<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Armadillo data types • cpp11armadillo</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Armadillo data types">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">cpp11armadillo</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/data-types.html">Armadillo data types</a></li>
    <li><a class="dropdown-item" href="../articles/usage.html">Basic 'cpp11armadillo' usage</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/pachadotdev/cpp11armadillo/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">



<script src="data-types_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Armadillo data types</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/pachadotdev/cpp11armadillo/blob/HEAD/vignettes/data-types.Rmd" class="external-link"><code>vignettes/data-types.Rmd</code></a></small>
      <div class="d-none name"><code>data-types.Rmd</code></div>
    </div>

    
    
<p>This vignette is adapted from the official Armadillo <a href="https://arma.sourceforge.net/docs.html" class="external-link">documentation</a>.</p>
<div class="section level2">
<h2 id="matrix-vector-cube-and-field-classes">Matrix, Vector, Cube and Field Classes<a class="anchor" aria-label="anchor" href="#matrix-vector-cube-and-field-classes"></a>
</h2>
<table class="table">
<colgroup>
<col width="30%">
<col width="69%">
</colgroup>
<thead><tr class="header">
<th>Class</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>Mat&lt;type&gt;</code></td>
<td>dense matrix class</td>
</tr>
<tr class="even">
<td><code>mat, cx_mat</code></td>
<td>dense matrix class</td>
</tr>
<tr class="odd">
<td><code>cx_mat</code></td>
<td>dense matrix class</td>
</tr>
<tr class="even">
<td><code>Col&lt;type&gt;</code></td>
<td>dense column vector class</td>
</tr>
<tr class="odd">
<td><code>colvec</code></td>
<td>dense column vector class</td>
</tr>
<tr class="even">
<td><code>vec</code></td>
<td>dense column vector class</td>
</tr>
<tr class="odd">
<td><code>Row&lt;type&gt;</code></td>
<td>dense row vector class</td>
</tr>
<tr class="even">
<td><code>rowvec</code></td>
<td>dense row vector class</td>
</tr>
<tr class="odd">
<td><code>Cube&lt;type&gt;</code></td>
<td>dense cube class (“3D matrix”)</td>
</tr>
<tr class="even">
<td><code>cube</code></td>
<td>dense cube class (“3D matrix”)</td>
</tr>
<tr class="odd">
<td><code>cx_cube</code></td>
<td>dense cube class (“3D matrix”)</td>
</tr>
<tr class="even">
<td><code>field&lt;object type&gt;</code></td>
<td>class for storing arbitrary objects in matrix-like or cube-like layouts</td>
</tr>
<tr class="odd">
<td><code>SpMat&lt;type&gt;</code></td>
<td>sparse matrix class</td>
</tr>
<tr class="even">
<td><code>sp_mat</code></td>
<td>sparse matrix class</td>
</tr>
<tr class="odd">
<td><code>sp_cx_mat</code></td>
<td>sparse matrix class</td>
</tr>
<tr class="even">
<td><code>+ - * % / == != &lt;= &gt;= &lt; &gt; &amp;&amp;</code></td>
<td>operators</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="matrix-class">Matrix class<a class="anchor" aria-label="anchor" href="#matrix-class"></a>
</h3>
<p><code>Mat&lt;type&gt;</code>, <code>mat</code> and <code>cx_mat</code> are classes for dense matrices, with elements stored in <a href="https://en.wikipedia.org/wiki/Column_major" class="external-link">column-major ordering</a> (e.g., column by column).</p>
<p>The root matrix class is <code>Mat&lt;type&gt;</code>, where <code>type</code> is one of:</p>
<ul>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>std::complex&lt;float&gt;</code></li>
<li><code>std::complex&lt;double&gt;</code></li>
<li><code>short</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>unsigned short</code></li>
<li><code>unsigned int</code></li>
<li><code>unsigned long</code></li>
</ul>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>mat = Mat&lt;double&gt;</code></li>
<li><code>dmat = Mat&lt;double&gt;</code></li>
<li><code>fmat = Mat&lt;float&gt;</code></li>
<li>
<code>cx_mat = Mat&lt;cx_double&gt;</code> (<code>cx_double</code> is a shortcut for <code>std::complex&lt;double&gt;</code>)</li>
<li><code>cx_dmat = Mat&lt;cx_double&gt;</code></li>
<li>
<code>cx_fmat = Mat&lt;cx_float&gt;</code> (<code>cx_float</code> is a shortcut for <code>std::complex&lt;float&gt;</code>)</li>
<li>
<code>umat = Mat&lt;uword&gt;</code> (<code>uword</code> is a shortcut for <code>unsigned int</code>)</li>
<li>
<code>imat = Mat&lt;sword&gt;</code> (<code>sword</code> is a shortcut for <code>signed int</code>)</li>
</ul>
<p>The <code>mat</code> type is used for convenience, and it is possible to use other matrix types (e.g, <code>fmat</code>, <code>cx_mat</code>) instead.</p>
<p>Matrix types with integer elements (such as <code>umat</code> and <code>imat</code>) cannot hold special values such as NaN and Inf.</p>
<p>Functions which use LAPACK (generally matrix decompositions) are only valid for the following matrix types: <code>mat</code>, <code>dmat</code>, <code>fmat</code>, <code>cx_mat</code>, <code>cx_dmat</code>, <code>cx_fmat</code>.</p>
<div class="section level4">
<h4 id="constructors">Constructors<a class="anchor" aria-label="anchor" href="#constructors"></a>
</h4>
<ul>
<li><code>mat()</code></li>
<li><code>mat(n_rows, n_cols)</code></li>
<li>
<code>mat(n_rows, n_cols, fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>mat(size(X))</code></li>
<li>
<code>mat(size(X), fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>mat(mat)</code></li>
<li><code>mat(vec)</code></li>
<li><code>mat(rowvec)</code></li>
<li><code>mat(initializer_list)</code></li>
<li><code>mat(string)</code></li>
<li>
<code>mat(std::vector)</code> (treated as a column vector)</li>
<li>
<code>mat(sp_mat)</code> (for converting a sparse matrix to a dense matrix)</li>
<li>
<code>cx_mat(mat,mat)</code> (for constructing a complex matrix out of two real matrices)</li>
</ul>
<p>The elements can be explicitly initialised during construction by specifying <code>fill_form</code>, which is one of:</p>
<ul>
<li>
<code>fill::zeros</code> set all elements to 0 (default in cpp11armadillo)</li>
<li>
<code>fill::ones</code> set all elements to 1</li>
<li>
<code>fill::eye</code> set the elements on the main diagonal to 1 and off-diagonal elements to 0</li>
<li>
<code>fill::randu</code> set all elements to random values from a uniform distribution in the [0,1] interval</li>
<li>
<code>fill::randn</code> set all elements to random values from a normal distribution with zero mean and unit variance</li>
<li>
<code>fill::value(scalar)</code> set all elements to specified scalar</li>
<li>
<code>fill::none</code> do not initialise the elements (matrix may have garbage values)</li>
</ul>
<p>For the <code>mat(string)</code> constructor, the format is elements separated by spaces, and rows denoted by semicolons; for example, the 2x2 identity matrix can be created using <code>"1 0; 0 1"</code>. Note that string based initialisation is slower than directly setting the elements or using element initialisation.</p>
<p>Each instance of <code>mat</code> automatically allocates and releases internal memory. All internally allocated memory used by an instance of mat is automatically released as soon as the instance goes out of scope. For example, if an instance of mat is declared inside a function, it will be automatically destroyed at the end of the function. To forcefully release memory at any point, use <code>.reset()</code>. Note that in normal use this is not required.</p>
</div>
<div class="section level4">
<h4 id="advanced-constructors">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors"></a>
</h4>
<ul>
<li>
<code>mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)</code>
<ul>
<li>Create a matrix using data from writable auxiliary (external) memory, where <code>ptr_aux_mem</code> is a pointer to the memory. By default the matrix allocates its own memory and copies data from the auxiliary memory (for safety). However, if <code>copy_aux_mem</code> is set to <code>false</code>, the matrix will instead directly use the auxiliary memory (e.g., no copying); this is faster, but can be dangerous unless you know what you are doing.<br>
</li>
<li>The <code>strict</code> parameter comes into effect only when copy_aux_mem is set to <code>false</code> (e.g., the matrix is directly using auxiliary memory).
<ul>
<li>When <code>strict</code> is set to <code>false</code>, the matrix will use the auxiliary memory until a size change or an aliasing event.</li>
<li>When <code>strict</code> is set to <code>true</code>, the matrix will be bound to the auxiliary memory for its lifetime; the number of elements in the matrix cannot be changed.</li>
</ul>
</li>
</ul>
</li>
<li>
<code>mat(const ptr_aux_mem, n_rows, n_cols)</code>
<ul>
<li>Create a matrix by copying data from read-only auxiliary memory, where <code>ptr_aux_mem</code> is a pointer to the memory</li>
</ul>
</li>
<li>
<code>mat::fixed&lt;n_rows, n_cols&gt;</code>
<ul>
<li>Create a fixed size matrix, with the size specified via template arguments. Memory for the matrix is reserved at compile time. This is generally faster than dynamic memory allocation, but the size of the matrix cannot be changed afterwards (directly or indirectly).<br>
</li>
<li>For convenience, there are several pre-defined typedefs for each matrix type (where the types are: <code>umat</code>, <code>imat</code>, <code>fmat</code>, <code>mat</code>, <code>cx_fmat</code>, <code>cx_mat</code>). The typedefs specify a square matrix size, ranging from 2x2 to 9x9. The typedefs were defined by appending a two digit form of the size to the matrix type. Examples: <code>mat33</code> is equivalent to <code>mat::fixed&lt;3,3&gt;</code>, and <code>cx_mat44</code> is equivalent to <code>cx_mat::fixed&lt;4,4&gt;</code>.</li>
</ul>
</li>
<li>
<code>mat::fixed&lt;n_rows, n_cols&gt;(fill_form)</code>
<ul>
<li>Create a fixed size matrix, with the elements explicitly initialised according to <code>fill_form</code>.</li>
</ul>
</li>
<li>
<code>mat::fixed&lt;n_rows, n_cols&gt;(const ptr_aux_mem)</code>
<ul>
<li>Create a fixed size matrix, with the size specified via template arguments; data is copied from auxiliary memory, where ptr_aux_mem is a pointer to the memory.</li>
</ul>
</li>
</ul>
</div>
<div class="section level4">
<h4 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h4>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">25</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">5</span>, ncol <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">matrix_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  mat A = as_Mat(a); <span class="co">// convert from R to C++</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="dt">double</span> x = A(<span class="dv">0</span>, <span class="dv">0</span>);  <span class="co">// access an element on row 1, column 1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  A = A + x; <span class="co">// scalar addition</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>      </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  mat B = A + A; <span class="co">// matrix addition</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  mat C = A * B; <span class="co">// matrix multiplication</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  mat D = A % B; <span class="co">// element-wise matrix multiplication</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>  mat res = B + C + D;</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// convert from C++ to R</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>}</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>      </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">matrix_fun2_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>  mat A = as_Mat(a);</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>  mat B = A + A;</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>  cx_mat X(A,B); <span class="co">// construct a complex matrix out of two real matrices</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>  B.zeros();                       <span class="co">// set all elements to zero</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>  B.set_size(A.n_rows, A.n_cols);  <span class="co">// resize the matrix</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>  B.ones(<span class="dv">5</span>, <span class="dv">6</span>);                    <span class="co">// same as mat B(5, 6, fill::ones)</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>        </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>  mat::fixed&lt;<span class="dv">5</span>,<span class="dv">6</span>&gt; F; <span class="co">// fixed size matrix</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a>      </span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a>  <span class="dt">double</span> aux_mem[<span class="dv">24</span>]; <span class="co">// auxiliary memory</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a>  mat H(&amp;aux_mem[<span class="dv">0</span>], <span class="dv">4</span>, <span class="dv">6</span>, <span class="kw">false</span>);  <span class="co">// use auxiliary memory</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a>  X = X + F.submat(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">4</span>) + H(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a>  Mat&lt;<span class="dt">double</span>&gt; res_real = real(X);</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true"></a>  Mat&lt;<span class="dt">double</span>&gt; res_imag = imag(X);</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true"></a>  writable::list res;</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true"></a>  res.push_back({<span class="st">"real"_nm</span> = as_doubles_matrix(res_real)});</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true"></a>  res.push_back({<span class="st">"imag"_nm</span> = as_doubles_matrix(res_imag)});</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="column-vector-class">Column vector class<a class="anchor" aria-label="anchor" href="#column-vector-class"></a>
</h3>
<p><code>Col&lt;type&gt;</code>, <code>vec</code> and <code>cx_vec</code> are classes for column vectors (dense matrices with one column).</p>
<p>The <code>Col&lt;type&gt;</code> class is derived from the <code>Mat&lt;type&gt;</code> class and inherits most of the member functions.</p>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>vec = colvec = Col&lt;double&gt;</code></li>
<li><code>dvec = dcolvec = Col&lt;double&gt;</code></li>
<li><code>fvec = fcolvec = Col&lt;float&gt;</code></li>
<li><code>cx_vec = cx_colvec = Col&lt;[cx_double](#cx_double)&gt;</code></li>
<li><code>cx_dvec = cx_dcolvec = Col&lt;[cx_double](#cx_double)&gt;</code></li>
<li><code>cx_fvec = cx_fcolvec = Col&lt;[cx_float](#cx_double)&gt;</code></li>
<li><code>uvec = ucolvec = Col&lt;[uword](#uword)&gt;</code></li>
<li><code>ivec = icolvec = Col&lt;[sword](#uword)&gt;</code></li>
</ul>
<p>The <code>vec</code> and <code>colvec</code> types have the same meaning and are used interchangeably.</p>
<p>The types <code>vec</code> or <code>colvec</code> are used for convenience. It is possible to use other column vector types instead (e.g., <code>fvec</code> or <code>fcolvec</code>).</p>
<p>Functions which take <code>mat</code> as input can generally also take <code>Col</code> as input. Main exceptions are functions that require square matrices.</p>
<div class="section level4">
<h4 id="constructors-1">Constructors:<a class="anchor" aria-label="anchor" href="#constructors-1"></a>
</h4>
<ul>
<li><code>vec()</code></li>
<li><code>vec(_n_elem_)</code></li>
<li>
<code>vec(_n_elem, fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>vec(size(X))</code></li>
<li>
<code>vec(size(X), fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>vec(vec)</code></li>
<li>
<code>vec(mat)</code> (<code>std::logic_error</code> exception is thrown if the given matrix has more than one column)</li>
<li><code>vec(initializer_list)</code></li>
<li>
<code>vec(string)</code> (elements separated by spaces)</li>
<li><code>vec(std::vector)</code></li>
<li>
<code>cx_vec(vec,vec)</code> (for constructing a complex vector out of two real vectors)</li>
</ul>
</div>
<div class="section level4">
<h4 id="advanced-constructors-1">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors-1"></a>
</h4>
<ul>
<li>
<code>vec(ptr_aux_mem, number_of_elements, copy_aux_mem = true, strict = false)</code>
<ul>
<li>Create a column vector using data from writable auxiliary (external) memory, where ptr_aux_mem is a pointer to the memory. By default the vector allocates its own memory and copies data from the auxiliary memory (for safety). However, if copy_aux_mem is set to <code>false</code>, the vector will instead directly use the auxiliary memory (e.g., no copying). This is faster, but can be dangerous unless you know what you are doing.</li>
<li>The <code>strict</code> parameter comes into effect only when copy_aux_mem is set to <code>false</code> (e.g., the vector is directly using auxiliary memory)
<ul>
<li>When <code>strict</code> is set to <code>false</code>, the vector will use the auxiliary memory until a size change or an aliasing event.</li>
<li>When <code>strict</code> is set to <code>true</code>, the vector will be bound to the auxiliary memory for its lifetime; the number of elements in the vector cannot be changed.</li>
</ul>
</li>
</ul>
</li>
<li>
<code>vec(const ptr_aux_mem, number_of_elements)</code>
<ul>
<li>Create a column vector by copying data from read-only auxiliary memory, where ptr_aux_mem is a pointer to the memory</li>
</ul>
</li>
<li>
<code>vec::fixed&lt;number_of_elements&gt;</code>
<ul>
<li>Create a fixed size column vector, with the size specified via the template argument. Memory for the vector is reserved at compile time. This is generally faster than dynamic memory allocation, but the size of the vector cannot be changed afterwards (directly or indirectly).<br>
</li>
<li>For convenience, there are several pre-defined typedefs for each vector type (where the types are: <code>uvec</code>, <code>ivec</code>, <code>fvec</code>, <code>vec</code>, <code>cx_fvec</code>, <code>cx_vec</code> as well as the corresponding <code>colvec</code> versions). The pre-defined typedefs specify vector sizes ranging from 2 to 9. The typedefs were defined by appending a single digit form of the size to the vector type. Examples: <code>vec3</code> is equivalent to <code>vec::fixed&lt;3&gt;</code>, and <code>cx_vec4</code> is equivalent to <code>cx_vec::fixed&lt;4&gt;</code>.</li>
</ul>
</li>
<li>
<code>vec::fixed&lt;number_of_elements&gt;(fill_form)</code>
<ul>
<li>Create a fixed size column vector, with the elements explicitly initialised according to <code>fill_form</code>.</li>
</ul>
</li>
<li>
<code>vec::fixed&lt;number_of_elements&gt;(const ptr_aux_mem)</code>
<ul>
<li>Create a fixed size column vector, with the size specified via the template argument; data is copied from auxiliary memory, where ptr_aux_mem is a pointer to the memory.</li>
</ul>
</li>
</ul>
</div>
<div class="section level4">
<h4 id="examples-1">Examples<a class="anchor" aria-label="anchor" href="#examples-1"></a>
</h4>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">column_fun1_</span>(<span class="at">const</span> doubles&amp; x, <span class="at">const</span> doubles&amp; y) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  vec X = as_Col(x); <span class="co">// convert from R to C++</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  vec Y = as_Col(y);</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  mat A(<span class="dv">10</span>, <span class="dv">10</span>, fill::randu);</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  vec Z = A.col(<span class="dv">5</span>); <span class="co">// extract a column vector</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  Z = Z + Y + X;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(Z); <span class="co">// convert from C++ to R</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="row-vector-class">Row vector class<a class="anchor" aria-label="anchor" href="#row-vector-class"></a>
</h3>
<p><code>Row&lt;type&gt;</code>, <code>rowvec</code> and <code>cx_rowvec</code> are classes for row vectors (dense matrices with one row).</p>
<p>The template <code>Row&lt;type&gt;</code> class is derived from the <code>Mat&lt;type&gt;</code> class and inherits most of the member functions.</p>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>rowvec = Row&lt;double&gt;</code></li>
<li><code>drowvec = Row&lt;double&gt;</code></li>
<li><code>frowvec = Row&lt;float&gt;</code></li>
<li><code>cx_rowvec = Row&lt;cx_double&gt;</code></li>
<li><code>cx_drowvec = Row&lt;cx_double&gt;</code></li>
<li><code>cx_frowvec = Row&lt;cx_float&gt;</code></li>
<li><code>urowvec = Row&lt;uword&gt;</code></li>
<li><code>irowvec = Row&lt;sword&gt;</code></li>
</ul>
<p>The <code>rowvec</code> type is used for convenience. It is possible to use other row vector types instead (e.g., <code>frowvec</code>).</p>
<p>Functions which take <code>mat</code> as input can generally also take <code>Row</code> as input. Main exceptions are functions which require square matrices.</p>
<div class="section level4">
<h4 id="constructors-2">Constructors<a class="anchor" aria-label="anchor" href="#constructors-2"></a>
</h4>
<ul>
<li><code>rowvec()</code></li>
<li><code>rowvec(n_elem)</code></li>
<li>
<code>rowvec(n_elem, fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>rowvec(size(X))</code></li>
<li>
<code>rowvec(size(X), fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>rowvec(rowvec)</code></li>
<li>
<code>rowvec(mat)</code> (<code>std::logic_error</code> exception is thrown if the given matrix has more than one row)</li>
<li><code>rowvec(initializer_list)</code></li>
<li>
<code>rowvec(string)</code> (elements separated by spaces)</li>
<li><code>rowvec(std::vector)</code></li>
<li>
<code>cx_rowvec(rowvec,rowvec)</code> (for constructing a complex row vector out of two real row vectors)</li>
</ul>
</div>
<div class="section level4">
<h4 id="advanced-constructors-2">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors-2"></a>
</h4>
<ul>
<li>
<code>rowvec(ptr_aux_mem, number_of_elements, copy_aux_mem = true, strict = false)</code>
<ul>
<li>Create a row vector using data from writable auxiliary (external) memory, where ptr_aux_mem is a pointer to the memory. By default the vector allocates its own memory and copies data from the auxiliary memory (for safety). However, if copy_aux_mem is set to <code>false</code>, the vector will instead directly use the auxiliary memory (e.g., no copying); this is faster, but can be dangerous unless you know what you are doing.</li>
<li>The <code>strict</code> parameter comes into effect only when copy_aux_mem is set to <code>false</code> (e.g., the vector is directly using auxiliary memory).
<ul>
<li>When <code>strict</code> is set to <code>false</code>, the vector will use the auxiliary memory until a size change or an aliasing event.</li>
<li>When <code>strict</code> is set to <code>true</code>, the vector will be bound to the auxiliary memory for its lifetime; the number of elements in the vector cannot be changed.</li>
</ul>
</li>
</ul>
</li>
<li>
<code>rowvec(const ptr_aux_mem, number_of_elements)</code>
<ul>
<li>Create a row vector by copying data from read-only auxiliary memory, where <code>ptr_aux_mem</code> is a pointer to the memory.</li>
</ul>
</li>
<li>
<code>rowvec::fixed&lt;number_of_elements&gt;</code>
<ul>
<li>Create a fixed size row vector, with the size specified via the template argument. Memory for the vector is reserved at compile time. This is generally faster than dynamic memory allocation, but the size of the vector cannot be changed afterwards (directly or indirectly).</li>
<li>For convenience, there are several pre-defined typedefs for each vector type (where the types are: <code>urowvec</code>, <code>irowvec</code>, <code>frowvec</code>, <code>rowvec</code>, <code>cx_frowvec</code>, <code>cx_rowvec</code>). The pre-defined typedefs specify vector sizes ranging from 2 to 9. The typedefs were defined by appending a single digit form of the size to the vector type. Examples: <code>rowvec3</code> is equivalent to <code>rowvec::fixed&lt;3&gt;</code>, and <code>cx_rowvec4</code> is equivalent to <code>cx_rowvec::fixed&lt;4&gt;</code>.</li>
</ul>
</li>
<li>
<code>rowvec::fixed&lt;number_of_elements&gt;(fill_form)</code>
<ul>
<li>Create a fixed size row vector, with the elements explicitly initialised according to <code>fill_form</code>.</li>
</ul>
</li>
<li>
<code>rowvec::fixed&lt;number_of_elements&gt;(const ptr_aux_mem)</code>
<ul>
<li>Create a fixed size row vector, with the size specified via the template argument; data is copied from auxiliary memory, where ptr_aux_mem is a pointer to the memory.</li>
</ul>
</li>
</ul>
</div>
<div class="section level4">
<h4 id="examples-2">Examples<a class="anchor" aria-label="anchor" href="#examples-2"></a>
</h4>
<p>⚠️Important⚠️: ‘cpp11armadillo’ is an opinionated package and it follows the notation from Econometrics by Bruce E. Hansen. It intentionally exports/imports matrices and column vectors. You can use row vectors in the functions, but the communication between R and C++ does not accept row vectors unless you transpose or convert those to matrices.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">row_fun1_</span>(<span class="at">const</span> doubles&amp; x, <span class="at">const</span> doubles&amp; y) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  vec X = as_Col(x);  <span class="co">// convert from R to C++</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  vec Y = as_Col(y);</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>  mat A(<span class="dv">10</span>, <span class="dv">10</span>, fill::randu);</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>  </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  rowvec Z = A.row(<span class="dv">5</span>);  <span class="co">// extract a row vector</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  Z = Z + Y.t() + X.t(); <span class="co">// transpose Y and X to be able to sum</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  vec res = Z.t();</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>  </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(res);  <span class="co">// convert from C++ to R</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="cube-class">Cube class<a class="anchor" aria-label="anchor" href="#cube-class"></a>
</h3>
<p><code>Cube&lt;type&gt;</code>, <code>cube</code> and <code>cx_cube</code> are classes for cubes, also known as quasi 3rd order tensors or “3D matrices”.</p>
<p>The data is stored as a set of slices (matrices) stored contiguously within memory. Within each slice, elements are stored with column-major ordering (e.g., column by column)</p>
<p>The root cube class is <code>Cube&lt;type&gt;</code>, where <code>type</code> is one of: <code>float</code>, <code>double</code>, <code>std::complex&lt;float&gt;</code>, <code>std::complex&lt;double&gt;</code>, <code>short</code>, <code>int</code>, <code>long</code> and unsigned versions of <code>short</code>, <code>int</code>, <code>long</code>.</p>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>cube = Cube&lt;double&gt;</code></li>
<li><code>dcube = Cube&lt;double&gt;</code></li>
<li><code>fcube = Cube&lt;float&gt;</code></li>
<li><code>cx_cube = Cube&lt;cx_double&gt;</code></li>
<li><code>cx_dcube = Cube&lt;cx_double&gt;</code></li>
<li><code>cx_fcube = Cube&lt;cx_float&gt;</code></li>
<li><code>ucube = Cube&lt;uword&gt;</code></li>
<li><code>icube = Cube&lt;sword&gt;</code></li>
</ul>
<p>The <code>cube</code> type is used for convenience; it is possible to use other types instead (e.g., <code>fcube</code>)</p>
<div class="section level4">
<h4 id="constructors-3">Constructors<a class="anchor" aria-label="anchor" href="#constructors-3"></a>
</h4>
<ul>
<li><code>cube()</code></li>
<li><code>cube(n_rows, n_cols, n_slices_)</code></li>
<li>
<code>cube(n_rows, n_cols, n_slices, fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>cube(size(X))</code></li>
<li>
<code>cube(size(X), fill_form)</code> (elements are initialised according to <code>fill_form</code>)</li>
<li><code>cube(cube)</code></li>
<li>
<code>cx_cube(cube, cube)</code> (for constructing a complex cube out of two real cubes)</li>
</ul>
<p>The elements can be explicitly initialised during construction by specifying <code>fill_form</code>, which is one of:</p>
<ul>
<li>
<code>fill::zeros</code>: set all elements to 0 (default in cpp11armadillo)</li>
<li>
<code>fill::ones</code>: set all elements to 1</li>
<li>
<code>fill::randu</code>: set all elements to random values from a uniform distribution in the [0,1] interval</li>
<li>
<code>fill::randn</code>: set all elements to random values from a normal distribution with zero mean and unit variance</li>
<li>
<code>fill::value(scalar)</code>: set all elements to specified scalar</li>
<li>
<code>fill::none</code>: do not initialise the elements (cube may have garbage values)</li>
</ul>
<p>Each instance of <code>cube</code> automatically allocates and releases internal memory. All internally allocated memory used by an instance of <code>cube</code> is automatically released as soon as the instance goes out of scope. For example, if an instance of <code>cube</code> is declared inside a function, it will be automatically destroyed at the end of the function. To forcefully release memory at any point, use <code>.reset()</code> note that in normal use this is not required.</p>
</div>
<div class="section level4">
<h4 id="advanced-constructors-3">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors-3"></a>
</h4>
<ul>
<li>
<code>cube::fixed&lt;n_rows, n_cols, n_slices&gt;</code>
<ul>
<li>Create a fixed size cube, with the size specified via template arguments. Memory for the cube is reserved at compile time. This is generally faster than dynamic memory allocation, but the size of the cube can’t be changed afterwards (directly or indirectly).</li>
</ul>
</li>
<li>
<code>cube(ptr_aux_mem, n_rows, n_cols, n_slices, copy_aux_mem = true, strict = false)</code>
<ul>
<li>Create a cube using data from writable auxiliary (external) memory, where <code>ptr_aux_mem</code> is a pointer to the memory. By default the cube allocates its own memory and copies data from the auxiliary memory (for safety). However, if <code>copy_aux_mem</code> is set to <code>false</code>, the cube will instead directly use the auxiliary memory (e.g., no copying). This is faster, but can be dangerous unless you know what you are doing.</li>
<li>The <code>strict</code> parameter comes into effect only when <code>copy_aux_mem</code> is set to <code>false</code> (e.g., the cube is directly using auxiliary memory)
<ul>
<li>When <code>strict</code> is set to <code>false</code>, the cube will use the auxiliary memory until a size change or an aliasing event</li>
<li>When <code>strict</code> is set to <code>true</code>, the cube will be bound to the auxiliary memory for its lifetime; the number of elements in the cube can’t be changed</li>
</ul>
</li>
</ul>
</li>
<li>
<code>cube(const ptr_aux_mem, n_rows, n_cols, n_slices)</code>
<ul>
<li>Create a cube by copying data from read-only auxiliary memory, where <code>ptr_aux_mem</code> is a pointer to the memory.</li>
</ul>
</li>
</ul>
</div>
<div class="section level4">
<h4 id="examples-3">Examples<a class="anchor" aria-label="anchor" href="#examples-3"></a>
</h4>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">b</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">cube_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>                                                <span class="at">const</span> doubles_matrix&lt;&gt;&amp; b) {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  mat B = as_Mat(b);</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  cube X(A.n_rows, A.n_cols, <span class="dv">2</span>);  <span class="co">// create a cube with 2 slices</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  X.slice(<span class="dv">0</span>) = A;                 <span class="co">// copy A into first slice</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  X.slice(<span class="dv">1</span>) = B;                 <span class="co">// copy B into second slice</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  cube Y = X + X;  <span class="co">// cube addition</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  cube Z = X % X;  <span class="co">// element-wise cube multiplication</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  mat res = Y.slice(<span class="dv">0</span>) + Z.slice(<span class="dv">1</span>);</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// convert from C++ to R</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level4">
<h4 id="notes">Notes<a class="anchor" aria-label="anchor" href="#notes"></a>
</h4>
<ul>
<li>Each cube slice can be interpreted as a matrix, hence functions which take <code>Mat</code> as input can generally also take cube slices as input</li>
<li>The size of individual slices can’t be changed. For example, the following will not work:</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>cube c(<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>);</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>c.slice(<span class="dv">0</span>) = randu&lt;mat&gt;(<span class="dv">10</span>,<span class="dv">20</span>); <span class="co">// wrong size</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="field-class">Field class<a class="anchor" aria-label="anchor" href="#field-class"></a>
</h3>
<p><code>field&lt;object_type&gt;</code> is a class for storing arbitrary objects in matrix-like or cube-like layouts.</p>
<p>It is similar to a matrix or cube, but instead of each element being a scalar, each element can be a vector, or matrix, or cube. This is similar to a list in R.</p>
<p>Each element can have an arbitrary size (e.g., in a field of matrices, each matrix can have a unique size).</p>
<div class="section level4">
<h4 id="constructors-4">Constructors<a class="anchor" aria-label="anchor" href="#constructors-4"></a>
</h4>
<p><code>object_type</code> is another class (e.g., <code>vec</code>, <code>mat</code>, <code>std::string</code>, etc)</p>
<ul>
<li><p><code>field&lt;object_type&gt;()</code></p></li>
<li><p><code>field&lt;object_type&gt;(n_elem)</code></p></li>
<li><p><code>field&lt;object_type&gt;(n_rows, n_cols)</code><br></p></li>
<li><p><code>field&lt;object_type&gt;(n_rows, n_cols, n_slices)</code></p></li>
<li><p><code>field&lt;object_type&gt;(size(X))</code></p></li>
<li><p><code>field&lt;object_type&gt;(field&lt;object_type&gt;)</code></p></li>
<li><p>Examples:</p></li>
</ul>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">b</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">field_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a,</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>                                                 <span class="at">const</span> doubles_matrix&lt;&gt;&amp; b) {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  mat B = as_Mat(b);</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>  field&lt;mat&gt; F(A.n_rows, A.n_cols, <span class="dv">3</span>);  <span class="co">// create a field with 2 matrices</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  F(<span class="dv">0</span>) = A;                             <span class="co">// copy A into first location</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>  F(<span class="dv">1</span>) = B;                             <span class="co">// copy B into second location</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>  F(<span class="dv">2</span>) = F(<span class="dv">0</span>) + F(<span class="dv">1</span>);                   <span class="co">// matrix addition</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>  mat res = F(<span class="dv">0</span>) + F(<span class="dv">1</span>) + F(<span class="dv">2</span>).t();</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// convert from C++ to R</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level4">
<h4 id="note">Note<a class="anchor" aria-label="anchor" href="#note"></a>
</h4>
<p>To store a set of matrices of the same size, the <a href="#Cube">Cube</a> class is more efficient.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="member-functions-variables">Member Functions &amp; Variables<a class="anchor" aria-label="anchor" href="#member-functions-variables"></a>
</h2>
<table class="table">
<colgroup>
<col width="19%">
<col width="80%">
</colgroup>
<thead><tr class="header">
<th>Function/Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.n_rows</code></td>
<td>number of rows</td>
</tr>
<tr class="even">
<td><code>.n_cols</code></td>
<td>number of columns</td>
</tr>
<tr class="odd">
<td><code>.n_elem</code></td>
<td>number of elements</td>
</tr>
<tr class="even">
<td><code>.n_slices</code></td>
<td>number of slices</td>
</tr>
<tr class="odd">
<td><code>()</code></td>
<td>element access</td>
</tr>
<tr class="even">
<td><code>[]</code></td>
<td>element access</td>
</tr>
<tr class="odd">
<td><code>.at()</code></td>
<td>element access</td>
</tr>
<tr class="even">
<td><code>.zeros</code></td>
<td>set all elements to zero</td>
</tr>
<tr class="odd">
<td><code>.ones</code></td>
<td>set all elements to one</td>
</tr>
<tr class="even">
<td><code>.eye</code></td>
<td>set elements along main diagonal to one and off-diagonal elements to zero</td>
</tr>
<tr class="odd">
<td><code>.randu</code></td>
<td>set all elements to random values from a uniform distribution</td>
</tr>
<tr class="even">
<td><code>.randn</code></td>
<td>set all elements to random values from a normal distribution</td>
</tr>
<tr class="odd">
<td><code>.fill</code></td>
<td>set all elements to specified value</td>
</tr>
<tr class="even">
<td><code>.imbue</code></td>
<td>imbue (fill) with values provided by functor or lambda function</td>
</tr>
<tr class="odd">
<td><code>.clean</code></td>
<td>replace elements below a threshold with zeros</td>
</tr>
<tr class="even">
<td><code>.replace</code></td>
<td>replace specific elements with a new value</td>
</tr>
<tr class="odd">
<td><code>.clamp</code></td>
<td>clamp values to lower and upper limits</td>
</tr>
<tr class="even">
<td><code>.transform</code></td>
<td>transform each element via functor or lambda function</td>
</tr>
<tr class="odd">
<td><code>.for_each</code></td>
<td>apply a functor or lambda function to each element</td>
</tr>
<tr class="even">
<td><code>.set_size</code></td>
<td>change size without keeping elements (fast)</td>
</tr>
<tr class="odd">
<td><code>.reshape</code></td>
<td>change size while keeping elements</td>
</tr>
<tr class="even">
<td><code>.resize</code></td>
<td>change size while keeping elements and preserving layout</td>
</tr>
<tr class="odd">
<td><code>.copy_size</code></td>
<td>change size to be same as given object</td>
</tr>
<tr class="even">
<td><code>.reset</code></td>
<td>change size to empty</td>
</tr>
<tr class="odd">
<td><code>.diag</code></td>
<td>read/write access to matrix diagonals</td>
</tr>
<tr class="even">
<td><code>.each_col</code></td>
<td>vector operations applied to each column of matrix (aka “broadcasting”)</td>
</tr>
<tr class="odd">
<td><code>.each_row</code></td>
<td>vector operations applied to each row of matrix (aka “broadcasting”)</td>
</tr>
<tr class="even">
<td><code>.each_slice</code></td>
<td>matrix operations applied to each slice of cube (aka “broadcasting”)</td>
</tr>
<tr class="odd">
<td><code>.set_imag</code></td>
<td>set imaginary part</td>
</tr>
<tr class="even">
<td><code>.set_real</code></td>
<td>set real part</td>
</tr>
<tr class="odd">
<td><code>.insert_rows</code></td>
<td>insert vector/matrix/cube at specified row</td>
</tr>
<tr class="even">
<td><code>.insert_cols</code></td>
<td>insert vector/matrix/cube at specified column</td>
</tr>
<tr class="odd">
<td><code>.insert_slices</code></td>
<td>insert vector/matrix/cube at specified slice</td>
</tr>
<tr class="even">
<td><code>.shed_rows</code></td>
<td>remove specified rows</td>
</tr>
<tr class="odd">
<td><code>.shed_cols</code></td>
<td>remove specified columns</td>
</tr>
<tr class="even">
<td><code>.shed_slices</code></td>
<td>remove specified slices</td>
</tr>
<tr class="odd">
<td><code>.swap_rows</code></td>
<td>swap specified rows</td>
</tr>
<tr class="even">
<td><code>.swap_cols</code></td>
<td>swap specified columns</td>
</tr>
<tr class="odd">
<td><code>.swap</code></td>
<td>swap contents with given object</td>
</tr>
<tr class="even">
<td><code>.memptr</code></td>
<td>raw pointer to memory</td>
</tr>
<tr class="odd">
<td><code>.colptr</code></td>
<td>raw pointer to memory used by specified column</td>
</tr>
<tr class="even">
<td><code>.as_col</code></td>
<td>return flattened matrix column as column vector</td>
</tr>
<tr class="odd">
<td><code>.as_row</code></td>
<td>return flattened matrix row as row vector</td>
</tr>
<tr class="even">
<td><code>.col_as_mat</code></td>
<td>return matrix representation of cube column</td>
</tr>
<tr class="odd">
<td><code>.row_as_mat</code></td>
<td>return matrix representation of cube row</td>
</tr>
<tr class="even">
<td><code>.as_dense</code></td>
<td>return dense vector/matrix representation of sparse matrix expression</td>
</tr>
<tr class="odd">
<td><code>.t</code></td>
<td>return matrix transpose</td>
</tr>
<tr class="even">
<td><code>.st</code></td>
<td>return matrix conjugate transpose</td>
</tr>
<tr class="odd">
<td><code>.i</code></td>
<td>return inverse of square matrix</td>
</tr>
<tr class="even">
<td><code>.min</code></td>
<td>return minimum value</td>
</tr>
<tr class="odd">
<td><code>.max</code></td>
<td>return maximum value</td>
</tr>
<tr class="even">
<td><code>.index_min</code></td>
<td>return index of minimum value</td>
</tr>
<tr class="odd">
<td><code>.index_max</code></td>
<td>return index of maximum value</td>
</tr>
<tr class="even">
<td><code>.eval</code></td>
<td>force evaluation of delayed expression</td>
</tr>
<tr class="odd">
<td><code>.in_range</code></td>
<td>check whether given location or span is valid</td>
</tr>
<tr class="even">
<td><code>.is_empty</code></td>
<td>check whether object is empty</td>
</tr>
<tr class="odd">
<td><code>.is_vec</code></td>
<td>check whether matrix is a vector</td>
</tr>
<tr class="even">
<td><code>.is_sorted</code></td>
<td>check whether vector or matrix is sorted</td>
</tr>
<tr class="odd">
<td><code>.is_trimatu</code></td>
<td>check whether matrix is upper triangular</td>
</tr>
<tr class="even">
<td><code>.is_trimatl</code></td>
<td>check whether matrix is lower triangular</td>
</tr>
<tr class="odd">
<td><code>.is_diagmat</code></td>
<td>check whether matrix is diagonal</td>
</tr>
<tr class="even">
<td><code>.is_square</code></td>
<td>check whether matrix is square sized</td>
</tr>
<tr class="odd">
<td><code>.is_symmetric</code></td>
<td>check whether matrix is symmetric</td>
</tr>
<tr class="even">
<td><code>.is_hermitian</code></td>
<td>check whether matrix is hermitian</td>
</tr>
<tr class="odd">
<td><code>.is_sympd</code></td>
<td>check whether matrix is symmetric/hermitian positive definite</td>
</tr>
<tr class="even">
<td><code>.is_zero</code></td>
<td>check whether all elements are zero</td>
</tr>
<tr class="odd">
<td><code>.is_finite</code></td>
<td>check whether all elements are finite</td>
</tr>
<tr class="even">
<td><code>.has_inf</code></td>
<td>check whether any element is +/- infinity</td>
</tr>
<tr class="odd">
<td><code>.has_nan</code></td>
<td>check whether any element is NaN</td>
</tr>
<tr class="even">
<td><code>.print</code></td>
<td>print object to <code>_std::cout_</code> or user specified stream (cpp11armadillo redirects to R messages)</td>
</tr>
<tr class="odd">
<td><code>.raw_print</code></td>
<td>print object without formatting</td>
</tr>
<tr class="even">
<td><code>.brief_print</code></td>
<td>print object in shortened/abridged form</td>
</tr>
<tr class="odd">
<td><code>.save</code></td>
<td>save matrix or cube (cpp11armadillo reads from R and sends data back to R)</td>
</tr>
<tr class="even">
<td><code>.load</code></td>
<td>load matrix or cube (cpp11armadillo reads from R and sends data back to R)</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="attributes">Attributes<a class="anchor" aria-label="anchor" href="#attributes"></a>
</h3>
<p><code>.n_rows</code> number of rows; present in <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code> and <code>SpMat</code> <code>.n_cols</code> number of columns; present in <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code> and <code>SpMat</code> <code>.n_elem</code> total number of elements; present in <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code> and <code>SpMat</code> <code>.n_slices</code> number of slices; present in <code>Cube</code> and <code>field</code> <code>.n_nonzero</code> number of non-zero elements; present in <code>SpMat</code></p>
<p>The variables are of type <code>uword</code></p>
<p>The variables are read-only; to change the size, use <code>set_size</code>, <code>copy_size</code>, <code>zeros_member</code>, <code>ones_member</code>, or <code>reset</code>.</p>
<p>For the <code>Col</code> and <code>Row</code> classes, <em>n_elem</em> also indicates vector length</p>
<div class="section level4">
<h4 id="examples-4">Examples:<a class="anchor" aria-label="anchor" href="#examples-4"></a>
</h4>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">attr_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="co">// uword or int can be used</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>  <span class="dt">int</span> n_rows = A.n_rows;  <span class="co">// number of rows</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>  <span class="dt">int</span> n_cols = A.n_cols;  <span class="co">// number of columns</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>  <span class="dt">int</span> n_elem = A.n_elem;  <span class="co">// number of elements</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>  writable::integers res({n_rows, n_cols, n_elem});</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"n_rows"</span>, <span class="st">"n_cols"</span>, <span class="st">"n_elem"</span>});</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="elementobject-access">Element/object access<a class="anchor" aria-label="anchor" href="#elementobject-access"></a>
</h3>
<p>Provide access to individual elements or objects stored in a container object (e.g., <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code>)</p>
<ul>
<li>
<code>(i)</code> For <code>vec</code> and <code>rowvec</code>, access the element stored at index <code>i</code>. For <code>Mat</code>, <code>Cube</code> and <code>field</code>, access the element/object stored at index <code>i</code> under the assumption of a flat layout, with column-major ordering of data (e.g., column by column). An exception is thrown if the requested element is out of bounds.</li>
<li>
<code>.at(i)</code> or <code>[i]</code> As for <code>(i)</code>, but without a bounds check; not recommended.</li>
<li>
<code>(r,c)</code> For <code>Mat</code> and 2D field classes, access the element/object stored at row <code>r</code> and column <code>c</code>. An exception is thrown if the requested element is out of bounds.</li>
<li>
<code>.at(r,c)</code> As for <code>(r,c)</code>, but without a bounds check; not recommended.</li>
<li>
<code>(r,c,s)</code> For <code>Cube</code> and 3D field classes, access the element/object stored at row <code>r</code>, column <code>c</code>, and slice <em>s</em>. An exception is thrown if the requested element is out of bounds.</li>
<li>
<code>.at(r,c,s)</code> As for <code>(r,c,s)</code>, but without a bounds check; not recommended.</li>
</ul>
<div class="section level4">
<h4 id="caveats">Caveats<a class="anchor" aria-label="anchor" href="#caveats"></a>
</h4>
<p>For <code>.at()</code> or <code>[i]</code>, <code>.at(r,c)</code>, and <code>.at(r,c,s)</code>:</p>
<ul>
<li>Indexing in C++ starts at 0</li>
<li>Accessing elements without bounds checks is slightly faster, but is not recommended until your code has been thoroughly debugged first</li>
<li>Accessing elements via <code>[r,c]</code> and <code>[r,c,s]</code> does not work correctly in C++; instead use <code>(r,c)</code> and <code>(r,c,s)</code>
</li>
</ul>
<p>The indices of elements are specified via the <code>uword</code> type, which is a <code>typedef</code> for an unsigned integer type. When using loops to access elements, it is best to use <code>uword</code> instead of <code>int</code>. For example: <code>for(uword i=0; i&lt;X.n_elem; ++i) { X(i) = ... }</code></p>
</div>
<div class="section level4">
<h4 id="examples-5">Examples<a class="anchor" aria-label="anchor" href="#examples-5"></a>
</h4>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">access_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  A(<span class="dv">1</span>,<span class="dv">1</span>) = <span class="fl">123.0</span>;     <span class="co">// set element at row 2, column 2</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  vec B(<span class="dv">2</span>, fill::randu);</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="dt">double</span> x = A(<span class="dv">0</span>,<span class="dv">1</span>);  <span class="co">// copy element at row 1, column 2 to a double</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>  <span class="dt">double</span> y = B(<span class="dv">1</span>);    <span class="co">// copy element at coordinate 2 to a double</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>  uword i, j; <span class="co">// int also works</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>  uword N = A.n_rows;</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>  uword M = A.n_cols;</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>  <span class="cf">for</span>(i = <span class="dv">0</span>; i &lt; N; ++i) {</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>    <span class="cf">for</span>(j = <span class="dv">0</span>; j &lt; M; ++j) {</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>      A(i,j) = A(i,j) + x + y;</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>    }</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a>  }</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// convert from C++ to R</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="element-initialisation">Element initialisation<a class="anchor" aria-label="anchor" href="#element-initialisation"></a>
</h3>
<p>Set elements in <code>Mat</code>, <code>Col</code>, <code>Row</code> via braced initialiser lists</p>
<div class="section level4">
<h4 id="examples-6">Examples<a class="anchor" aria-label="anchor" href="#examples-6"></a>
</h4>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">initialization_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  mat B = {{<span class="dv">1</span>, <span class="dv">2</span>}, {<span class="dv">3</span>, <span class="dv">4</span>}}; <span class="co">// create new matrix</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  vec C = {<span class="dv">1</span>, <span class="dv">2</span>}; <span class="co">// create new column vector</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  <span class="co">// sum C to the diagonal of A</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  A(<span class="dv">0</span>,<span class="dv">0</span>) = A(<span class="dv">0</span>,<span class="dv">0</span>) + C(<span class="dv">0</span>);</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  A(<span class="dv">1</span>,<span class="dv">1</span>) = A(<span class="dv">1</span>,<span class="dv">1</span>) + C(<span class="dv">1</span>);</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  mat D = A + B;</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>  </span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="zeros">Zeros<a class="anchor" aria-label="anchor" href="#zeros"></a>
</h3>
<p>Set the elements of an object to zero, optionally first changing the size to specified dimensions</p>
<p><code>.zeros()</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>SpMat</code>, <code>Cube</code>) <code>.zeros(n_elem)</code> (member function of <code>Col</code> and <code>Row</code>) <code>.zeros(n_rows, n_cols)</code> (member function of <code>Mat</code> and <code>SpMat</code>) <code>.zeros(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>) <code>.zeros(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>)</p>
<div class="section level4">
<h4 id="examples-7">Examples<a class="anchor" aria-label="anchor" href="#examples-7"></a>
</h4>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">zeros_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  A.zeros();          <span class="co">// set all elements to zero</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  B.zeros(size(A)); <span class="co">// set size to be the same as A and set all elements to zero</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::zeros);</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="ones">Ones<a class="anchor" aria-label="anchor" href="#ones"></a>
</h3>
<p>Set all the elements of an object to one, optionally first changing the size to specified dimensions</p>
<p><code>ones()</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>) <code>ones(n_elem)</code> (member function of <code>Col</code> and <code>Row</code>) <code>ones(n_rows, n_cols)</code> (member function of <code>Mat</code>) <code>ones(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>) <code>ones(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>)</p>
<div class="section level4">
<h4 id="examples-8">Examples<a class="anchor" aria-label="anchor" href="#examples-8"></a>
</h4>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">ones_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  A.ones();          <span class="co">// set all elements to zero</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  B.ones(size(A)); <span class="co">// set size to be the same as A and set all elements to zero</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::ones);</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="eye">Eye<a class="anchor" aria-label="anchor" href="#eye"></a>
</h3>
<ul>
<li>
<code>eye()</code> Member functions of <code>Mat</code> and <code>SpMat</code>
</li>
<li>
<code>eye(n_rows, n_cols)</code> Set the elements along the main diagonal to one and off-diagonal elements to zero, optionally first changing the size to specified dimensions</li>
<li>
<code>eye(size(X))</code> An identity matrix is generated when <code>n_rows = n_cols</code>
</li>
</ul>
<div class="section level4">
<h4 id="examples-9">Examples<a class="anchor" aria-label="anchor" href="#examples-9"></a>
</h4>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">eye_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  A.eye();            <span class="co">// create an identity matrix</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  B.eye(size(A)); <span class="co">// another identity matrix</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>  uword N = A.n_rows;</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>  uword M = A.n_cols;</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>  mat C(N, M, fill::randu);</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>  C.eye(N, M); <span class="co">// yet another identity matrix</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="random-uniform">Random uniform<a class="anchor" aria-label="anchor" href="#random-uniform"></a>
</h3>
<p>Set all the elements to random values from a uniform distribution in the [0,1] interval, optionally first changing the size to specified dimensions.</p>
<p>For complex elements, the real and imaginary parts are treated separately.</p>
<ul>
<li>
<code>randu()</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>)</li>
<li>
<code>randu(n_elem)</code> (member function of <code>Col</code> and <code>Row</code>)</li>
<li>
<code>randu(n_rows, n_cols)</code> (member function of <code>Mat</code>)</li>
<li>
<code>randu(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>)</li>
<li>
<code>randu(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>)</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randu_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>  mat B;</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>  B.randu(size(A)); <span class="co">// random uniform matrix with the same size as A</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::randu);</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a>}</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randu_fun2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a>  GetRNGstate();  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true"></a>  mat y(n, n);</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true"></a>  ::arma_rng::randu&lt;<span class="dt">double</span>&gt;::fill(y.memptr(), y.n_elem);</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true"></a>  PutRNGstate();</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(y);</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="normal-distribution">Normal distribution<a class="anchor" aria-label="anchor" href="#normal-distribution"></a>
</h3>
<p>Set all the elements to random values from a normal distribution with zero mean and unit variance, optionally first changing the size to specified dimensions.</p>
<p>For complex elements, the real and imaginary parts are treated separately.</p>
<ul>
<li>
<code>randn()</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>)</li>
<li>
<code>randn(n_elem)</code> (member function of <code>Col</code> and <code>Row</code>)</li>
<li>
<code>randn(n_rows, n_cols)</code> (member function of <code>Mat</code>)</li>
<li>
<code>randn(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>)</li>
<li>
<code>randn(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>)</li>
</ul>
<div class="section level4">
<h4 id="examples-10">Examples<a class="anchor" aria-label="anchor" href="#examples-10"></a>
</h4>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randn_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>  mat B;</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>  B.randn(size(A)); <span class="co">// random normal matrix with the same size as A</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::randn);</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>}</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randn_fun2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true"></a>  GetRNGstate();  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true"></a>  mat y(n, n);</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true"></a>  ::arma_rng::randn&lt;<span class="dt">double</span>&gt;::fill(y.memptr(), y.n_elem);</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true"></a>  PutRNGstate();</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true"></a>  </span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(y);</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="fill">Fill<a class="anchor" aria-label="anchor" href="#fill"></a>
</h3>
<p>Sets the elements to a specified value</p>
<p><code>fill( value )</code> Member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code></p>
<p>The type of value must match the type of elements used by the container object (e.g., for <code>Mat</code> the type is <code>double</code>)</p>
<div class="section level4">
<h4 id="examples-11">Examples<a class="anchor" aria-label="anchor" href="#examples-11"></a>
</h4>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">fill_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>  uword N = A.n_rows;</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>  uword M = A.n_cols;</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  mat B(size(A), fill::value(<span class="fl">200.0</span>));  <span class="co">// create a matrix filled with 200.0</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>  mat C(N, M, fill::value(<span class="fl">100.0</span>));     <span class="co">// matrix filled with 100.0</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>  mat D(N, M, fill::zeros);            <span class="co">// matrix filled with zeros</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>  mat E(N, M, fill::ones);             <span class="co">// matrix filled with ones</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a>  mat F = A + B + C + D + E;</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(F);  <span class="co">// convert from C++ to R</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="imbue">Imbue<a class="anchor" aria-label="anchor" href="#imbue"></a>
</h3>
<p>Imbue (fill) with values provided by a functor or lambda function</p>
<ul>
<li>
<code>imbue(functor)</code> Member functions of <code>Mat</code>, <code>Col</code>, <code>Row</code> and <code>Cube</code>
</li>
<li>
<code>imbue(lambda_function)</code> Imbue (fill) with values provided by a functor or lambda function</li>
</ul>
<p>For matrices, filling is done column-by-column (e.g., column 0 is filled, then column 1, etc.)</p>
<p>For cubes, filling is done slice-by-slice, with each slice treated as a matrix</p>
<div class="section level4">
<h4 id="examples-12">Examples<a class="anchor" aria-label="anchor" href="#examples-12"></a>
</h4>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">imbue_fun1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  <span class="bu">std::</span>mt19937 engine;  <span class="co">// Mersenne twister random number engine</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">double</span>&gt; distr(<span class="fl">0.0</span>, <span class="fl">1.0</span>);</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>  mat B(size(A), fill::none);                <span class="co">// create an empty matrix</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>  B.imbue([&amp;]() { <span class="cf">return</span> distr(engine); });  <span class="co">// fill with random values</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a>  mat C = A + B;</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(C);  <span class="co">// convert from C++ to R</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a>}</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">imbue_fun2_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true"></a>  GetRNGstate();  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// Convert from R to C++</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true"></a>  mat B(size(A), fill::none);  <span class="co">// Create an empty matrix</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true"></a>  B.imbue([]() { <span class="cf">return</span> unif_rand(); });  <span class="co">// Fill with random values</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true"></a></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true"></a>  mat C = A + B;</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true"></a></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true"></a>  PutRNGstate();</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true"></a></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(C);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="clean">Clean<a class="anchor" aria-label="anchor" href="#clean"></a>
</h3>
<p><code>clean(threshold)</code> Member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code> and <code>SpMat</code></p>
<p>For objects with non-complex elements: each element with an absolute value less or equal to the threshold is replaced by zero.</p>
<p>For objects with complex elements: for each element, each component (real and imaginary) with an absolute value less or equal to the threshold is replaced by zero.</p>
<p>Can be used to sparsify a matrix, in the sense of zeroing values with small magnitudes.</p>
<div class="section level4">
<h4 id="caveat">Caveat<a class="anchor" aria-label="anchor" href="#caveat"></a>
</h4>
<p>To explicitly convert from dense storage to sparse storage, use the <code>SpMat</code>.</p>
</div>
<div class="section level4">
<h4 id="examples-13">Examples<a class="anchor" aria-label="anchor" href="#examples-13"></a>
</h4>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">clean_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>  mat A(n, n, fill::randu); <span class="co">// create a random matrix</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>  A(<span class="dv">0</span>, <span class="dv">0</span>) = datum::eps; <span class="co">// set the diagonal with small values (+/- epsilon)</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>  A(<span class="dv">1</span>, <span class="dv">1</span>) = -datum::eps;</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>  A.clean(datum::eps); <span class="co">// set elements with small values to zero</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="fill-1">Fill<a class="anchor" aria-label="anchor" href="#fill-1"></a>
</h3>
<p><code>replace( old_value, new_value )</code> Member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code> and <code>SpMat</code></p>
<p>For all elements equal to <code>old_value</code>, set them to <code>new_value</code>.</p>
<p>The type of <code>old_value</code> and <code>new_value</code> must match the type of elements used by the container object (e.g., for <code>Mat</code> the type is <code>double</code>).</p>
<div class="section level4">
<h4 id="caveats-1">Caveats<a class="anchor" aria-label="anchor" href="#caveats-1"></a>
</h4>
<ul>
<li>Floating point numbers (<code>float</code> and <code>double</code>) are approximations due to their <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" class="external-link">limited precision</a>.</li>
<li>For sparse matrices (<code>SpMat</code>), replacement is not done when <code>old_value = 0</code>.</li>
</ul>
</div>
<div class="section level4">
<h4 id="examples-14">Examples<a class="anchor" aria-label="anchor" href="#examples-14"></a>
</h4>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">replace_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>  mat A(n, n, fill::randu); <span class="co">// create a random matrix</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>  A.diag().fill(datum::nan); <span class="co">// set the diagonal with NaN values</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>  A.replace(datum::nan, <span class="dv">0</span>);  <span class="co">// replace each NaN with 0</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="clamp">Clamp<a class="anchor" aria-label="anchor" href="#clamp"></a>
</h3>
<p>Clamp each element to the <code>[min_val, max_val]</code> interval; any value lower than <code>min_val</code> will be set to <code>min_val</code>, and any value higher than <code>max_val</code> will be set to <code>max_val</code>.</p>
<p><code>clamp(min_value, max_value)</code> Member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code> and <code>SpMat</code>.</p>
<p>For complex elements, the real and imaginary components are clamped separately.</p>
<p>For sparse matrices, clamping is applied only to the non-zero elements.</p>
<div class="section level4">
<h4 id="examples-15">Examples<a class="anchor" aria-label="anchor" href="#examples-15"></a>
</h4>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">clamp_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>  mat A(n, n, fill::randu); <span class="co">// create a random matrix</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>  A.diag().fill(<span class="fl">0.1</span>);       <span class="co">// set the diagonal with 0.1 values</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>  A.clamp(<span class="fl">0.2</span>, <span class="fl">0.8</span>); <span class="co">// clamp values to the [0.2, 0.8] interval</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="transform">Transform<a class="anchor" aria-label="anchor" href="#transform"></a>
</h3>
<ul>
<li>
<code>transform(functor)</code> Member functions of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code> and <code>SpMat</code>.</li>
<li>
<code>transform(lambda_function)</code> Transform each element using a functor or lambda function.</li>
</ul>
<p>For dense matrices, transformation is done column-by-column for all elements.</p>
<p>For sparse matrices, transformation is done column-by-column for non-zero elements.</p>
<p>For cubes, transformation is done slice-by-slice, with each slice treated as a matrix.</p>
<div class="section level4">
<h4 id="examples-16">Examples<a class="anchor" aria-label="anchor" href="#examples-16"></a>
</h4>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">transform_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  mat A(n, n, fill::ones);  <span class="co">// create a matrix filled with ones</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>  A.transform([](<span class="dt">double</span> val) { <span class="cf">return</span> (val + <span class="fl">122.0</span>); });</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="for-each">For each<a class="anchor" aria-label="anchor" href="#for-each"></a>
</h3>
<p>For dense matrices and fields, the processing is done column-by-column for all elements.</p>
<p>For sparse matrices, the processing is done column-by-column for non-zero elements.</p>
<p>For cubes, processing is done slice-by-slice, with each slice treated as a matrix.</p>
<p><code>for_each(functor)</code> Member functions of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code> and <code>field</code> <code>for_each(lambda_function)</code> For each element, pass its reference to a functor or lambda function</p>
<div class="section level4">
<h4 id="examples-17">Examples<a class="anchor" aria-label="anchor" href="#examples-17"></a>
</h4>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">for_each_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  <span class="co">// add 122 to each element in a dense matrix, the '&amp;' is important</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>  mat D(n, n, fill::ones);</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>  D.for_each([](mat::<span class="dt">elem_type</span>&amp; val) { val += <span class="fl">122.0</span>; });</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>  <span class="co">// add 122 to each non-zero element in a sparse matrix</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>  sp_mat S;</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a>  S.sprandu(n, n, <span class="fl">1.0</span>);</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a>  S.for_each([](sp_mat::<span class="dt">elem_type</span>&amp; val) { val += <span class="fl">123.0</span>; });</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true"></a>  <span class="co">// set the size of all matrices in a field</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true"></a>  field&lt;mat&gt; F(<span class="dv">2</span>, <span class="dv">2</span>);</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true"></a>  F.for_each([n](mat&amp; X) { X.zeros(n, n); });  <span class="co">// capture n for the lambda</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true"></a></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true"></a>  mat res = D + S + F(<span class="dv">0</span>) + F(<span class="dv">1</span>);</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="set-size">Set size<a class="anchor" aria-label="anchor" href="#set-size"></a>
</h3>
<p>Change the size of an object, without explicitly preserving data and without initialising the elements (e.g., elements may contain garbage values, including <code>NaN</code>)</p>
<ul>
<li>
<code>set_size(n_elem)</code> (member function of <code>Col</code>, <code>Row</code>, <code>field</code>)</li>
<li>
<code>set_size(n_rows, n_cols)</code> (member function of <code>Mat</code>, <code>SpMat</code>, <code>field</code>)</li>
<li>
<code>set_size(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code> and <code>field</code>)</li>
<li>
<code>set_size(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>, <code>field</code>)</li>
</ul>
<p>To initialise the elements to zero while changing the size, use <code>.zeros()</code> instead.</p>
<p>To explicitly preserve data while changing the size, use <code>.reshape()</code> or <code>.resize()</code> instead.</p>
<div class="section level4">
<h4 id="examples-18">Examples<a class="anchor" aria-label="anchor" href="#examples-18"></a>
</h4>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">set_size_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>  mat A;</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>  A.set_size(n, n);  <span class="co">// or:  mat A(n, n, fill::none);</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>  B.set_size(size(A));  <span class="co">// or:  mat B(size(A), fill::none);</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a>  vec C;</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a>  C.set_size(n);  <span class="co">// or:  vec v(n, fill::none);</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true"></a>  A.fill(<span class="fl">1.0</span>);  <span class="co">// set all elements to 1.0</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true"></a>  B.fill(<span class="fl">2.0</span>);  <span class="co">// set all elements to 2.0</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true"></a>  C.fill(<span class="fl">3.0</span>);  <span class="co">// set all elements to 3.0</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true"></a>  vec res = A.col(<span class="dv">0</span>) + B.col(<span class="dv">1</span>) + C;</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="reshape">Reshape<a class="anchor" aria-label="anchor" href="#reshape"></a>
</h3>
<p>Recreate an object according to given size specifications, with the elements taken from the previous version of the object in a column-wise manner; the elements in the generated object are placed column-wise (e.g., the first column is filled up before filling the second column)</p>
<ul>
<li>
<code>reshape(n_rows, n_cols)</code> (member function of <code>Mat</code> and <code>SpMat</code>)</li>
<li>
<code>reshape(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>)</li>
<li>
<code>reshape(size(X))</code> (member function of <code>Mat</code>, <code>Cube</code>, <code>SpMat</code>)</li>
</ul>
<p>The layout of the elements in the recreated object will be different to the layout in the previous version of the object</p>
<p>If the total number of elements in the previous version of the object is less than the specified size, the extra elements in the recreated object are set to zero</p>
<p>If the total number of elements in the previous version of the object is greater than the specified size, only a subset of the elements is taken</p>
<div class="section level4">
<h4 id="caveats-2">Caveats<a class="anchor" aria-label="anchor" href="#caveats-2"></a>
</h4>
<ul>
<li>
<code>.reshape()</code> is considerably slower than <code>.set_size()</code>.</li>
<li>to change the size without preserving data, use <code>.set_size()</code>.</li>
<li>to grow/shrink the object while preserving the elements and the layout of the elements, use <code>.resize()</code>
</li>
<li>to flatten a matrix into a vector, use <code>vectorise()</code> or <code>.as_col()</code>/<code>.as_row()</code>.</li>
</ul>
</div>
<div class="section level4">
<h4 id="examples-19">Examples<a class="anchor" aria-label="anchor" href="#examples-19"></a>
</h4>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">reshape_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>  mat A(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::randu);</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>  A.reshape(n - <span class="dv">1</span>, n + <span class="dv">1</span>);</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="resize">Resize<a class="anchor" aria-label="anchor" href="#resize"></a>
</h3>
<p>Recreate the object according to given size specifications, while preserving the elements as well as the layout of the elements</p>
<ul>
<li>
<code>resize(n_elem)</code> (member function of <code>Col</code>, <code>Row</code>)</li>
<li>
<code>resize(n_rows, n_cols)</code> (member function of <code>Mat</code> and <code>SpMat</code>)</li>
<li>
<code>resize(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>)</li>
<li>
<code>resize(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>)</li>
</ul>
<p>Can be used for growing or shrinking an object (e.g., adding/removing rows, and/or columns, and/or slices)</p>
<div class="section level4">
<h4 id="caveats-3">Caveats<a class="anchor" aria-label="anchor" href="#caveats-3"></a>
</h4>
<ul>
<li>
<code>.resize()</code> is considerably slower than <code>.set_size()</code>.</li>
<li>to change the size without preserving data, <code>.set_size()</code> instead</li>
</ul>
</div>
<div class="section level4">
<h4 id="examples-20">Examples<a class="anchor" aria-label="anchor" href="#examples-20"></a>
</h4>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">resize_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>  mat A(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::randu);</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>  A.resize(n - <span class="dv">1</span>, n + <span class="dv">1</span>);</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="copy-size">Copy size<a class="anchor" aria-label="anchor" href="#copy-size"></a>
</h3>
<p><code>copy_size(A)</code> Set the size to be the same as object <code>A</code></p>
<p>Object <code>A</code> must be of the same root type as the object being modified (e.g., the size of a matrix can’t be set by providing a cube)</p>
<div class="section level4">
<h4 id="examples-21">Examples<a class="anchor" aria-label="anchor" href="#examples-21"></a>
</h4>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">copy_size_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>  mat B;</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>  B.copy_size(A);</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>  <span class="dt">int</span> N = B.n_rows;</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>  <span class="dt">int</span> M = B.n_cols;</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true"></a>  </span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true"></a>  writable::integers res({N, M});</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"n_rows"</span>, <span class="st">"n_cols"</span>});</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="reset">Reset<a class="anchor" aria-label="anchor" href="#reset"></a>
</h3>
<p><code>reset()</code> Reset the size to zero (the object will have no elements)</p>
<div class="section level4">
<h4 id="examples-22">Examples<a class="anchor" aria-label="anchor" href="#examples-22"></a>
</h4>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">reset_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>  A.reset();</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>  <span class="dt">int</span> N = A.n_rows;</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>  <span class="dt">int</span> M = A.n_cols;</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>  </span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a>  writable::integers res({N, M});</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"n_rows"</span>, <span class="st">"n_cols"</span>});</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="submatrix-views">Submatrix views<a class="anchor" aria-label="anchor" href="#submatrix-views"></a>
</h3>
<p>A collection of member functions of <code>Mat</code>, <code>Col</code> and <code>Row</code> classes that provide read/write access to submatrix views.</p>
<div class="section level4">
<h4 id="contiguous-views-for-matrix">Contiguous views for matrix<a class="anchor" aria-label="anchor" href="#contiguous-views-for-matrix"></a>
</h4>
<ul>
<li><code>X.col(col_number)</code></li>
<li><code>X.row(row_number)</code></li>
<li>
<code>X.cols(first_col, last_col)</code><br>
</li>
<li><code>X.rows(first_row, last_row)</code></li>
<li><code>X.submat(first_row, first_col, last_row, last_col)</code></li>
<li><code>X(span(first_row, last_row), span(first_col, last_col))</code></li>
<li><code>X(first_row, first_col, size(n_rows, n_cols))</code></li>
<li>
<code>X(first_row, first_col, size(Y))</code> (<code>Y</code> is a matrix)</li>
<li><code>X(span(first_row, last_row), col_number)</code></li>
<li><code>X(row_number, span(first_col, last_col))</code></li>
<li><code>X.head_cols(number_of_cols)</code></li>
<li><code>X.head_rows(number_of_rows)</code></li>
<li><code>X.tail_cols(number_of_cols)</code></li>
<li><code>X.tail_rows(number_of_rows)</code></li>
<li>
<code>X.unsafe_col(col_number)</code> (use with caution)</li>
</ul>
</div>
<div class="section level4">
<h4 id="contiguous-views-for-vector">Contiguous views for vector<a class="anchor" aria-label="anchor" href="#contiguous-views-for-vector"></a>
</h4>
<ul>
<li><code>Y(span(first_index, last_index))</code></li>
<li><code>Y.subvec(first_index, last_index)</code></li>
<li>
<code>Y.subvec(first_index, size(X))</code> (<code>X</code> is a vector)<br>
</li>
<li><code>Y.head(number_of_elements)</code></li>
<li><code>Y.tail(number_of_elements)</code></li>
</ul>
</div>
<div class="section level4">
<h4 id="non-contiguous-views-for-matrix-or-vector">Non-contiguous views for matrix or vector:<a class="anchor" aria-label="anchor" href="#non-contiguous-views-for-matrix-or-vector"></a>
</h4>
<ul>
<li><code>X.elem(vector_of_indices)</code></li>
<li><code>X(vector_of_indices)</code></li>
<li><code>X.cols(vector_of_column_indices)</code></li>
<li><code>X.rows(vector_of_row_indices)</code></li>
<li><code>X.submat(vector_of_row_indices, vector_of_column_indices)</code></li>
<li><code>X(vector_of_row_indices, vector_of_column_indices)</code></li>
</ul>
<p>Instances of <code>span(start, end)</code> can be replaced by <code>span::all_</code> to indicate the entire range.</p>
<p>For functions requiring one or more vector of indices, for example <code>X.submat(vector_of_row_indices, vector_of_column_indices)</code>, each vector of indices must be of type <code>uvec</code>.</p>
<p>In the function <code>X.elem(vector_of_indices)</code>, elements specified in <code>vector_of_indices</code> are accessed. <code>X</code> is interpreted as one long vector, with column-by-column ordering of the elements of <code>X</code>. The <code>vector_of_indices</code> must evaluate to a vector of type <code>uvec</code> (e.g., generated by the <code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function). The aggregate set of the specified elements is treated as a column vector (e.g., the output of <code>X.elem()</code> is always a column vector).</p>
<p>The function <code>.unsafe_col()</code> is provided for speed reasons and should be used only if you know what you are doing. It creates a seemingly independent <code>Col</code> vector object (e.g., <code>vec</code>), but uses memory from the existing matrix object. As such, the created vector is not alias safe, and does not take into account that the underlying matrix memory could be freed (e.g., due to any operation involving a size change of the matrix).</p>
</div>
<div class="section level4">
<h4 id="examples-23">Examples<a class="anchor" aria-label="anchor" href="#examples-23"></a>
</h4>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">subview_fun1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>  mat A(n, n, fill::zeros);</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a>  A.submat(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) = randu&lt;mat&gt;(<span class="dv">3</span>,<span class="dv">3</span>);</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>  A(span(<span class="dv">0</span>,<span class="dv">2</span>), span(<span class="dv">1</span>,<span class="dv">3</span>)) = randu&lt;mat&gt;(<span class="dv">3</span>,<span class="dv">3</span>);</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a>  A(<span class="dv">0</span>,<span class="dv">1</span>, size(<span class="dv">3</span>,<span class="dv">3</span>)) = randu&lt;mat&gt;(<span class="dv">3</span>,<span class="dv">3</span>);</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>  mat B = A.submat(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a>  mat C = A(span(<span class="dv">0</span>,<span class="dv">2</span>), span(<span class="dv">1</span>,<span class="dv">3</span>) );</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true"></a>  mat D = A(<span class="dv">0</span>, <span class="dv">1</span>, size(<span class="dv">3</span>,<span class="dv">3</span>) );</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true"></a>  A.col(<span class="dv">1</span>) = randu&lt;mat&gt;(<span class="dv">5</span>,<span class="dv">1</span>);</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true"></a>  A(span::all, <span class="dv">1</span>) = randu&lt;mat&gt;(<span class="dv">5</span>,<span class="dv">1</span>);</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true"></a>  mat X(<span class="dv">5</span>, <span class="dv">5</span>, fill::randu);</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true"></a>    </span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true"></a>  <span class="co">// get all elements of X that are greater than 0.5</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true"></a>  vec q = X.elem( find(X &gt; <span class="fl">0.5</span>) );</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true"></a>    </span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true"></a>  <span class="co">// add 123 to all elements of X greater than 0.5</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true"></a>  X.elem( find(X &gt; <span class="fl">0.5</span>) ) += <span class="fl">123.0</span>;</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true"></a>    </span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true"></a>  <span class="co">// set four specific elements of X to 1</span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true"></a>  uvec indices = { <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">8</span> };</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true"></a>    </span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true"></a>  X.elem(indices) = ones&lt;vec&gt;(<span class="dv">4</span>);</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true"></a>    </span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true"></a>  <span class="co">// add 123 to the last 5 elements of vector a</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true"></a>  vec a(<span class="dv">10</span>, fill::randu);</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true"></a>  a.tail(<span class="dv">5</span>) += <span class="fl">123.0</span>;</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true"></a>    </span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true"></a>  <span class="co">// add 123 to the first 3 elements of column 2 of X</span></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true"></a>  X.col(<span class="dv">2</span>).head(<span class="dv">3</span>) += <span class="dv">123</span>;</span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true"></a></span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="subcube-views-and-slices">Subcube views and slices<a class="anchor" aria-label="anchor" href="#subcube-views-and-slices"></a>
</h3>
<p>A collection of member functions of the <code>Cube</code> class that provide subcube views.</p>
<div class="section level4">
<h4 id="contiguous-views-for-cube">Contiguous views for cube<a class="anchor" aria-label="anchor" href="#contiguous-views-for-cube"></a>
</h4>
<ul>
<li><code>Q.slice(slice_number)</code></li>
<li><code>Q.slices(first_slice, last_slice)</code></li>
<li><code>Q.row(row_number)</code></li>
<li><code>Q.rows(first_row, last_row)</code></li>
<li><code>Q.col(col_number)</code></li>
<li><code>Q.cols(first_col, last_col)</code></li>
<li><code>Q.subcube( first_row, first_col, first_slice, last_row, last_col, last_slice)</code></li>
<li><code>Q(span(first_row, last_row), span(first_col, last_col), span(first_slice, last_slice))</code></li>
<li><code>Q(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></li>
<li>
<code>Q(first_row, first_col, first_slice, size(R))</code> (<code>R</code> is a cube)<br>
</li>
<li><code>Q.head_slices(number_of_slices)</code></li>
<li><code>Q.tail_slices(number_of_slices)</code></li>
<li><code>Q.tube(row, col)</code></li>
<li><code>Q.tube(first_row, first_col, last_row, last_col)</code></li>
<li><code>Q.tube(span(first_row, last_row), span(first_col, last_col))</code></li>
<li><code>Q.tube(first_row, first_col, size(n_rows, n_cols))</code></li>
</ul>
</div>
<div class="section level4">
<h4 id="non-contiguous-views-for-cube">Non-contiguous views for cube<a class="anchor" aria-label="anchor" href="#non-contiguous-views-for-cube"></a>
</h4>
<ul>
<li><code>Q.elem(vector_of_indices)</code></li>
<li><code>Q(vector_of_indices)</code></li>
<li><code>Q.slices( vector_of_slice_indices)</code></li>
</ul>
<p>Instances of <code>span(a,b)</code> can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code>, to indicate the entire range</li>
<li>
<code>span(a)</code>, to indicate a particular row, column or slice</li>
</ul>
<p>An individual slice, accessed via <code>.slice()</code>, is an instance of the <code>Mat</code> class (a reference to a matrix is provided)</p>
<p>All <code>.tube()</code> forms are variants of <code>.subcube()</code>, using <code>first_slice = 0</code> and <code>last_slice = Q.n_slices-1</code></p>
<p>The <code>.tube(row,col)</code> form uses <code>row = first_row = last_row</code>, and <code>col = first_col = last_col</code></p>
<p>In the function <code>Q.elem(vector_of_indices)</code>, elements specified in <code>vector_of_indices</code> are accessed. <code>Q</code> is interpreted as one long vector, with slice-by-slice and column-by-column ordering of the elements of <code>Q</code>. The <code>vector_of_indices</code> must evaluate to a vector of type <code>uvec</code> (e.g., generated by the <code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function). The aggregate set of the specified elements is treated as a column vector (e.g., the output of <code>Q.elem()</code> is always a column vector).</p>
<p>In the function <code>Q.slices(vector_of_slice_indices)</code>, slices specified in <code>vector_of_slice_indices</code> are accessed. The <code>vector_of_slice_indices</code> must evaluate to a vector of type <code>uvec</code>.</p>
</div>
<div class="section level4">
<h4 id="examples-24">Examples<a class="anchor" aria-label="anchor" href="#examples-24"></a>
</h4>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">subview_fun2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>  cube A(n, <span class="dv">3</span>, <span class="dv">4</span>, fill::randu);</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>    </span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>  mat B = A.slice(<span class="dv">1</span>); <span class="co">// each slice is a matrix</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>    </span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a>  A.slice(<span class="dv">0</span>) = randu&lt;mat&gt;(<span class="dv">2</span>,<span class="dv">3</span>);</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a>  A.slice(<span class="dv">0</span>)(<span class="dv">1</span>,<span class="dv">2</span>) = <span class="fl">99.0</span>;</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true"></a>    </span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true"></a>  A.subcube(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,  <span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>)           = randu&lt;cube&gt;(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>);</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true"></a>  A(span(<span class="dv">0</span>,<span class="dv">1</span>), span(<span class="dv">0</span>,<span class="dv">1</span>), span(<span class="dv">1</span>,<span class="dv">2</span>)) = randu&lt;cube&gt;(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>);</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true"></a>  A(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>, size(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))              = randu&lt;cube&gt;(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>);</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true"></a>    </span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true"></a>  <span class="co">// add 123 to all elements of A greater than 0.5</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true"></a>  A.elem( find(A &gt; <span class="fl">0.5</span>) ) += <span class="fl">123.0</span>;</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true"></a>    </span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true"></a>  cube C = A.head_slices(<span class="dv">2</span>);  <span class="co">// get first two slices</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true"></a>    </span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true"></a>  A.head_slices(<span class="dv">2</span>) += <span class="fl">123.0</span>;</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true"></a></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true"></a>  mat res = A.slice(<span class="dv">0</span>) + B + C.slice(<span class="dv">1</span>);</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true"></a></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="subfield-views">Subfield views<a class="anchor" aria-label="anchor" href="#subfield-views"></a>
</h3>
<p>A collection of member functions of the <code>field</code> class that provide subfield views.</p>
<p>For a 2D field <code>F</code>, the subfields are accessed as:</p>
<ul>
<li><code>F.row(row_number)</code></li>
<li><code>F.col(col_number)</code></li>
<li><code>F.rows(first_row, last_row)</code></li>
<li><code>F.cols(first_col, last_col)</code></li>
<li><code>F.subfield(first_row, first_col, last_row, last_col)</code></li>
<li><code>F(span(first_row, last_row), span(first_col, last_col))</code></li>
<li>
<code>F(first_row, first_col, size(G))</code> (<code>G</code> is a 2D field)</li>
<li><code>F(first_row, first_col, size(n_rows, n_cols))</code></li>
</ul>
<p>For a 3D field <em>F</em>, the subfields are accessed as:</p>
<ul>
<li><code>F.slice(slice_number)</code></li>
<li><code>F.slices(first_slice, last_slice)</code></li>
<li><code>F.subfield(first_row, first_col, first_slice, last_row, last_col, last_slice)</code></li>
<li><code>F(span(first_row, last_row), span(first_col, last_col), span(first_slice, last_slice))</code></li>
<li>
<code>F(first_row, first_col, first_slice, size(G))</code> (<code>G</code> is a 3D field)</li>
<li><code>F(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></li>
</ul>
<p>Instances of <code>span(a,b)</code> can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code>, to indicate the entire range</li>
<li>
<code>span(a)</code>, to indicate a particular row or column</li>
</ul>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Mauricio Vargas Sepulveda, Conrad Sanderson.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.9000.</p>
</div>

    </footer>
</div>





  </body>
</html>
