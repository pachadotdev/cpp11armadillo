<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="cpp11armadillo">
<title>Matrix, vector, cube and field classes • cpp11armadillo</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.1/jquery-3.6.1.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Matrix, vector, cube and field classes">
<meta property="og:description" content="cpp11armadillo">
<meta property="og:image" content="../cpp11armadillo/logo.svg">
<!-- mathjax --><script src="file:///usr/share/javascript/mathjax/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">cpp11armadillo</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5.3</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/basic-usage.html">Basic 'cpp11armadillo' usage</a>
    <a class="dropdown-item" href="../articles/configuration.html">Armadillo configuration</a>
    <a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-dense.html">Decompositions, factorisations, inverses and equation solvers (dense matrices)</a>
    <a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-sparse.html">Decompositions, factorisations, inverses and equation solvers (sparse matrices)</a>
    <a class="dropdown-item" href="../articles/functions-of-vector-matrices-cubes.html">Functions of vectors, matrices, and cubes</a>
    <a class="dropdown-item" href="../articles/generated-vectors-matrices-cubes.html">Generated vectors, matrices, and cubes</a>
    <a class="dropdown-item" href="../articles/linear-model.html">Fitting regressions with Armadillo</a>
    <a class="dropdown-item" href="../articles/matrix-vector-cube-and-field-classes.html">Matrix, vector, cube and field classes</a>
    <a class="dropdown-item" href="../articles/member-functions-and-variables.html">Member functions and variables</a>
    <a class="dropdown-item" href="../articles/miscellaneous.html">Miscellaneous</a>
    <a class="dropdown-item" href="../articles/save-load.html">Saving and loading Armadillo objects on C++ side</a>
    <a class="dropdown-item" href="../articles/signal-and-image-processing.html">Signal and image processing</a>
    <a class="dropdown-item" href="../articles/sparse-matrices.html">Sparse matrices</a>
    <a class="dropdown-item" href="../articles/statistics-and-clustering.html">Statistics and clustering</a>
    <a class="dropdown-item" href="../articles/syntax-comparison-for-matlab-users.html">Syntax comparison for MATLAB/Octave users</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="nav-link" href="https://github.com/pachadotdev/cpp11armadillo/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Matrix, vector, cube and field classes</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/pachadotdev/cpp11armadillo/blob/HEAD/vignettes/matrix-vector-cube-and-field-classes.Rmd"><code>vignettes/matrix-vector-cube-and-field-classes.Rmd</code></a></small>
      <div class="d-none name"><code>matrix-vector-cube-and-field-classes.Rmd</code></div>
    </div>

    
    
<p>This vignette is adapted from the official Armadillo <a href="https://arma.sourceforge.net/docs.html" class="external-link">documentation</a>.</p>
<div class="section level2">
<h2 id="dense-matrix-class">Dense matrix class<a class="anchor" aria-label="anchor" href="#dense-matrix-class"></a>
</h2>
<p><code>Mat&lt;type&gt;</code>, <code>mat</code> and
<code>cx_mat</code> are classes for dense matrices, with elements stored
in <a href="https://en.wikipedia.org/wiki/Column_major" class="external-link">column-major
ordering</a> (e.g., column by column).</p>
<p>The root matrix class is <code>Mat&lt;type&gt;</code>, where
<code>type</code> is one of:</p>
<ul>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>std::complex&lt;float&gt;</code></li>
<li><code>std::complex&lt;double&gt;</code></li>
<li><code>short</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>unsigned short</code></li>
<li><code>unsigned int</code></li>
<li><code>unsigned long</code></li>
</ul>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>mat = Mat&lt;double&gt;</code></li>
<li><code>dmat = Mat&lt;double&gt;</code></li>
<li><code>fmat = Mat&lt;float&gt;</code></li>
<li>
<code>cx_mat = Mat&lt;cx_double&gt;</code> (<code>cx_double</code>
is a shortcut for <code>std::complex&lt;double&gt;</code>)</li>
<li><code>cx_dmat = Mat&lt;cx_double&gt;</code></li>
<li>
<code>cx_fmat = Mat&lt;cx_float&gt;</code> (<code>cx_float</code> is
a shortcut for <code>std::complex&lt;float&gt;</code>)</li>
<li>
<code>umat = Mat&lt;uword&gt;</code> (<code>uword</code> is a
shortcut for <code>unsigned int</code>)</li>
<li>
<code>imat = Mat&lt;sword&gt;</code> (<code>sword</code> is a
shortcut for <code>signed int</code>)</li>
</ul>
<p>The <code>mat</code> type is used for convenience, and it is possible
to use other matrix types (e.g, <code>fmat</code>, <code>cx_mat</code>)
instead.</p>
<p>Matrix types with integer elements (such as <code>umat</code> and
<code>imat</code>) cannot hold special values such as NaN and Inf.</p>
<p>Functions which use LAPACK (generally matrix decompositions) are only
valid for the following matrix types: <code>mat</code>,
<code>dmat</code>, <code>fmat</code>, <code>cx_mat</code>,
<code>cx_dmat</code>, <code>cx_fmat</code>.</p>
<div class="section level3">
<h3 id="constructors">Constructors<a class="anchor" aria-label="anchor" href="#constructors"></a>
</h3>
<ul>
<li><code>mat()</code></li>
<li><code>mat(n_rows, n_cols)</code></li>
<li>
<code>mat(n_rows, n_cols, fill_form)</code> (elements are
initialised according to <code>fill_form</code>)</li>
<li><code>mat(size(X))</code></li>
<li>
<code>mat(size(X), fill_form)</code> (elements are initialised
according to <code>fill_form</code>)</li>
<li><code>mat(mat)</code></li>
<li><code>mat(vec)</code></li>
<li><code>mat(rowvec)</code></li>
<li><code>mat(initializer_list)</code></li>
<li><code>mat(string)</code></li>
<li>
<code>mat(std::vector)</code> (treated as a column vector)</li>
<li>
<code>mat(sp_mat)</code> (for converting a sparse matrix to a dense
matrix)</li>
<li>
<code>cx_mat(mat,mat)</code> (for constructing a complex matrix out
of two real matrices)</li>
</ul>
<p>The elements can be explicitly initialised during construction by
specifying <code>fill_form</code>, which is one of:</p>
<ul>
<li>
<code>fill::zeros</code> set all elements to 0 (default in
cpp11armadillo)</li>
<li>
<code>fill::ones</code> set all elements to 1</li>
<li>
<code>fill::eye</code> set the elements on the main diagonal to 1
and off-diagonal elements to 0</li>
<li>
<code>fill::randu</code> set all elements to random values from a
uniform distribution in the [0,1] interval</li>
<li>
<code>fill::randn</code> set all elements to random values from a
normal distribution with zero mean and unit variance</li>
<li>
<code>fill::value(scalar)</code> set all elements to specified
scalar</li>
<li>
<code>fill::none</code> do not initialise the elements (matrix may
have garbage values)</li>
</ul>
<p>For the <code>mat(string)</code> constructor, the format is elements
separated by spaces, and rows denoted by semicolons. For example, the
2x2 identity matrix can be created using <code>"1 0; 0 1"</code>. Note
that string based initialisation is slower than directly setting the
elements or using element initialisation.</p>
<p>Each instance of <code>mat</code> automatically allocates and
releases internal memory. All internally allocated memory used by an
instance of mat is automatically released as soon as the instance goes
out of scope. For example, if an instance of mat is declared inside a
function, it will be automatically destroyed at the end of the function.
To forcefully release memory at any point, use <code>.reset()</code>.
Note that in normal use this is not required.</p>
</div>
<div class="section level3">
<h3 id="advanced-constructors">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors"></a>
</h3>
<ul>
<li>
<code>mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)</code>
<ul>
<li>Create a matrix using data from writable auxiliary (external)
memory, where <code>ptr_aux_mem</code> is a pointer to the memory. By
default the matrix allocates its own memory and copies data from the
auxiliary memory (for safety). However, if <code>copy_aux_mem</code> is
set to <code>false</code>, the matrix will instead directly use the
auxiliary memory (e.g., no copying). This is faster, but can be
dangerous unless you know what you are doing.<br>
</li>
<li>The <code>strict</code> parameter comes into effect only when
copy_aux_mem is set to <code>false</code> (e.g., the matrix is directly
using auxiliary memory).
<ul>
<li>When <code>strict</code> is set to <code>false</code>, the matrix
will use the auxiliary memory until a size change or an aliasing
event.</li>
<li>When <code>strict</code> is set to <code>true</code>, the matrix
will be bound to the auxiliary memory for its lifetime. The number of
elements in the matrix cannot be changed.</li>
</ul>
</li>
</ul>
</li>
<li>
<code>mat(const ptr_aux_mem, n_rows, n_cols)</code>
<ul>
<li>Create a matrix by copying data from read-only auxiliary memory,
where <code>ptr_aux_mem</code> is a pointer to the memory</li>
</ul>
</li>
<li>
<code>mat::fixed&lt;n_rows, n_cols&gt;</code>
<ul>
<li>Create a fixed size matrix, with the size specified via template
arguments. Memory for the matrix is reserved at compile time. This is
generally faster than dynamic memory allocation, but the size of the
matrix cannot be changed afterwards (directly or indirectly).<br>
</li>
<li>For convenience, there are several pre-defined typedefs for each
matrix type (where the types are: <code>umat</code>, <code>imat</code>,
<code>fmat</code>, <code>mat</code>, <code>cx_fmat</code>,
<code>cx_mat</code>). The typedefs specify a square matrix size, ranging
from 2x2 to 9x9. The typedefs were defined by appending a two digit form
of the size to the matrix type. Examples: <code>mat33</code> is
equivalent to <code>mat::fixed&lt;3,3&gt;</code>, and
<code>cx_mat44</code> is equivalent to
<code>cx_mat::fixed&lt;4,4&gt;</code>.</li>
</ul>
</li>
<li>
<code>mat::fixed&lt;n_rows, n_cols&gt;(fill_form)</code>
<ul>
<li>Create a fixed size matrix, with the elements explicitly initialised
according to <code>fill_form</code>.</li>
</ul>
</li>
<li>
<code>mat::fixed&lt;n_rows, n_cols&gt;(const ptr_aux_mem)</code>
<ul>
<li>Create a fixed size matrix, with the size specified via template
arguments; data is copied from auxiliary memory, where ptr_aux_mem is a
pointer to the memory.</li>
</ul>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h3>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">25</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">5</span>, ncol <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">matrix1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span> <span class="co">// convert from R to C++</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  <span class="dt">double</span> x <span class="op">=</span> A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// access an element on row 1, column 1</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  A <span class="op">=</span> A <span class="op">+</span> x<span class="op">;</span> <span class="co">// scalar addition</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>      </span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>  mat B <span class="op">=</span> A <span class="op">+</span> A<span class="op">;</span> <span class="co">// matrix addition</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>  mat C <span class="op">=</span> A <span class="op">*</span> B<span class="op">;</span> <span class="co">// matrix multiplication</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>  mat D <span class="op">=</span> A <span class="op">%</span> B<span class="op">;</span> <span class="co">// element-wise matrix multiplication</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>  mat res <span class="op">=</span> B <span class="op">+</span> C <span class="op">+</span> D<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>      </span>
<span id="cb2-16"><a href="#cb2-16" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">matrix2_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb2-18"><a href="#cb2-18" tabindex="-1"></a>  mat B <span class="op">=</span> A <span class="op">+</span> A<span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" tabindex="-1"></a>  cx_mat X<span class="op">(</span>A<span class="op">,</span>B<span class="op">);</span> <span class="co">// construct a complex matrix out of two real matrices</span></span>
<span id="cb2-21"><a href="#cb2-21" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" tabindex="-1"></a>  B<span class="op">.</span>zeros<span class="op">();</span>                       <span class="co">// set all elements to zero</span></span>
<span id="cb2-23"><a href="#cb2-23" tabindex="-1"></a>  B<span class="op">.</span>set_size<span class="op">(</span>A<span class="op">.</span>n_rows<span class="op">,</span> A<span class="op">.</span>n_cols<span class="op">);</span>  <span class="co">// resize the matrix</span></span>
<span id="cb2-24"><a href="#cb2-24" tabindex="-1"></a>  B<span class="op">.</span>ones<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">);</span>                    <span class="co">// same as mat B(5, 6, fill::ones)</span></span>
<span id="cb2-25"><a href="#cb2-25" tabindex="-1"></a>        </span>
<span id="cb2-26"><a href="#cb2-26" tabindex="-1"></a>  mat<span class="op">::</span>fixed<span class="op">&lt;</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">&gt;</span> F<span class="op">;</span> <span class="co">// fixed size matrix</span></span>
<span id="cb2-27"><a href="#cb2-27" tabindex="-1"></a>      </span>
<span id="cb2-28"><a href="#cb2-28" tabindex="-1"></a>  <span class="dt">double</span> aux_mem<span class="op">[</span><span class="dv">24</span><span class="op">];</span> <span class="co">// auxiliary memory</span></span>
<span id="cb2-29"><a href="#cb2-29" tabindex="-1"></a>  mat H<span class="op">(&amp;</span>aux_mem<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="kw">false</span><span class="op">);</span>  <span class="co">// use auxiliary memory</span></span>
<span id="cb2-30"><a href="#cb2-30" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" tabindex="-1"></a>  X <span class="op">=</span> X <span class="op">+</span> F<span class="op">.</span>submat<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span> <span class="op">+</span> H<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb2-32"><a href="#cb2-32" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" tabindex="-1"></a>  Mat<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> res_real <span class="op">=</span> real<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb2-34"><a href="#cb2-34" tabindex="-1"></a>  Mat<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> res_imag <span class="op">=</span> imag<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb2-35"><a href="#cb2-35" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">;</span></span>
<span id="cb2-37"><a href="#cb2-37" tabindex="-1"></a>  res<span class="op">.</span>push_back<span class="op">({</span><span class="st">"real"_nm</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>res_real<span class="op">)});</span></span>
<span id="cb2-38"><a href="#cb2-38" tabindex="-1"></a>  res<span class="op">.</span>push_back<span class="op">({</span><span class="st">"imag"_nm</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>res_imag<span class="op">)});</span></span>
<span id="cb2-39"><a href="#cb2-39" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb2-41"><a href="#cb2-41" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="column-vector-class">Column vector class<a class="anchor" aria-label="anchor" href="#column-vector-class"></a>
</h2>
<p><code>Col&lt;type&gt;</code>, <code>vec</code> and
<code>cx_vec</code> are classes for column vectors (dense matrices with
one column).</p>
<p>The <code>Col&lt;type&gt;</code> class is derived from the
<code>Mat&lt;type&gt;</code> class and inherits most of the member
functions.</p>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>vec = colvec = Col&lt;double&gt;</code></li>
<li><code>dvec = dcolvec = Col&lt;double&gt;</code></li>
<li><code>fvec = fcolvec = Col&lt;float&gt;</code></li>
<li><code>cx_vec = cx_colvec = Col&lt;[cx_double](#cx_double)&gt;</code></li>
<li><code>cx_dvec = cx_dcolvec = Col&lt;[cx_double](#cx_double)&gt;</code></li>
<li><code>cx_fvec = cx_fcolvec = Col&lt;[cx_float](#cx_double)&gt;</code></li>
<li><code>uvec = ucolvec = Col&lt;[uword](#uword)&gt;</code></li>
<li><code>ivec = icolvec = Col&lt;[sword](#uword)&gt;</code></li>
</ul>
<p>The <code>vec</code> and <code>colvec</code> types have the same
meaning and are used interchangeably.</p>
<p>The types <code>vec</code> or <code>colvec</code> are used for
convenience. It is possible to use other column vector types instead
(e.g., <code>fvec</code> or <code>fcolvec</code>).</p>
<p>Functions which take <code>mat</code> as input can generally also
take <code>Col</code> as input. Main exceptions are functions that
require square matrices.</p>
<div class="section level3">
<h3 id="constructors-1">Constructors<a class="anchor" aria-label="anchor" href="#constructors-1"></a>
</h3>
<ul>
<li><code>vec()</code></li>
<li><code>vec(_n_elem_)</code></li>
<li>
<code>vec(_n_elem, fill_form)</code> (elements are initialised
according to <code>fill_form</code>)</li>
<li><code>vec(size(X))</code></li>
<li>
<code>vec(size(X), fill_form)</code> (elements are initialised
according to <code>fill_form</code>)</li>
<li><code>vec(vec)</code></li>
<li>
<code>vec(mat)</code> (<code>std::logic_error</code> exception is
thrown if the given matrix has more than one column)</li>
<li><code>vec(initializer_list)</code></li>
<li>
<code>vec(string)</code> (elements separated by spaces)</li>
<li><code>vec(std::vector)</code></li>
<li>
<code>cx_vec(vec,vec)</code> (for constructing a complex vector out
of two real vectors)</li>
</ul>
</div>
<div class="section level3">
<h3 id="advanced-constructors-1">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors-1"></a>
</h3>
<ul>
<li>
<code>vec(ptr_aux_mem, number_of_elements, copy_aux_mem = true, strict = false)</code>:
<ul>
<li>Create a column vector using data from writable auxiliary (external)
memory, where ptr_aux_mem is a pointer to the memory. By default the
vector allocates its own memory and copies data from the auxiliary
memory (for safety). However, if copy_aux_mem is set to
<code>false</code>, the vector will instead directly use the auxiliary
memory (e.g., no copying). This is faster, but can be dangerous unless
you know what you are doing.</li>
<li>The <code>strict</code> parameter comes into effect only when
<code>copy_aux_mem</code> is set to <code>false</code> (e.g., the vector
is directly using auxiliary memory).</li>
<li>When <code>strict</code> is set to <code>false</code>, the vector
will use the auxiliary memory until a size change or an aliasing
event.</li>
<li>When <code>strict</code> is set to <code>true</code>, the vector
will be bound to the auxiliary memory for its lifetime. The number of
elements in the vector cannot be changed.</li>
</ul>
</li>
<li>
<code>vec(const ptr_aux_mem, number_of_elements)</code>: Create a
column vector by copying data from read-only auxiliary memory, where
ptr_aux_mem is a pointer to the memory.</li>
<li>
<code>vec::fixed&lt;number_of_elements&gt;</code>:
<ul>
<li>Create a fixed size column vector, with the size specified via the
template argument. Memory for the vector is reserved at compile time.
This is generally faster than dynamic memory allocation, but the size of
the vector cannot be changed afterwards (directly or indirectly).<br>
</li>
<li>For convenience, there are several pre-defined typedefs for each
vector type (where the types are: <code>uvec</code>, <code>ivec</code>,
<code>fvec</code>, <code>vec</code>, <code>cx_fvec</code>,
<code>cx_vec</code> as well as the corresponding <code>colvec</code>
versions). The pre-defined typedefs specify vector sizes ranging from 2
to 9. The typedefs were defined by appending a single digit form of the
size to the vector type. Examples: <code>vec3</code> is equivalent to
<code>vec::fixed&lt;3&gt;</code>, and <code>cx_vec4</code> is equivalent
to <code>cx_vec::fixed&lt;4&gt;</code>.</li>
</ul>
</li>
<li>
<code>vec::fixed&lt;number_of_elements&gt;(fill_form)</code>: Create
a fixed size column vector, with the elements explicitly initialised
according to <code>fill_form</code>.</li>
<li>
<code>vec::fixed&lt;number_of_elements&gt;(const ptr_aux_mem)</code>:
Create a fixed size column vector, with the size specified via the
template argument. The data is copied from auxiliary memory, where
<code>ptr_aux_mem</code> is a pointer to the memory.</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-1">Examples<a class="anchor" aria-label="anchor" href="#examples-1"></a>
</h3>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">column1_</span><span class="op">(</span><span class="at">const</span> doubles<span class="op">&amp;</span> x<span class="op">,</span> <span class="at">const</span> doubles<span class="op">&amp;</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  vec X <span class="op">=</span> as_Col<span class="op">(</span>x<span class="op">);</span> <span class="co">// convert from R to C++</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  vec Y <span class="op">=</span> as_Col<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  mat A<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>  vec Z <span class="op">=</span> A<span class="op">.</span>col<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">// extract a column vector</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>  Z <span class="op">=</span> Z <span class="op">+</span> Y <span class="op">+</span> X<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>Z<span class="op">);</span> <span class="co">// convert from C++ to R</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="row-vector-class">Row vector class<a class="anchor" aria-label="anchor" href="#row-vector-class"></a>
</h2>
<p><code>Row&lt;type&gt;</code>, <code>rowvec</code> and
<code>cx_rowvec</code> are classes for row vectors (dense matrices with
one row).</p>
<p>The template <code>Row&lt;type&gt;</code> class is derived from the
<code>Mat&lt;type&gt;</code> class and inherits most of the member
functions.</p>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>rowvec = Row&lt;double&gt;</code></li>
<li><code>drowvec = Row&lt;double&gt;</code></li>
<li><code>frowvec = Row&lt;float&gt;</code></li>
<li><code>cx_rowvec = Row&lt;cx_double&gt;</code></li>
<li><code>cx_drowvec = Row&lt;cx_double&gt;</code></li>
<li><code>cx_frowvec = Row&lt;cx_float&gt;</code></li>
<li><code>urowvec = Row&lt;uword&gt;</code></li>
<li><code>irowvec = Row&lt;sword&gt;</code></li>
</ul>
<p>The <code>rowvec</code> type is used for convenience. It is possible
to use other row vector types instead (e.g., <code>frowvec</code>).</p>
<p>Functions which take <code>mat</code> as input can generally also
take <code>Row</code> as input. Main exceptions are functions which
require square matrices.</p>
<div class="section level3">
<h3 id="constructors-2">Constructors<a class="anchor" aria-label="anchor" href="#constructors-2"></a>
</h3>
<ul>
<li><code>rowvec()</code></li>
<li><code>rowvec(n_elem)</code></li>
<li>
<code>rowvec(n_elem, fill_form)</code> (elements are initialised
according to <code>fill_form</code>)</li>
<li><code>rowvec(size(X))</code></li>
<li>
<code>rowvec(size(X), fill_form)</code> (elements are initialised
according to <code>fill_form</code>)</li>
<li><code>rowvec(rowvec)</code></li>
<li>
<code>rowvec(mat)</code> (<code>std::logic_error</code> exception is
thrown if the given matrix has more than one row)</li>
<li><code>rowvec(initializer_list)</code></li>
<li>
<code>rowvec(string)</code> (elements separated by spaces)</li>
<li><code>rowvec(std::vector)</code></li>
<li>
<code>cx_rowvec(rowvec,rowvec)</code> (for constructing a complex
row vector out of two real row vectors)</li>
</ul>
</div>
<div class="section level3">
<h3 id="advanced-constructors-2">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors-2"></a>
</h3>
<ul>
<li>
<code>rowvec(ptr_aux_mem, number_of_elements, copy_aux_mem = true, strict = false)</code>
<ul>
<li>Create a row vector using data from writable auxiliary (external)
memory, where ptr_aux_mem is a pointer to the memory. By default the
vector allocates its own memory and copies data from the auxiliary
memory (for safety). However, if copy_aux_mem is set to
<code>false</code>, the vector will instead directly use the auxiliary
memory (e.g., no copying); this is faster, but can be dangerous unless
you know what you are doing.</li>
<li>The <code>strict</code> parameter comes into effect only when
copy_aux_mem is set to <code>false</code> (e.g., the vector is directly
using auxiliary memory).
<ul>
<li>When <code>strict</code> is set to <code>false</code>, the vector
will use the auxiliary memory until a size change or an aliasing
event.</li>
<li>When <code>strict</code> is set to <code>true</code>, the vector
will be bound to the auxiliary memory for its lifetime. The number of
elements in the vector cannot be changed.</li>
</ul>
</li>
</ul>
</li>
<li>
<code>rowvec(const ptr_aux_mem, number_of_elements)</code>
<ul>
<li>Create a row vector by copying data from read-only auxiliary memory,
where <code>ptr_aux_mem</code> is a pointer to the memory.</li>
</ul>
</li>
<li>
<code>rowvec::fixed&lt;number_of_elements&gt;</code>
<ul>
<li>Create a fixed size row vector, with the size specified via the
template argument. Memory for the vector is reserved at compile time.
This is generally faster than dynamic memory allocation, but the size of
the vector cannot be changed afterwards (directly or indirectly).</li>
<li>For convenience, there are several pre-defined typedefs for each
vector type (where the types are: <code>urowvec</code>,
<code>irowvec</code>, <code>frowvec</code>, <code>rowvec</code>,
<code>cx_frowvec</code>, <code>cx_rowvec</code>). The pre-defined
typedefs specify vector sizes ranging from 2 to 9. The typedefs were
defined by appending a single digit form of the size to the vector type.
Examples: <code>rowvec3</code> is equivalent to
<code>rowvec::fixed&lt;3&gt;</code>, and <code>cx_rowvec4</code> is
equivalent to <code>cx_rowvec::fixed&lt;4&gt;</code>.</li>
</ul>
</li>
<li>
<code>rowvec::fixed&lt;number_of_elements&gt;(fill_form)</code>
<ul>
<li>Create a fixed size row vector, with the elements explicitly
initialised according to <code>fill_form</code>.</li>
</ul>
</li>
<li>
<code>rowvec::fixed&lt;number_of_elements&gt;(const ptr_aux_mem)</code>
<ul>
<li>Create a fixed size row vector, with the size specified via the
template argument. The data is copied from auxiliary memory, where
<code>ptr_aux_mem</code> is a pointer to the memory.</li>
</ul>
</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-2">Examples<a class="anchor" aria-label="anchor" href="#examples-2"></a>
</h3>
<p>⚠️Important⚠️: ‘cpp11armadillo’ is an opinionated package and it
follows the notation from Econometrics by Bruce E. Hansen. It
intentionally exports/imports matrices and column vectors. You can use
row vectors in the functions, but the communication between R and C++
does not accept row vectors unless you transpose or convert those to
matrices.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">row1_</span><span class="op">(</span><span class="at">const</span> doubles<span class="op">&amp;</span> x<span class="op">,</span> <span class="at">const</span> doubles<span class="op">&amp;</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  vec X <span class="op">=</span> as_Col<span class="op">(</span>x<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  vec Y <span class="op">=</span> as_Col<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  mat A<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  </span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  rowvec Z <span class="op">=</span> A<span class="op">.</span>row<span class="op">(</span><span class="dv">5</span><span class="op">);</span>  <span class="co">// extract a row vector</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  Z <span class="op">=</span> Z <span class="op">+</span> Y<span class="op">.</span>t<span class="op">()</span> <span class="op">+</span> X<span class="op">.</span>t<span class="op">();</span> <span class="co">// transpose Y and X to be able to sum</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>  vec res <span class="op">=</span> Z<span class="op">.</span>t<span class="op">();</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>  </span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>res<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cube-class">Cube class<a class="anchor" aria-label="anchor" href="#cube-class"></a>
</h2>
<p><code>Cube&lt;type&gt;</code>, <code>cube</code> and
<code>cx_cube</code> are classes for cubes, also known as quasi 3rd
order tensors or “3D matrices”.</p>
<p>The data is stored as a set of slices (matrices) stored contiguously
within memory. Within each slice, elements are stored with column-major
ordering (e.g., column by column)</p>
<p>The root cube class is <code>Cube&lt;type&gt;</code>, where
<code>type</code> is one of: <code>float</code>, <code>double</code>,
<code>std::complex&lt;float&gt;</code>,
<code>std::complex&lt;double&gt;</code>, <code>short</code>,
<code>int</code>, <code>long</code> and unsigned versions of
<code>short</code>, <code>int</code>, <code>long</code>.</p>
<p>For convenience the following typedefs have been defined:</p>
<ul>
<li><code>cube = Cube&lt;double&gt;</code></li>
<li><code>dcube = Cube&lt;double&gt;</code></li>
<li><code>fcube = Cube&lt;float&gt;</code></li>
<li><code>cx_cube = Cube&lt;cx_double&gt;</code></li>
<li><code>cx_dcube = Cube&lt;cx_double&gt;</code></li>
<li><code>cx_fcube = Cube&lt;cx_float&gt;</code></li>
<li><code>ucube = Cube&lt;uword&gt;</code></li>
<li><code>icube = Cube&lt;sword&gt;</code></li>
</ul>
<p>The <code>cube</code> type is used for convenience. It is possible to
use other types instead (e.g., <code>fcube</code>).</p>
<p>Each cube slice can be interpreted as a matrix, hence functions which
take <code>Mat</code> as input can generally also take cube slices as
input.</p>
<div class="section level3">
<h3 id="constructors-3">Constructors<a class="anchor" aria-label="anchor" href="#constructors-3"></a>
</h3>
<ul>
<li><code>cube()</code></li>
<li><code>cube(n_rows, n_cols, n_slices_)</code></li>
<li>
<code>cube(n_rows, n_cols, n_slices, fill_form)</code> (elements are
initialised according to <code>fill_form</code>)</li>
<li><code>cube(size(X))</code></li>
<li>
<code>cube(size(X), fill_form)</code> (elements are initialised
according to <code>fill_form</code>)</li>
<li><code>cube(cube)</code></li>
<li>
<code>cx_cube(cube, cube)</code> (for constructing a complex cube
out of two real cubes)</li>
</ul>
<p>The elements can be explicitly initialised during construction by
specifying <code>fill_form</code>, which is one of:</p>
<ul>
<li>
<code>fill::zeros</code>: set all elements to 0 (default in
cpp11armadillo)</li>
<li>
<code>fill::ones</code>: set all elements to 1</li>
<li>
<code>fill::randu</code>: set all elements to random values from a
uniform distribution in the [0,1] interval</li>
<li>
<code>fill::randn</code>: set all elements to random values from a
normal distribution with zero mean and unit variance</li>
<li>
<code>fill::value(scalar)</code>: set all elements to specified
scalar</li>
<li>
<code>fill::none</code>: do not initialise the elements (cube may
have garbage values)</li>
</ul>
<p>Each instance of <code>cube</code> automatically allocates and
releases internal memory. All internally allocated memory used by an
instance of <code>cube</code> is automatically released as soon as the
instance goes out of scope. For example, if an instance of
<code>cube</code> is declared inside a function, it will be
automatically destroyed at the end of the function. To forcefully
release memory at any point, use <code>.reset()</code> note that in
normal use this is not required.</p>
</div>
<div class="section level3">
<h3 id="advanced-constructors-3">Advanced constructors<a class="anchor" aria-label="anchor" href="#advanced-constructors-3"></a>
</h3>
<ul>
<li>
<code>cube::fixed&lt;n_rows, n_cols, n_slices&gt;</code>: Create a
fixed size cube, with the size specified via template arguments. Memory
for the cube is reserved at compile time. This is generally faster than
dynamic memory allocation, but the size of the cube cannot be changed
afterwards (directly or indirectly).</li>
<li>
<code>cube(ptr_aux_mem, n_rows, n_cols, n_slices, copy_aux_mem = true, strict = false)</code>:
<ul>
<li>Create a cube using data from writable auxiliary (external) memory,
where <code>ptr_aux_mem</code> is a pointer to the memory. By default
the cube allocates its own memory and copies data from the auxiliary
memory (for safety). However, if <code>copy_aux_mem</code> is set to
<code>false</code>, the cube will instead directly use the auxiliary
memory (e.g., no copying). This is faster, but can be dangerous unless
you know what you are doing.</li>
<li>The <code>strict</code> parameter comes into effect only when
<code>copy_aux_mem</code> is set to <code>false</code> (e.g., the cube
is directly using auxiliary memory).</li>
<li>When <code>strict</code> is set to <code>false</code>, the cube will
use the auxiliary memory until a size change or an aliasing event.</li>
<li>When <code>strict</code> is set to <code>true</code>, the cube will
be bound to the auxiliary memory for its lifetime. The number of
elements in the cube cannot be changed.</li>
</ul>
</li>
<li>
<code>cube(const ptr_aux_mem, n_rows, n_cols, n_slices)</code>:
Create a cube by copying data from read-only auxiliary memory, where
<code>ptr_aux_mem</code> is a pointer to the memory.</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-3">Examples<a class="anchor" aria-label="anchor" href="#examples-3"></a>
</h3>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">b</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">cube1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">,</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>                                                <span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>  mat B <span class="op">=</span> as_Mat<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  cube X<span class="op">(</span>A<span class="op">.</span>n_rows<span class="op">,</span> A<span class="op">.</span>n_cols<span class="op">,</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// create a cube with 2 slices</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>  X<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> A<span class="op">;</span>                 <span class="co">// copy A into first slice</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>  X<span class="op">.</span>slice<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> B<span class="op">;</span>                 <span class="co">// copy B into second slice</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>  cube Y <span class="op">=</span> X <span class="op">+</span> X<span class="op">;</span>  <span class="co">// cube addition</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>  cube Z <span class="op">=</span> X <span class="op">%</span> X<span class="op">;</span>  <span class="co">// element-wise cube multiplication</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>  mat res <span class="op">=</span> Y<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">+</span> Z<span class="op">.</span>slice<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The size of individual slices cannot be changed. The following will
not work:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>cube c<span class="op">(</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>c<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span><span class="dv">10</span><span class="op">,</span><span class="dv">20</span><span class="op">);</span> <span class="co">// wrong size</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="field-class">Field class<a class="anchor" aria-label="anchor" href="#field-class"></a>
</h2>
<p><code>field&lt;object_type&gt;</code> is a class for storing
arbitrary objects in matrix-like or cube-like layouts.</p>
<p>It is similar to a matrix or cube, but instead of each element being
a scalar, each element can be a vector, or matrix, or cube. This is
similar to a list in R.</p>
<p>Each element can have an arbitrary size (e.g., in a field of
matrices, each matrix can have a unique size).</p>
<div class="section level3">
<h3 id="constructors-4">Constructors<a class="anchor" aria-label="anchor" href="#constructors-4"></a>
</h3>
<p><code>object_type</code> is another class (e.g., <code>vec</code>,
<code>mat</code>, <code>std::string</code>, etc)</p>
<ul>
<li><code>field&lt;object_type&gt;()</code></li>
<li><code>field&lt;object_type&gt;(n_elem)</code></li>
<li>
<code>field&lt;object_type&gt;(n_rows, n_cols)</code><br>
</li>
<li><code>field&lt;object_type&gt;(n_rows, n_cols, n_slices)</code></li>
<li><code>field&lt;object_type&gt;(size(X))</code></li>
<li><code>field&lt;object_type&gt;(field&lt;object_type&gt;)</code></li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-4">Examples<a class="anchor" aria-label="anchor" href="#examples-4"></a>
</h3>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">b</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">field1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">,</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>                                                 <span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  mat B <span class="op">=</span> as_Mat<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>  field<span class="op">&lt;</span>mat<span class="op">&gt;</span> F<span class="op">(</span>A<span class="op">.</span>n_rows<span class="op">,</span> A<span class="op">.</span>n_cols<span class="op">,</span> <span class="dv">3</span><span class="op">);</span>  <span class="co">// create a field with 2 matrices</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>  F<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> A<span class="op">;</span>                             <span class="co">// copy A into first location</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>  F<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> B<span class="op">;</span>                             <span class="co">// copy B into second location</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>  F<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">=</span> F<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">+</span> F<span class="op">(</span><span class="dv">1</span><span class="op">);</span>                   <span class="co">// matrix addition</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>  mat res <span class="op">=</span> F<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">+</span> F<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> F<span class="op">(</span><span class="dv">2</span><span class="op">).</span>t<span class="op">();</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat">Caveat<a class="anchor" aria-label="anchor" href="#caveat"></a>
</h3>
<p>To store a set of matrices of the same size, the <code>Cube</code>
class is more efficient.</p>
</div>
</div>
<div class="section level2">
<h2 id="member-functions-and-variables">Member Functions and Variables<a class="anchor" aria-label="anchor" href="#member-functions-and-variables"></a>
</h2>
<table class="table">
<colgroup>
<col width="19%">
<col width="80%">
</colgroup>
<thead><tr class="header">
<th>Function/Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.n_rows</code></td>
<td>number of rows</td>
</tr>
<tr class="even">
<td><code>.n_cols</code></td>
<td>number of columns</td>
</tr>
<tr class="odd">
<td><code>.n_elem</code></td>
<td>number of elements</td>
</tr>
<tr class="even">
<td><code>.n_slices</code></td>
<td>number of slices</td>
</tr>
<tr class="odd">
<td><code>()</code></td>
<td>element access</td>
</tr>
<tr class="even">
<td><code>[]</code></td>
<td>element access</td>
</tr>
<tr class="odd">
<td><code>.at()</code></td>
<td>element access</td>
</tr>
<tr class="even">
<td><code>.zeros</code></td>
<td>set all elements to zero</td>
</tr>
<tr class="odd">
<td><code>.ones</code></td>
<td>set all elements to one</td>
</tr>
<tr class="even">
<td><code>.eye</code></td>
<td>set elements along main diagonal to one and off-diagonal elements to
zero</td>
</tr>
<tr class="odd">
<td><code>.randu</code></td>
<td>set all elements to random values from a uniform distribution</td>
</tr>
<tr class="even">
<td><code>.randn</code></td>
<td>set all elements to random values from a normal distribution</td>
</tr>
<tr class="odd">
<td><code>.fill</code></td>
<td>set all elements to specified value</td>
</tr>
<tr class="even">
<td><code>.imbue</code></td>
<td>imbue (fill) with values provided by functor or lambda function</td>
</tr>
<tr class="odd">
<td><code>.clean</code></td>
<td>replace elements below a threshold with zeros</td>
</tr>
<tr class="even">
<td><code>.replace</code></td>
<td>replace specific elements with a new value</td>
</tr>
<tr class="odd">
<td><code>.clamp</code></td>
<td>clamp values to lower and upper limits</td>
</tr>
<tr class="even">
<td><code>.transform</code></td>
<td>transform each element via functor or lambda function</td>
</tr>
<tr class="odd">
<td><code>.for_each</code></td>
<td>apply a functor or lambda function to each element</td>
</tr>
<tr class="even">
<td><code>.set_size</code></td>
<td>change size without keeping elements (fast)</td>
</tr>
<tr class="odd">
<td><code>.reshape</code></td>
<td>change size while keeping elements</td>
</tr>
<tr class="even">
<td><code>.resize</code></td>
<td>change size while keeping elements and preserving layout</td>
</tr>
<tr class="odd">
<td><code>.copy_size</code></td>
<td>change size to be same as given object</td>
</tr>
<tr class="even">
<td><code>.reset</code></td>
<td>change size to empty</td>
</tr>
<tr class="odd">
<td><code>.diag</code></td>
<td>read/write access to matrix diagonals</td>
</tr>
<tr class="even">
<td><code>.each_col</code></td>
<td>vector operations applied to each column of matrix (aka
“broadcasting”)</td>
</tr>
<tr class="odd">
<td><code>.each_row</code></td>
<td>vector operations applied to each row of matrix (aka
“broadcasting”)</td>
</tr>
<tr class="even">
<td><code>.each_slice</code></td>
<td>matrix operations applied to each slice of cube (aka
“broadcasting”)</td>
</tr>
<tr class="odd">
<td><code>.set_imag</code></td>
<td>set imaginary part</td>
</tr>
<tr class="even">
<td><code>.set_real</code></td>
<td>set real part</td>
</tr>
<tr class="odd">
<td><code>.insert_rows</code></td>
<td>insert vector/matrix/cube at specified row</td>
</tr>
<tr class="even">
<td><code>.insert_cols</code></td>
<td>insert vector/matrix/cube at specified column</td>
</tr>
<tr class="odd">
<td><code>.insert_slices</code></td>
<td>insert vector/matrix/cube at specified slice</td>
</tr>
<tr class="even">
<td><code>.shed_rows</code></td>
<td>remove specified rows</td>
</tr>
<tr class="odd">
<td><code>.shed_cols</code></td>
<td>remove specified columns</td>
</tr>
<tr class="even">
<td><code>.shed_slices</code></td>
<td>remove specified slices</td>
</tr>
<tr class="odd">
<td><code>.swap_rows</code></td>
<td>swap specified rows</td>
</tr>
<tr class="even">
<td><code>.swap_cols</code></td>
<td>swap specified columns</td>
</tr>
<tr class="odd">
<td><code>.swap</code></td>
<td>swap contents with given object</td>
</tr>
<tr class="even">
<td><code>.memptr</code></td>
<td>raw pointer to memory</td>
</tr>
<tr class="odd">
<td><code>.colptr</code></td>
<td>raw pointer to memory used by specified column</td>
</tr>
<tr class="even">
<td><code>.as_col</code></td>
<td>return flattened matrix column as column vector</td>
</tr>
<tr class="odd">
<td><code>.as_row</code></td>
<td>return flattened matrix row as row vector</td>
</tr>
<tr class="even">
<td><code>.col_as_mat</code></td>
<td>return matrix representation of cube column</td>
</tr>
<tr class="odd">
<td><code>.row_as_mat</code></td>
<td>return matrix representation of cube row</td>
</tr>
<tr class="even">
<td><code>.as_dense</code></td>
<td>return dense vector/matrix representation of sparse matrix
expression</td>
</tr>
<tr class="odd">
<td><code>.t</code></td>
<td>return matrix transpose</td>
</tr>
<tr class="even">
<td><code>.st</code></td>
<td>return matrix conjugate transpose</td>
</tr>
<tr class="odd">
<td><code>.i</code></td>
<td>return inverse of square matrix</td>
</tr>
<tr class="even">
<td><code>.min</code></td>
<td>return minimum value</td>
</tr>
<tr class="odd">
<td><code>.max</code></td>
<td>return maximum value</td>
</tr>
<tr class="even">
<td><code>.index_min</code></td>
<td>return index of minimum value</td>
</tr>
<tr class="odd">
<td><code>.index_max</code></td>
<td>return index of maximum value</td>
</tr>
<tr class="even">
<td><code>.eval</code></td>
<td>force evaluation of delayed expression</td>
</tr>
<tr class="odd">
<td><code>.in_range</code></td>
<td>check whether given location or span is valid</td>
</tr>
<tr class="even">
<td><code>.is_empty</code></td>
<td>check whether object is empty</td>
</tr>
<tr class="odd">
<td><code>.is_vec</code></td>
<td>check whether matrix is a vector</td>
</tr>
<tr class="even">
<td><code>.is_sorted</code></td>
<td>check whether vector or matrix is sorted</td>
</tr>
<tr class="odd">
<td><code>.is_trimatu</code></td>
<td>check whether matrix is upper triangular</td>
</tr>
<tr class="even">
<td><code>.is_trimatl</code></td>
<td>check whether matrix is lower triangular</td>
</tr>
<tr class="odd">
<td><code>.is_diagmat</code></td>
<td>check whether matrix is diagonal</td>
</tr>
<tr class="even">
<td><code>.is_square</code></td>
<td>check whether matrix is square sized</td>
</tr>
<tr class="odd">
<td><code>.is_symmetric</code></td>
<td>check whether matrix is symmetric</td>
</tr>
<tr class="even">
<td><code>.is_hermitian</code></td>
<td>check whether matrix is hermitian</td>
</tr>
<tr class="odd">
<td><code>.is_sympd</code></td>
<td>check whether matrix is symmetric/hermitian positive definite</td>
</tr>
<tr class="even">
<td><code>.is_zero</code></td>
<td>check whether all elements are zero</td>
</tr>
<tr class="odd">
<td><code>.is_finite</code></td>
<td>check whether all elements are finite</td>
</tr>
<tr class="even">
<td><code>.has_inf</code></td>
<td>check whether any element is +/- infinity</td>
</tr>
<tr class="odd">
<td><code>.has_nan</code></td>
<td>check whether any element is NaN</td>
</tr>
</tbody>
</table>
</div>
<div class="section level2">
<h2 id="attributes">Attributes<a class="anchor" aria-label="anchor" href="#attributes"></a>
</h2>
<p><code>n_*</code> provides information for different objects:</p>
<ul>
<li>
<code>.n_rows</code> number of rows for <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>field</code>, and <code>SpMat</code>.</li>
<li>
<code>.n_cols</code> number of columns for <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>field</code>, and <code>SpMat</code>.</li>
<li>
<code>.n_elem</code> total number of elements for <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>field</code>, and <code>SpMat</code>.</li>
<li>
<code>.n_slices</code> number of slices for <code>Cube</code> and
<code>field</code>.</li>
<li>
<code>.n_nonzero</code> number of non-zero elements for
<code>SpMat</code>.</li>
</ul>
<p>For the <code>Col</code> and <code>Row</code> classes,
<code>n_elem</code> also indicates vector length.</p>
<p>The variables are read-only and of type <code>uword</code>. To change
the size, use <code>set_size</code>, <code>copy_size</code>,
<code>zeros_member</code>, <code>ones_member</code>, or
<code>reset</code>.</p>
<p>To avoid compiler warnings about implicit conversion when operating
<code>uword</code> with <code>integers</code>/<code>doubles</code> to
pass data to R, converte <code>uword</code> to <code>int</code> with
<code>static_cast&lt;int&gt;</code> or declare these as
<code>int</code>.</p>
<div class="section level3">
<h3 id="examples-5">Examples<a class="anchor" aria-label="anchor" href="#examples-5"></a>
</h3>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">attr1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>  <span class="co">// uword or int can be used</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  <span class="dt">int</span> n_rows <span class="op">=</span> A<span class="op">.</span>n_rows<span class="op">;</span>  <span class="co">// number of rows</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>  <span class="dt">int</span> n_cols <span class="op">=</span> A<span class="op">.</span>n_cols<span class="op">;</span>  <span class="co">// number of columns</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>  <span class="dt">int</span> n_elem <span class="op">=</span> A<span class="op">.</span>n_elem<span class="op">;</span>  <span class="co">// number of elements</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>  writable<span class="op">::</span>integers res<span class="op">({</span>n_rows<span class="op">,</span> n_cols<span class="op">,</span> n_elem<span class="op">});</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"n_rows"</span><span class="op">,</span> <span class="st">"n_cols"</span><span class="op">,</span> <span class="st">"n_elem"</span><span class="op">});</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="elementobject-access">Element/object access<a class="anchor" aria-label="anchor" href="#elementobject-access"></a>
</h2>
<p>Provide access to individual elements or objects stored in a
container object (e.g., <code>Mat</code>, <code>Col</code>,
<code>Row</code>, <code>Cube</code>, <code>field</code>).</p>
<ul>
<li>
<code>(i)</code> For <code>vec</code> and <code>rowvec</code>,
access the element stored at index <code>i</code>. For <code>Mat</code>,
<code>Cube</code> and <code>field</code>, access the element/object
stored at index <code>i</code> under the assumption of a flat layout,
with column-major ordering of data (e.g., column by column). An
exception is thrown if the requested element is out of bounds.</li>
<li>
<code>.at(i)</code> or <code>[i]</code> As for <code>(i)</code>, but
without a bounds check. Not recommended.</li>
<li>
<code>(r,c)</code> For <code>Mat</code> and 2D field classes, access
the element/object stored at row <code>r</code> and column
<code>c</code>. An exception is thrown if the requested element is out
of bounds.</li>
<li>
<code>.at(r,c)</code> As for <code>(r,c)</code>, but without a
bounds check. Not recommended.</li>
<li>
<code>(r,c,s)</code> For <code>Cube</code> and 3D field classes,
access the element/object stored at row <code>r</code>, column
<code>c</code>, and slice <code>s</code>. An exception is thrown if the
requested element is out of bounds.</li>
<li>
<code>.at(r,c,s)</code> As for <code>(r,c,s)</code>, but without a
bounds check. Not recommended.</li>
</ul>
<div class="section level3">
<h3 id="examples-6">Examples<a class="anchor" aria-label="anchor" href="#examples-6"></a>
</h3>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">access1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="fl">123.0</span><span class="op">;</span>     <span class="co">// set element at row 2, column 2</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  vec B<span class="op">(</span><span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  <span class="dt">double</span> x <span class="op">=</span> A<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">);</span>  <span class="co">// copy element at row 1, column 2 to a double</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  <span class="dt">double</span> y <span class="op">=</span> B<span class="op">(</span><span class="dv">1</span><span class="op">);</span>    <span class="co">// copy element at coordinate 2 to a double</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>  uword i<span class="op">,</span> j<span class="op">;</span> <span class="co">// int also works</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>  uword N <span class="op">=</span> A<span class="op">.</span>n_rows<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>  uword M <span class="op">=</span> A<span class="op">.</span>n_cols<span class="op">;</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> M<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>      A<span class="op">(</span>i<span class="op">,</span>j<span class="op">)</span> <span class="op">=</span> A<span class="op">(</span>i<span class="op">,</span>j<span class="op">)</span> <span class="op">+</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats">Caveats<a class="anchor" aria-label="anchor" href="#caveats"></a>
</h3>
<p>For <code>.at()</code> or <code>[i]</code>, <code>.at(r,c)</code> and
<code>.at(r,c,s)</code>:</p>
<ul>
<li>Indexing in C++ starts at 0</li>
<li>Accessing elements without bounds checks is slightly faster, but is
not recommended until your code has been thoroughly debugged first</li>
<li>Accessing elements via <code>[r,c]</code> and <code>[r,c,s]</code>
does not work correctly in C++; instead use <code>(r,c)</code> and
<code>(r,c,s)</code>
</li>
</ul>
<p>The indices of elements are specified via the <code>uword</code>
type, which is a <code>typedef</code> for an unsigned integer type. When
using loops to access elements, it more efficient to use
<code>uword</code> instead of <code>int</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="element-initialisation">Element initialisation<a class="anchor" aria-label="anchor" href="#element-initialisation"></a>
</h2>
<p>Set elements in <code>Mat</code>, <code>Col</code> and
<code>Row</code> via braced initialiser lists.</p>
<div class="section level3">
<h3 id="examples-7">Examples<a class="anchor" aria-label="anchor" href="#examples-7"></a>
</h3>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">initialization1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>  mat B <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">}};</span> <span class="co">// create new matrix</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>  vec C <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span> <span class="co">// create new column vector</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>  <span class="co">// sum C to the diagonal of A</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">)</span> <span class="op">+</span> C<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> C<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>  mat D <span class="op">=</span> A <span class="op">+</span> B<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>  </span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="zeros">Zeros<a class="anchor" aria-label="anchor" href="#zeros"></a>
</h2>
<p>Set the elements of an object to zero, optionally first changing the
size to specified dimensions.</p>
<p><code>.zeros()</code> (member function of <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>SpMat</code>,
<code>Cube</code>) <code>.zeros(n_elem)</code> (member function of
<code>Col</code> and <code>Row</code>)
<code>.zeros(n_rows, n_cols)</code> (member function of <code>Mat</code>
and <code>SpMat</code>) <code>.zeros(n_rows, n_cols, n_slices)</code>
(member function of <code>Cube</code>) <code>.zeros(size(X))</code>
(member function of <code>Mat</code>, <code>Col</code>,
<code>Row</code>, <code>Cube</code>, <code>SpMat</code>)</p>
<div class="section level3">
<h3 id="examples-8">Examples<a class="anchor" aria-label="anchor" href="#examples-8"></a>
</h3>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">zeros1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>  A<span class="op">.</span>zeros<span class="op">();</span>          <span class="co">// set all elements to zero</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>  mat B<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>  B<span class="op">.</span>zeros<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span> <span class="co">// set size to be the same as A and set all elements to zero</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>  mat C<span class="op">(</span>A<span class="op">.</span>n_rows<span class="op">,</span> A<span class="op">.</span>n_cols<span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a>  mat D <span class="op">=</span> A <span class="op">+</span> B <span class="op">+</span> C<span class="op">;</span></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="ones">Ones<a class="anchor" aria-label="anchor" href="#ones"></a>
</h2>
<p>Set all the elements of an object to one, optionally first changing
the size to specified dimensions.</p>
<table class="table">
<thead><tr class="header">
<th>Function</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.ones()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.ones(n_elem)</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td><code>.ones(n_rows, n_cols)</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>.ones(n_rows, n_cols, n_slices)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.ones(size(X))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="examples-9">Examples<a class="anchor" aria-label="anchor" href="#examples-9"></a>
</h3>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">ones1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>  A<span class="op">.</span>ones<span class="op">();</span>          <span class="co">// set all elements to zero</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>  mat B<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>  B<span class="op">.</span>ones<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span> <span class="co">// set size to be the same as A and set all elements to zero</span></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>  mat C<span class="op">(</span>A<span class="op">.</span>n_rows<span class="op">,</span> A<span class="op">.</span>n_cols<span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>  mat D <span class="op">=</span> A <span class="op">+</span> B <span class="op">+</span> C<span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="eye">Eye<a class="anchor" aria-label="anchor" href="#eye"></a>
</h2>
<p><code>.eye()</code> is member function of <code>Mat</code> and
<code>SpMat</code>. <code>.eye(n_rows, n_cols)</code> sets the elements
along the main diagonal to one and off-diagonal elements to zero,
optionally first changing the size to specified dimensions.
<code>.eye(size(X))</code> creates an identity matrix is generated when
<code>n_rows = n_cols</code>.</p>
<div class="section level3">
<h3 id="examples-10">Examples<a class="anchor" aria-label="anchor" href="#examples-10"></a>
</h3>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">eye1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  A<span class="op">.</span>eye<span class="op">();</span>            <span class="co">// create an identity matrix</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>  mat B<span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>  B<span class="op">.</span>eye<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span> <span class="co">// another identity matrix</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>  uword N <span class="op">=</span> A<span class="op">.</span>n_rows<span class="op">;</span></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>  uword M <span class="op">=</span> A<span class="op">.</span>n_cols<span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>  mat C<span class="op">(</span>N<span class="op">,</span> M<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>  C<span class="op">.</span>eye<span class="op">(</span>N<span class="op">,</span> M<span class="op">);</span> <span class="co">// yet another identity matrix</span></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>  mat D <span class="op">=</span> A <span class="op">+</span> B <span class="op">+</span> C<span class="op">;</span></span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="random-uniform">Random uniform<a class="anchor" aria-label="anchor" href="#random-uniform"></a>
</h2>
<p>Set all the elements to random values from a uniform distribution in
the [0,1] interval, optionally first changing the size to specified
dimensions.</p>
<p>For complex elements, the real and imaginary parts are treated
separately.</p>
<table class="table">
<thead><tr class="header">
<th>Function/Method</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.randu()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.randu(n_elem)</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td><code>.randu(n_rows, n_cols)</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>.randu(n_rows, n_cols, n_slices)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.randu(size(X))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">randu1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>  mat B<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>  B<span class="op">.</span>randu<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span> <span class="co">// random uniform matrix with the same size as A</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  mat C<span class="op">(</span>A<span class="op">.</span>n_rows<span class="op">,</span> A<span class="op">.</span>n_cols<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>  mat D <span class="op">=</span> A <span class="op">+</span> B <span class="op">+</span> C<span class="op">;</span></span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">randu2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>  GetRNGstate<span class="op">();</span>  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb25-16"><a href="#cb25-16" tabindex="-1"></a>  mat y<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb25-17"><a href="#cb25-17" tabindex="-1"></a>  <span class="op">::</span>arma_rng<span class="op">::</span>randu<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>fill<span class="op">(</span>y<span class="op">.</span>memptr<span class="op">(),</span> y<span class="op">.</span>n_elem<span class="op">);</span></span>
<span id="cb25-18"><a href="#cb25-18" tabindex="-1"></a>  PutRNGstate<span class="op">();</span></span>
<span id="cb25-19"><a href="#cb25-19" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb25-21"><a href="#cb25-21" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="normal-distribution">Normal distribution<a class="anchor" aria-label="anchor" href="#normal-distribution"></a>
</h2>
<p>Set all the elements to random values from a normal distribution with
zero mean and unit variance, optionally first changing the size to
specified dimensions.</p>
<p>For complex elements, the real and imaginary parts are treated
separately.</p>
<table class="table">
<thead><tr class="header">
<th>Function/Method</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.randn()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.randn(n_elem)</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td><code>.randn(n_rows, n_cols)</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>.randn(n_rows, n_cols, n_slices)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.randn(size(X))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="examples-11">Examples<a class="anchor" aria-label="anchor" href="#examples-11"></a>
</h3>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">randn1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>  mat B<span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>  B<span class="op">.</span>randn<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span> <span class="co">// random normal matrix with the same size as A</span></span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>  mat C<span class="op">(</span>A<span class="op">.</span>n_rows<span class="op">,</span> A<span class="op">.</span>n_cols<span class="op">,</span> fill<span class="op">::</span>randn<span class="op">);</span></span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a>  mat D <span class="op">=</span> A <span class="op">+</span> B <span class="op">+</span> C<span class="op">;</span></span>
<span id="cb27-10"><a href="#cb27-10" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb27-12"><a href="#cb27-12" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb27-13"><a href="#cb27-13" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">randn2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-15"><a href="#cb27-15" tabindex="-1"></a>  GetRNGstate<span class="op">();</span>  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb27-16"><a href="#cb27-16" tabindex="-1"></a>  mat y<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb27-17"><a href="#cb27-17" tabindex="-1"></a>  <span class="op">::</span>arma_rng<span class="op">::</span>randn<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>fill<span class="op">(</span>y<span class="op">.</span>memptr<span class="op">(),</span> y<span class="op">.</span>n_elem<span class="op">);</span></span>
<span id="cb27-18"><a href="#cb27-18" tabindex="-1"></a>  PutRNGstate<span class="op">();</span></span>
<span id="cb27-19"><a href="#cb27-19" tabindex="-1"></a>  </span>
<span id="cb27-20"><a href="#cb27-20" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb27-21"><a href="#cb27-21" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="fill">Fill<a class="anchor" aria-label="anchor" href="#fill"></a>
</h2>
<p>Sets the elements to a specified value</p>
<p><code>.fill(value)</code> is a member function of <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>field</code>.</p>
<p>The type of value must match the type of elements used by the
container object (e.g., for <code>Mat</code> the type is
<code>double</code>)</p>
<div class="section level3">
<h3 id="examples-12">Examples<a class="anchor" aria-label="anchor" href="#examples-12"></a>
</h3>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">fill1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>  uword N <span class="op">=</span> A<span class="op">.</span>n_rows<span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>  uword M <span class="op">=</span> A<span class="op">.</span>n_cols<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>  mat B<span class="op">(</span>size<span class="op">(</span>A<span class="op">),</span> fill<span class="op">::</span>value<span class="op">(</span><span class="fl">200.0</span><span class="op">));</span>  <span class="co">// create a matrix filled with 200.0</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>  mat C<span class="op">(</span>N<span class="op">,</span> M<span class="op">,</span> fill<span class="op">::</span>value<span class="op">(</span><span class="fl">100.0</span><span class="op">));</span>     <span class="co">// matrix filled with 100.0</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>  mat D<span class="op">(</span>N<span class="op">,</span> M<span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span>            <span class="co">// matrix filled with zeros</span></span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>  mat E<span class="op">(</span>N<span class="op">,</span> M<span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span>             <span class="co">// matrix filled with ones</span></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>  mat F <span class="op">=</span> A <span class="op">+</span> B <span class="op">+</span> C <span class="op">+</span> D <span class="op">+</span> E<span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>F<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="imbue">Imbue<a class="anchor" aria-label="anchor" href="#imbue"></a>
</h2>
<p><code>.imbue(functor)</code> is a member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code> and
<code>Cube</code>, it fills the elements with values provided by a
functor. The argument can be a functor or lambda function.</p>
<p>For matrices, filling is done column-by-column (e.g., column 0 is
filled, then column 1, etc.)</p>
<p>For cubes, filling is done slice-by-slice, with each slice treated as
a matrix</p>
<div class="section level3">
<h3 id="examples-13">Examples<a class="anchor" aria-label="anchor" href="#examples-13"></a>
</h3>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">imbue1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// convert from R to C++</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>  <span class="bu">std::</span>mt19937 engine<span class="op">;</span>  <span class="co">// Mersenne twister random number engine</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>  <span class="bu">std::</span>uniform_real_distribution<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> distr<span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a>  mat B<span class="op">(</span>size<span class="op">(</span>A<span class="op">),</span> fill<span class="op">::</span>none<span class="op">);</span>                <span class="co">// create an empty matrix</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>  B<span class="op">.</span>imbue<span class="op">([&amp;]()</span> <span class="op">{</span> <span class="cf">return</span> distr<span class="op">(</span>engine<span class="op">);</span> <span class="op">});</span>  <span class="co">// fill with random values</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a>  mat C <span class="op">=</span> A <span class="op">+</span> B<span class="op">;</span></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span>  <span class="co">// convert from C++ to R</span></span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">imbue2_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-16"><a href="#cb31-16" tabindex="-1"></a>  GetRNGstate<span class="op">();</span>  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb31-17"><a href="#cb31-17" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span>  <span class="co">// Convert from R to C++</span></span>
<span id="cb31-19"><a href="#cb31-19" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" tabindex="-1"></a>  mat B<span class="op">(</span>size<span class="op">(</span>A<span class="op">),</span> fill<span class="op">::</span>none<span class="op">);</span>  <span class="co">// Create an empty matrix</span></span>
<span id="cb31-21"><a href="#cb31-21" tabindex="-1"></a>  B<span class="op">.</span>imbue<span class="op">([]()</span> <span class="op">{</span> <span class="cf">return</span> unif_rand<span class="op">();</span> <span class="op">});</span>  <span class="co">// Fill with random values</span></span>
<span id="cb31-22"><a href="#cb31-22" tabindex="-1"></a></span>
<span id="cb31-23"><a href="#cb31-23" tabindex="-1"></a>  mat C <span class="op">=</span> A <span class="op">+</span> B<span class="op">;</span></span>
<span id="cb31-24"><a href="#cb31-24" tabindex="-1"></a></span>
<span id="cb31-25"><a href="#cb31-25" tabindex="-1"></a>  PutRNGstate<span class="op">();</span></span>
<span id="cb31-26"><a href="#cb31-26" tabindex="-1"></a></span>
<span id="cb31-27"><a href="#cb31-27" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb31-28"><a href="#cb31-28" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="clean">Clean<a class="anchor" aria-label="anchor" href="#clean"></a>
</h2>
<p><code>.clean(threshold)</code> is a member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
and <code>SpMat</code>. It can be used to sparsify a matrix, in the
sense of zeroing values with small magnitudes.</p>
<ul>
<li>For objects with non-complex elements: each element with an absolute
value less or equal to the threshold is replaced by zero.</li>
<li>For objects with complex elements: for each element, each component
(real and imaginary) with an absolute value less or equal to the
threshold is replaced by zero.</li>
</ul>
<div class="section level3">
<h3 id="examples-14">Examples<a class="anchor" aria-label="anchor" href="#examples-14"></a>
</h3>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">clean1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span> <span class="co">// create a random matrix</span></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> datum<span class="op">::</span>eps<span class="op">;</span> <span class="co">// set the diagonal with small values (+/- epsilon)</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="op">-</span>datum<span class="op">::</span>eps<span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a>  A<span class="op">.</span>clean<span class="op">(</span>datum<span class="op">::</span>eps<span class="op">);</span> <span class="co">// set elements with small values to zero</span></span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span> <span class="co">// Convert from C++ to R</span></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-1">Caveat<a class="anchor" aria-label="anchor" href="#caveat-1"></a>
</h3>
<p>To explicitly convert from dense storage to sparse storage, use the
<code>SpMat</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="replace">Replace<a class="anchor" aria-label="anchor" href="#replace"></a>
</h2>
<p><code>.replace( old_value, new_value )</code> is a member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
and <code>SpMat</code>.</p>
<p>For all elements equal to <code>old_value</code>, set them to
<code>new_value</code>.</p>
<div class="section level3">
<h3 id="examples-15">Examples<a class="anchor" aria-label="anchor" href="#examples-15"></a>
</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">replace1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span> <span class="co">// create a random matrix</span></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>  A<span class="op">.</span>diag<span class="op">().</span>fill<span class="op">(</span>datum<span class="op">::</span>nan<span class="op">);</span> <span class="co">// set the diagonal with NaN values</span></span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>  A<span class="op">.</span>replace<span class="op">(</span>datum<span class="op">::</span>nan<span class="op">,</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// replace each NaN with 0</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span> <span class="co">// Convert from C++ to R</span></span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-1">Caveats<a class="anchor" aria-label="anchor" href="#caveats-1"></a>
</h3>
<ul>
<li>The type of <code>old_value</code> and <code>new_value</code> must
match the type of elements used by the container object (e.g., for
<code>Mat</code> the type is <code>double</code>).</li>
<li>Floating point numbers (<code>float</code> and <code>double</code>)
are approximations due to their <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" class="external-link">limited
precision</a>.</li>
<li>For sparse matrices (<code>SpMat</code>), replacement is not done
when <code>old_value = 0</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="clamp">Clamp<a class="anchor" aria-label="anchor" href="#clamp"></a>
</h2>
<p><code>.clamp(min_value, max_value)</code> is a member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>
and <code>SpMat</code> that transforms all values lower than
<code>min_val</code> to <code>min_val</code>, and all values higher than
<code>max_val</code> to <code>max_val</code>.</p>
<ul>
<li>For complex elements, the real and imaginary components are clamped
separately.</li>
<li>For sparse matrices, clamping is applied only to the non-zero
elements.</li>
</ul>
<div class="section level3">
<h3 id="examples-16">Examples<a class="anchor" aria-label="anchor" href="#examples-16"></a>
</h3>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">clamp1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span> <span class="co">// create a random matrix</span></span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>  A<span class="op">.</span>diag<span class="op">().</span>fill<span class="op">(</span><span class="fl">0.1</span><span class="op">);</span>       <span class="co">// set the diagonal with 0.1 values</span></span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a>  A<span class="op">.</span>clamp<span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span> <span class="co">// clamp values to the [0.2, 0.8] interval</span></span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span> <span class="co">// Convert from C++ to R</span></span>
<span id="cb34-8"><a href="#cb34-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="transform">Transform<a class="anchor" aria-label="anchor" href="#transform"></a>
</h2>
<p><code>.transform(functor)</code> is a member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
and <code>SpMat</code>. The argument can be a functor or lambda
function.</p>
<ul>
<li>For dense matrices, transformation is done column-by-column for all
elements.</li>
<li>For sparse matrices, transformation is done column-by-column for
non-zero elements.</li>
<li>For cubes, transformation is done slice-by-slice, with each slice
treated as a matrix.</li>
</ul>
<div class="section level3">
<h3 id="examples-17">Examples<a class="anchor" aria-label="anchor" href="#examples-17"></a>
</h3>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">transform1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span>  <span class="co">// create a matrix filled with ones</span></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>  A<span class="op">.</span>transform<span class="op">([](</span><span class="dt">double</span> val<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>val <span class="op">+</span> <span class="fl">122.0</span><span class="op">);</span> <span class="op">});</span></span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span> <span class="co">// Convert from C++ to R</span></span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="for-each">For each<a class="anchor" aria-label="anchor" href="#for-each"></a>
</h2>
<p><code>.for_each(functor)</code> is a member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>SpMat</code>, and <code>field</code>. The argument can be a
functor or lambda function.</p>
<ul>
<li>For dense matrices and fields, the processing is done
column-by-column for all elements.</li>
<li>For sparse matrices, the processing is done column-by-column for
non-zero elements.</li>
<li>For cubes, processing is done slice-by-slice, with each slice
treated as a matrix.</li>
</ul>
<div class="section level3">
<h3 id="examples-18">Examples<a class="anchor" aria-label="anchor" href="#examples-18"></a>
</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">for_each1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>  <span class="co">// add 122 to each element in a dense matrix, the '&amp;' is important</span></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>  mat D<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>  D<span class="op">.</span>for_each<span class="op">([](</span>mat<span class="op">::</span><span class="dt">elem_type</span><span class="op">&amp;</span> val<span class="op">)</span> <span class="op">{</span> val <span class="op">+=</span> <span class="fl">122.0</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a>  <span class="co">// add 122 to each non-zero element in a sparse matrix</span></span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a>  sp_mat S<span class="op">;</span></span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a>  S<span class="op">.</span>sprandu<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a>  S<span class="op">.</span>for_each<span class="op">([](</span>sp_mat<span class="op">::</span><span class="dt">elem_type</span><span class="op">&amp;</span> val<span class="op">)</span> <span class="op">{</span> val <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a>  <span class="co">// set the size of all matrices in a field</span></span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a>  field<span class="op">&lt;</span>mat<span class="op">&gt;</span> F<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a>  F<span class="op">.</span>for_each<span class="op">([</span>n<span class="op">](</span>mat<span class="op">&amp;</span> X<span class="op">)</span> <span class="op">{</span> X<span class="op">.</span>zeros<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span> <span class="op">});</span>  <span class="co">// capture n for the lambda</span></span>
<span id="cb36-14"><a href="#cb36-14" tabindex="-1"></a></span>
<span id="cb36-15"><a href="#cb36-15" tabindex="-1"></a>  mat res <span class="op">=</span> D <span class="op">+</span> S <span class="op">+</span> F<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">+</span> F<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb36-16"><a href="#cb36-16" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb36-18"><a href="#cb36-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="set-size">Set size<a class="anchor" aria-label="anchor" href="#set-size"></a>
</h2>
<p>Change the size of an object, without explicitly preserving data and
without initialising the elements (e.g., elements may contain garbage
values, including <code>NaN</code>).</p>
<ul>
<li>
<code>.set_size(n_elem)</code> (member function of <code>Col</code>,
<code>Row</code>, <code>field</code>)</li>
<li>
<code>.set_size(n_rows, n_cols)</code> (member function of
<code>Mat</code>, <code>SpMat</code>, <code>field</code>)</li>
<li>
<code>.set_size(n_rows, n_cols, n_slices)</code> (member function of
<code>Cube</code> and <code>field</code>)</li>
<li>
<code>.set_size(size(X))</code> (member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>SpMat</code>, <code>field</code>)</li>
</ul>
<p>To initialise the elements to zero while changing the size, use
<code>.zeros()</code> instead. To explicitly preserve data while
changing the size, use <code>.reshape()</code> or <code>.resize()</code>
instead.</p>
<div class="section level3">
<h3 id="examples-19">Examples<a class="anchor" aria-label="anchor" href="#examples-19"></a>
</h3>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">set_size1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>  mat A<span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>  A<span class="op">.</span>set_size<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span>  <span class="co">// or:  mat A(n, n, fill::none);</span></span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>  mat B<span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a>  B<span class="op">.</span>set_size<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span>  <span class="co">// or:  mat B(size(A), fill::none);</span></span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a>  vec C<span class="op">;</span></span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a>  C<span class="op">.</span>set_size<span class="op">(</span>n<span class="op">);</span>  <span class="co">// or:  vec v(n, fill::none);</span></span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" tabindex="-1"></a>  A<span class="op">.</span>fill<span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// set all elements to 1.0</span></span>
<span id="cb37-12"><a href="#cb37-12" tabindex="-1"></a>  B<span class="op">.</span>fill<span class="op">(</span><span class="fl">2.0</span><span class="op">);</span>  <span class="co">// set all elements to 2.0</span></span>
<span id="cb37-13"><a href="#cb37-13" tabindex="-1"></a>  C<span class="op">.</span>fill<span class="op">(</span><span class="fl">3.0</span><span class="op">);</span>  <span class="co">// set all elements to 3.0</span></span>
<span id="cb37-14"><a href="#cb37-14" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" tabindex="-1"></a>  vec res <span class="op">=</span> A<span class="op">.</span>col<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">+</span> B<span class="op">.</span>col<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> C<span class="op">;</span></span>
<span id="cb37-16"><a href="#cb37-16" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb37-18"><a href="#cb37-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="reshape">Reshape<a class="anchor" aria-label="anchor" href="#reshape"></a>
</h2>
<p>Recreate an object according to given size specifications, with the
elements taken from the previous version of the object in a column-wise
manner. The elements in the generated object are placed column-wise
(e.g., the first column is filled up before filling the second
column)</p>
<ul>
<li>
<code>.reshape(n_rows, n_cols)</code> (member function of
<code>Mat</code> and <code>SpMat</code>)</li>
<li>
<code>.reshape(n_rows, n_cols, n_slices)</code> (member function of
<code>Cube</code>)</li>
<li>
<code>.reshape(size(X))</code> (member function of <code>Mat</code>,
<code>Cube</code>, <code>SpMat</code>)</li>
</ul>
<p>The layout of the elements in the recreated object will be different
to the layout in the previous version of the object</p>
<p>If the total number of elements in the previous version of the object
is less than the specified size, the extra elements in the recreated
object are set to zero</p>
<p>If the total number of elements in the previous version of the object
is greater than the specified size, only a subset of the elements is
taken</p>
<div class="section level3">
<h3 id="examples-20">Examples<a class="anchor" aria-label="anchor" href="#examples-20"></a>
</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">reshape1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>  A<span class="op">.</span>reshape<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-2">Caveats<a class="anchor" aria-label="anchor" href="#caveats-2"></a>
</h3>
<ul>
<li>
<code>.reshape()</code> is considerably slower than
<code>.set_size()</code>.</li>
<li>To change the size without preserving data, use
<code>.set_size()</code>.</li>
<li>To grow/shrink the object while preserving the elements and the
layout of the elements, use <code>.resize()</code>
</li>
<li>To flatten a matrix into a vector, use <code>vectorise()</code> or
<code>.as_col()</code>/<code>.as_row()</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="resize">Resize<a class="anchor" aria-label="anchor" href="#resize"></a>
</h2>
<p>Resize an object according to given size specifications, while
preserving the elements and the layout of the elements. It can be used
for growing or shrinking an object (e.g., adding/removing rows, and/or
columns, and/or slices).</p>
<ul>
<li>
<code>.resize(n_elem)</code>: member function of <code>Col</code>,
<code>Row</code>.</li>
<li>
<code>.resize(n_rows, n_cols)</code>: member function of
<code>Mat</code> and <code>SpMat</code>.</li>
<li>
<code>.resize(n_rows, n_cols, n_slices)</code>: member function of
<code>Cube</code>.</li>
<li>
<code>.resize(size(X))</code>: member function of <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>SpMat</code>.</li>
</ul>
<div class="section level3">
<h3 id="examples-21">Examples<a class="anchor" aria-label="anchor" href="#examples-21"></a>
</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">resize1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>  A<span class="op">.</span>resize<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-3">Caveats<a class="anchor" aria-label="anchor" href="#caveats-3"></a>
</h3>
<ul>
<li>
<code>.resize()</code> is considerably slower than
<code>.set_size()</code>.</li>
<li>to change the size without preserving data, <code>.set_size()</code>
instead.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="copy-size">Copy size<a class="anchor" aria-label="anchor" href="#copy-size"></a>
</h2>
<p><code>.copy_size(A)</code> sets the size of a matrix/vector/cube to
be the same as matrix/vector/cube <code>A</code>.</p>
<div class="section level3">
<h3 id="examples-22">Examples<a class="anchor" aria-label="anchor" href="#examples-22"></a>
</h3>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">copy_size1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>  mat B<span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a>  B<span class="op">.</span>copy_size<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a>  <span class="dt">int</span> N <span class="op">=</span> B<span class="op">.</span>n_rows<span class="op">;</span></span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a>  <span class="dt">int</span> M <span class="op">=</span> B<span class="op">.</span>n_cols<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a>  </span>
<span id="cb40-10"><a href="#cb40-10" tabindex="-1"></a>  writable<span class="op">::</span>integers res<span class="op">({</span>N<span class="op">,</span> M<span class="op">});</span></span>
<span id="cb40-11"><a href="#cb40-11" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"n_rows"</span><span class="op">,</span> <span class="st">"n_cols"</span><span class="op">});</span></span>
<span id="cb40-12"><a href="#cb40-12" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb40-14"><a href="#cb40-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-2">Caveat<a class="anchor" aria-label="anchor" href="#caveat-2"></a>
</h3>
<p>To set the size of an object <code>B</code>, <code>A</code> must be
of the same type as <code>B</code>. For example, the size of a matrix
cannot be set by providing a cube.</p>
</div>
</div>
<div class="section level2">
<h2 id="reset">Reset<a class="anchor" aria-label="anchor" href="#reset"></a>
</h2>
<p><code>.reset()</code> sets a matrix/vector size to zero (the object
will have no elements).</p>
<div class="section level3">
<h3 id="examples-23">Examples<a class="anchor" aria-label="anchor" href="#examples-23"></a>
</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">reset1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a>  A<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb41-4"><a href="#cb41-4" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" tabindex="-1"></a>  <span class="dt">int</span> N <span class="op">=</span> A<span class="op">.</span>n_rows<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" tabindex="-1"></a>  <span class="dt">int</span> M <span class="op">=</span> A<span class="op">.</span>n_cols<span class="op">;</span></span>
<span id="cb41-7"><a href="#cb41-7" tabindex="-1"></a>  </span>
<span id="cb41-8"><a href="#cb41-8" tabindex="-1"></a>  writable<span class="op">::</span>integers res<span class="op">({</span>N<span class="op">,</span> M<span class="op">});</span></span>
<span id="cb41-9"><a href="#cb41-9" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"n_rows"</span><span class="op">,</span> <span class="st">"n_cols"</span><span class="op">});</span></span>
<span id="cb41-10"><a href="#cb41-10" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb41-12"><a href="#cb41-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="submatrix-views">Submatrix views<a class="anchor" aria-label="anchor" href="#submatrix-views"></a>
</h2>
<p>A collection of member functions of <code>Mat</code>,
<code>Col</code> and <code>Row</code> classes that provide read/write
access to submatrix views.</p>
<div class="section level3">
<h3 id="contiguous-views-for-matrix">Contiguous views for matrix<a class="anchor" aria-label="anchor" href="#contiguous-views-for-matrix"></a>
</h3>
<ul>
<li><code>X.col(col_number)</code></li>
<li><code>X.row(row_number)</code></li>
<li>
<code>X.cols(first_col, last_col)</code><br>
</li>
<li><code>X.rows(first_row, last_row)</code></li>
<li><code>X.submat(first_row, first_col, last_row, last_col)</code></li>
<li><code>X(span(first_row, last_row), span(first_col, last_col))</code></li>
<li><code>X(first_row, first_col, size(n_rows, n_cols))</code></li>
<li>
<code>X(first_row, first_col, size(Y))</code> (<code>Y</code> is a
matrix)</li>
<li><code>X(span(first_row, last_row), col_number)</code></li>
<li><code>X(row_number, span(first_col, last_col))</code></li>
<li><code>X.head_cols(number_of_cols)</code></li>
<li><code>X.head_rows(number_of_rows)</code></li>
<li><code>X.tail_cols(number_of_cols)</code></li>
<li><code>X.tail_rows(number_of_rows)</code></li>
<li>
<code>X.unsafe_col(col_number)</code> (use with caution)</li>
</ul>
</div>
<div class="section level3">
<h3 id="contiguous-views-for-vector">Contiguous views for vector<a class="anchor" aria-label="anchor" href="#contiguous-views-for-vector"></a>
</h3>
<ul>
<li><code>Y(span(first_index, last_index))</code></li>
<li><code>Y.subvec(first_index, last_index)</code></li>
<li>
<code>Y.subvec(first_index, size(X))</code> (<code>X</code> is a
vector)<br>
</li>
<li><code>Y.head(number_of_elements)</code></li>
<li><code>Y.tail(number_of_elements)</code></li>
</ul>
</div>
<div class="section level3">
<h3 id="non-contiguous-views-for-matrix-or-vector">Non-contiguous views for matrix or vector:<a class="anchor" aria-label="anchor" href="#non-contiguous-views-for-matrix-or-vector"></a>
</h3>
<ul>
<li><code>X.elem(vector_of_indices)</code></li>
<li><code>X(vector_of_indices)</code></li>
<li><code>X.cols(vector_of_column_indices)</code></li>
<li><code>X.rows(vector_of_row_indices)</code></li>
<li><code>X.submat(vector_of_row_indices, vector_of_column_indices)</code></li>
<li><code>X(vector_of_row_indices, vector_of_column_indices)</code></li>
</ul>
<p>Instances of <code>span(start, end)</code> can be replaced by
<code>span::all_</code> to indicate the entire range.</p>
<p>For functions requiring one or more vector of indices, for example
<code>X.submat(vector_of_row_indices, vector_of_column_indices)</code>,
each vector of indices must be of type <code>uvec</code>.</p>
<p>In the function <code>X.elem(vector_of_indices)</code>, elements
specified in <code>vector_of_indices</code> are accessed. <code>X</code>
is interpreted as one long vector, with column-by-column ordering of the
elements of <code>X</code>. The <code>vector_of_indices</code> must
evaluate to a vector of type <code>uvec</code> (e.g., generated by the
<code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function). The aggregate set of the specified
elements is treated as a column vector (e.g., the output of
<code>X.elem()</code> is always a column vector).</p>
<p>The function <code>.unsafe_col()</code> is provided for speed reasons
and should be used only if you know what you are doing. It creates a
seemingly independent <code>Col</code> vector object (e.g.,
<code>vec</code>), but uses memory from the existing matrix object. As
such, the created vector is not alias safe, and does not take into
account that the underlying matrix memory could be freed (e.g., due to
any operation involving a size change of the matrix).</p>
</div>
<div class="section level3">
<h3 id="examples-24">Examples<a class="anchor" aria-label="anchor" href="#examples-24"></a>
</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">subview1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" tabindex="-1"></a>  A<span class="op">.</span>submat<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" tabindex="-1"></a>  A<span class="op">(</span>span<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">2</span><span class="op">),</span> span<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">))</span> <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb42-6"><a href="#cb42-6" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span> size<span class="op">(</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">))</span> <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb42-7"><a href="#cb42-7" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" tabindex="-1"></a>  mat B <span class="op">=</span> A<span class="op">.</span>submat<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb42-9"><a href="#cb42-9" tabindex="-1"></a>  mat C <span class="op">=</span> A<span class="op">(</span>span<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">2</span><span class="op">),</span> span<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">);</span></span>
<span id="cb42-10"><a href="#cb42-10" tabindex="-1"></a>  mat D <span class="op">=</span> A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> size<span class="op">(</span><span class="dv">3</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">);</span></span>
<span id="cb42-11"><a href="#cb42-11" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" tabindex="-1"></a>  A<span class="op">.</span>col<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span><span class="dv">5</span><span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb42-13"><a href="#cb42-13" tabindex="-1"></a>  A<span class="op">(</span>span<span class="op">::</span>all<span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span><span class="dv">5</span><span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb42-14"><a href="#cb42-14" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" tabindex="-1"></a>  mat X<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb42-16"><a href="#cb42-16" tabindex="-1"></a>    </span>
<span id="cb42-17"><a href="#cb42-17" tabindex="-1"></a>  <span class="co">// get all elements of X that are greater than 0.5</span></span>
<span id="cb42-18"><a href="#cb42-18" tabindex="-1"></a>  vec q <span class="op">=</span> X<span class="op">.</span>elem<span class="op">(</span> find<span class="op">(</span>X <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">);</span></span>
<span id="cb42-19"><a href="#cb42-19" tabindex="-1"></a>    </span>
<span id="cb42-20"><a href="#cb42-20" tabindex="-1"></a>  <span class="co">// add 123 to all elements of X greater than 0.5</span></span>
<span id="cb42-21"><a href="#cb42-21" tabindex="-1"></a>  X<span class="op">.</span>elem<span class="op">(</span> find<span class="op">(</span>X <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">)</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb42-22"><a href="#cb42-22" tabindex="-1"></a>    </span>
<span id="cb42-23"><a href="#cb42-23" tabindex="-1"></a>  <span class="co">// set four specific elements of X to 1</span></span>
<span id="cb42-24"><a href="#cb42-24" tabindex="-1"></a>  uvec indices <span class="op">=</span> <span class="op">{</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">8</span> <span class="op">};</span></span>
<span id="cb42-25"><a href="#cb42-25" tabindex="-1"></a>    </span>
<span id="cb42-26"><a href="#cb42-26" tabindex="-1"></a>  X<span class="op">.</span>elem<span class="op">(</span>indices<span class="op">)</span> <span class="op">=</span> ones<span class="op">&lt;</span>vec<span class="op">&gt;(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb42-27"><a href="#cb42-27" tabindex="-1"></a>    </span>
<span id="cb42-28"><a href="#cb42-28" tabindex="-1"></a>  <span class="co">// add 123 to the last 5 elements of vector a</span></span>
<span id="cb42-29"><a href="#cb42-29" tabindex="-1"></a>  vec a<span class="op">(</span><span class="dv">10</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb42-30"><a href="#cb42-30" tabindex="-1"></a>  a<span class="op">.</span>tail<span class="op">(</span><span class="dv">5</span><span class="op">)</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb42-31"><a href="#cb42-31" tabindex="-1"></a>    </span>
<span id="cb42-32"><a href="#cb42-32" tabindex="-1"></a>  <span class="co">// add 123 to the first 3 elements of column 2 of X</span></span>
<span id="cb42-33"><a href="#cb42-33" tabindex="-1"></a>  X<span class="op">.</span>col<span class="op">(</span><span class="dv">2</span><span class="op">).</span>head<span class="op">(</span><span class="dv">3</span><span class="op">)</span> <span class="op">+=</span> <span class="dv">123</span><span class="op">;</span></span>
<span id="cb42-34"><a href="#cb42-34" tabindex="-1"></a></span>
<span id="cb42-35"><a href="#cb42-35" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>X<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb42-36"><a href="#cb42-36" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="subcube-views-and-slices">Subcube views and slices<a class="anchor" aria-label="anchor" href="#subcube-views-and-slices"></a>
</h2>
<p>A collection of member functions of the <code>Cube</code> class that
provide subcube views.</p>
<div class="section level3">
<h3 id="contiguous-views-for-cube">Contiguous views for cube<a class="anchor" aria-label="anchor" href="#contiguous-views-for-cube"></a>
</h3>
<ul>
<li><code>Q.slice(slice_number)</code></li>
<li><code>Q.slices(first_slice, last_slice)</code></li>
<li><code>Q.row(row_number)</code></li>
<li><code>Q.rows(first_row, last_row)</code></li>
<li><code>Q.col(col_number)</code></li>
<li><code>Q.cols(first_col, last_col)</code></li>
<li><code>Q.subcube( first_row, first_col, first_slice, last_row, last_col, last_slice)</code></li>
<li><code>Q(span(first_row, last_row), span(first_col, last_col), span(first_slice, last_slice))</code></li>
<li><code>Q(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></li>
<li>
<code>Q(first_row, first_col, first_slice, size(R))</code>
(<code>R</code> is a cube)<br>
</li>
<li><code>Q.head_slices(number_of_slices)</code></li>
<li><code>Q.tail_slices(number_of_slices)</code></li>
<li><code>Q.tube(row, col)</code></li>
<li><code>Q.tube(first_row, first_col, last_row, last_col)</code></li>
<li><code>Q.tube(span(first_row, last_row), span(first_col, last_col))</code></li>
<li><code>Q.tube(first_row, first_col, size(n_rows, n_cols))</code></li>
</ul>
</div>
<div class="section level3">
<h3 id="non-contiguous-views-for-cube">Non-contiguous views for cube<a class="anchor" aria-label="anchor" href="#non-contiguous-views-for-cube"></a>
</h3>
<p><code>Q.elem(vector_of_indices)</code>,
<code>Q(vector_of_indices)</code>, and
<code>Q.slices( vector_of_slice_indices)</code> are instances of
<code>span(a,b)</code> that can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code>, to indicate the
entire range.</li>
<li>
<code>span(a)</code>, to indicate a particular row, column or
slice.</li>
</ul>
<p>An individual slice, accessed via <code>.slice()</code>, is an
instance of the <code>Mat</code> class (a reference to a matrix is
provided).</p>
<p>All <code>.tube()</code> forms are variants of
<code>.subcube()</code>, using <code>first_slice = 0</code> and
<code>last_slice = Q.n_slices-1</code>. The <code>.tube(row,col)</code>
form uses <code>row = first_row = last_row</code>, and
<code>col = first_col = last_col</code>.</p>
<p>In the function <code>Q.elem(vector_of_indices)</code>, elements
specified in <code>vector_of_indices</code> are accessed. <code>Q</code>
is interpreted as one long vector, with slice-by-slice and
column-by-column ordering of the elements of <code>Q</code>. The
<code>vector_of_indices</code> must evaluate to a vector of type
<code>uvec</code> (e.g., generated by the <code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function).
The aggregate set of the specified elements is treated as a column
vector (e.g., the output of <code>Q.elem()</code> is always a column
vector).</p>
<p>In the function <code>Q.slices(vector_of_slice_indices)</code>,
slices specified in <code>vector_of_slice_indices</code> are accessed.
The <code>vector_of_slice_indices</code> must evaluate to a vector of
type <code>uvec</code>.</p>
</div>
<div class="section level3">
<h3 id="examples-25">Examples<a class="anchor" aria-label="anchor" href="#examples-25"></a>
</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">subview2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>  cube A<span class="op">(</span>n<span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>    </span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a>  mat B <span class="op">=</span> A<span class="op">.</span>slice<span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="co">// each slice is a matrix</span></span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a>    </span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a>  A<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb43-7"><a href="#cb43-7" tabindex="-1"></a>  A<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">)(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">=</span> <span class="fl">99.0</span><span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8" tabindex="-1"></a>    </span>
<span id="cb43-9"><a href="#cb43-9" tabindex="-1"></a>  A<span class="op">.</span>subcube<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span>  <span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span>           <span class="op">=</span> randu<span class="op">&lt;</span>cube<span class="op">&gt;(</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb43-10"><a href="#cb43-10" tabindex="-1"></a>  A<span class="op">(</span>span<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">),</span> span<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">),</span> span<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">))</span> <span class="op">=</span> randu<span class="op">&lt;</span>cube<span class="op">&gt;(</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb43-11"><a href="#cb43-11" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span> size<span class="op">(</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">))</span>              <span class="op">=</span> randu<span class="op">&lt;</span>cube<span class="op">&gt;(</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb43-12"><a href="#cb43-12" tabindex="-1"></a>    </span>
<span id="cb43-13"><a href="#cb43-13" tabindex="-1"></a>  <span class="co">// add 123 to all elements of A greater than 0.5</span></span>
<span id="cb43-14"><a href="#cb43-14" tabindex="-1"></a>  A<span class="op">.</span>elem<span class="op">(</span> find<span class="op">(</span>A <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">)</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb43-15"><a href="#cb43-15" tabindex="-1"></a>    </span>
<span id="cb43-16"><a href="#cb43-16" tabindex="-1"></a>  cube C <span class="op">=</span> A<span class="op">.</span>head_slices<span class="op">(</span><span class="dv">2</span><span class="op">);</span>  <span class="co">// get first two slices</span></span>
<span id="cb43-17"><a href="#cb43-17" tabindex="-1"></a>    </span>
<span id="cb43-18"><a href="#cb43-18" tabindex="-1"></a>  A<span class="op">.</span>head_slices<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb43-19"><a href="#cb43-19" tabindex="-1"></a></span>
<span id="cb43-20"><a href="#cb43-20" tabindex="-1"></a>  mat res <span class="op">=</span> A<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">+</span> B <span class="op">+</span> C<span class="op">.</span>slice<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb43-21"><a href="#cb43-21" tabindex="-1"></a></span>
<span id="cb43-22"><a href="#cb43-22" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb43-23"><a href="#cb43-23" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="subfield-views">Subfield views<a class="anchor" aria-label="anchor" href="#subfield-views"></a>
</h2>
<p>A collection of member functions of the <code>field</code> class that
provide subfield views.</p>
<p>For a 2D field <code>F</code>, the subfields are accessed as:</p>
<ul>
<li><code>F.row(row_number)</code></li>
<li><code>F.col(col_number)</code></li>
<li><code>F.rows(first_row, last_row)</code></li>
<li><code>F.cols(first_col, last_col)</code></li>
<li><code>F.subfield(first_row, first_col, last_row, last_col)</code></li>
<li><code>F(span(first_row, last_row), span(first_col, last_col))</code></li>
<li>
<code>F(first_row, first_col, size(G))</code> (<code>G</code> is a
2D field)</li>
<li><code>F(first_row, first_col, size(n_rows, n_cols))</code></li>
</ul>
<p>For a 3D field <code>F</code>, the subfields are accessed as:</p>
<ul>
<li><code>F.slice(slice_number)</code></li>
<li><code>F.slices(first_slice, last_slice)</code></li>
<li><code>F.subfield(first_row, first_col, first_slice, last_row, last_col, last_slice)</code></li>
<li><code>F(span(first_row, last_row), span(first_col, last_col), span(first_slice, last_slice))</code></li>
<li>
<code>F(first_row, first_col, first_slice, size(G))</code>
(<code>G</code> is a 3D field)</li>
<li><code>F(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></li>
</ul>
<p>Instances of <code>span(a,b)</code> can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code>, to indicate the
entire range.</li>
<li>
<code>span(a)</code>, to indicate a particular row or column.</li>
</ul>
</div>
<div class="section level2">
<h2 id="diagonal">Diagonal<a class="anchor" aria-label="anchor" href="#diagonal"></a>
</h2>
<p><code>.diag()</code> is a member functions of <code>Mat</code> and
<code>SpMat</code> with read/write access to the diagonal in a matrix.
The argument can be empty or a value <code>k</code> to specify the
diagonal to (<code>k = 0</code> by default). The diagonal is interpreted
as a column vector within expressions.</p>
<ul>
<li>
<code>k = 0</code> indicates the main diagonal (default
setting)</li>
<li>
<code>k &lt; 0</code> indicates the <code>k</code>-th sub-diagonal
(below main diagonal, towards bottom-left corner)</li>
<li>
<code>k &gt; 0</code> indicates the <code>k</code>-th super-diagonal
(above main diagonal, towards top-right corner)</li>
</ul>
<div class="section level3">
<h3 id="examples-26">Examples<a class="anchor" aria-label="anchor" href="#examples-26"></a>
</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">diagonal1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>  vec A <span class="op">=</span> X<span class="op">.</span>diag<span class="op">();</span> <span class="co">// extract the main diagonal</span></span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>  <span class="dt">double</span> B <span class="op">=</span> accu<span class="op">(</span>X<span class="op">.</span>diag<span class="op">(</span><span class="dv">1</span><span class="op">));</span> <span class="co">// sum of elements on the first upper diagonal</span></span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a>  <span class="dt">double</span> C <span class="op">=</span> accu<span class="op">(</span>X<span class="op">.</span>diag<span class="op">(-</span><span class="dv">1</span><span class="op">));</span> <span class="co">// sum of elements on the first lower diagonal</span></span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a>  X<span class="op">.</span>diag<span class="op">()</span> <span class="op">=</span> randu<span class="op">&lt;</span>vec<span class="op">&gt;(</span>n<span class="op">);</span></span>
<span id="cb44-9"><a href="#cb44-9" tabindex="-1"></a>  X<span class="op">.</span>diag<span class="op">()</span> <span class="op">+=</span> A<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10" tabindex="-1"></a>  X<span class="op">.</span>diag<span class="op">()</span> <span class="op">/=</span> B<span class="op">;</span></span>
<span id="cb44-11"><a href="#cb44-11" tabindex="-1"></a>  X<span class="op">.</span>diag<span class="op">()</span> <span class="op">*=</span> C<span class="op">;</span></span>
<span id="cb44-12"><a href="#cb44-12" tabindex="-1"></a></span>
<span id="cb44-13"><a href="#cb44-13" tabindex="-1"></a>  sp_mat S <span class="op">=</span> sprandu<span class="op">&lt;</span>sp_mat<span class="op">&gt;(</span>n<span class="op">,</span> n<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb44-14"><a href="#cb44-14" tabindex="-1"></a>  S<span class="op">.</span>diag<span class="op">().</span>ones<span class="op">();</span></span>
<span id="cb44-15"><a href="#cb44-15" tabindex="-1"></a></span>
<span id="cb44-16"><a href="#cb44-16" tabindex="-1"></a>  vec v<span class="op">(</span>S<span class="op">.</span>diag<span class="op">());</span>  <span class="co">// copy sparse diagonal to dense vector</span></span>
<span id="cb44-17"><a href="#cb44-17" tabindex="-1"></a>  v <span class="op">+=</span> X<span class="op">.</span>diag<span class="op">();</span></span>
<span id="cb44-18"><a href="#cb44-18" tabindex="-1"></a></span>
<span id="cb44-19"><a href="#cb44-19" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>v<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb44-20"><a href="#cb44-20" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-3">Caveat<a class="anchor" aria-label="anchor" href="#caveat-3"></a>
</h3>
<p>To calculate only the diagonal elements of a compound expression, use
<code>diagvec()</code> or <code>diagmat()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="each-col">Each col<a class="anchor" aria-label="anchor" href="#each-col"></a>
</h2>
<p><code>.each_col()</code> is a member function of <code>Mat</code>. It
applies a vector operation to each column of a matrix, and are similar
to “broadcasting” in Matlab/Octave. The argument can be empty, a vector
of indices, or a lambda function.</p>
<table class="table">
<colgroup>
<col width="38%">
<col width="13%">
<col width="29%">
<col width="19%">
</colgroup>
<thead><tr class="header">
<th>Operation</th>
<th><code>.each_col()</code></th>
<th><code>.each_col(vector_of_indices)</code></th>
<th><code>.each_col(lambda)</code></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>
<code>+</code> addition</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>+=</code> in-place addition</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>-</code> subtraction</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>-=</code> in-place subtraction</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>%</code> element-wise multiplication</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>%=</code> in-place element-wise multiplication</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>/</code> element-wise division</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>/=</code> in-place element-wise division</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>=</code> assignment (copy)</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>lambda</code> (lambda function)</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="examples-27">Examples<a class="anchor" aria-label="anchor" href="#examples-27"></a>
</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">each_col1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a>  <span class="co">// create a vector with n elements ranging from 5 to 10</span></span>
<span id="cb45-5"><a href="#cb45-5" tabindex="-1"></a>  vec v <span class="op">=</span> linspace<span class="op">&lt;</span>vec<span class="op">&gt;(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb45-6"><a href="#cb45-6" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" tabindex="-1"></a>  <span class="co">// in-place addition of v to each column vector of X</span></span>
<span id="cb45-8"><a href="#cb45-8" tabindex="-1"></a>  X<span class="op">.</span>each_col<span class="op">()</span> <span class="op">+=</span> v<span class="op">;</span></span>
<span id="cb45-9"><a href="#cb45-9" tabindex="-1"></a></span>
<span id="cb45-10"><a href="#cb45-10" tabindex="-1"></a>  <span class="co">// generate Y by adding v to each column vector of X</span></span>
<span id="cb45-11"><a href="#cb45-11" tabindex="-1"></a>  mat Y <span class="op">=</span> X<span class="op">.</span>each_col<span class="op">()</span> <span class="op">+</span> v<span class="op">;</span></span>
<span id="cb45-12"><a href="#cb45-12" tabindex="-1"></a></span>
<span id="cb45-13"><a href="#cb45-13" tabindex="-1"></a>  <span class="co">// subtract v from columns 1 and 2 of X</span></span>
<span id="cb45-14"><a href="#cb45-14" tabindex="-1"></a>  X<span class="op">.</span>cols<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">).</span>each_col<span class="op">()</span> <span class="op">-=</span> v<span class="op">;</span></span>
<span id="cb45-15"><a href="#cb45-15" tabindex="-1"></a></span>
<span id="cb45-16"><a href="#cb45-16" tabindex="-1"></a>  uvec indices<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb45-17"><a href="#cb45-17" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb45-18"><a href="#cb45-18" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb45-19"><a href="#cb45-19" tabindex="-1"></a></span>
<span id="cb45-20"><a href="#cb45-20" tabindex="-1"></a>  X<span class="op">.</span>each_col<span class="op">(</span>indices<span class="op">)</span> <span class="op">=</span> v<span class="op">;</span>  <span class="co">// copy v to columns 1 and 2 of X</span></span>
<span id="cb45-21"><a href="#cb45-21" tabindex="-1"></a></span>
<span id="cb45-22"><a href="#cb45-22" tabindex="-1"></a>  <span class="co">// lambda function with non-const vector</span></span>
<span id="cb45-23"><a href="#cb45-23" tabindex="-1"></a>  X<span class="op">.</span>each_col<span class="op">([](</span>vec<span class="op">&amp;</span> a<span class="op">)</span> <span class="op">{</span> <span class="dv">2</span> <span class="op">*</span> a<span class="op">;</span> <span class="op">});</span></span>
<span id="cb45-24"><a href="#cb45-24" tabindex="-1"></a></span>
<span id="cb45-25"><a href="#cb45-25" tabindex="-1"></a>  <span class="at">const</span> mat<span class="op">&amp;</span> XX <span class="op">=</span> X<span class="op">;</span></span>
<span id="cb45-26"><a href="#cb45-26" tabindex="-1"></a></span>
<span id="cb45-27"><a href="#cb45-27" tabindex="-1"></a>  <span class="co">// lambda function with const vector</span></span>
<span id="cb45-28"><a href="#cb45-28" tabindex="-1"></a>  XX<span class="op">.</span>each_col<span class="op">([](</span><span class="at">const</span> vec<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span> <span class="dv">3</span> <span class="op">*</span> b<span class="op">;</span> <span class="op">});</span></span>
<span id="cb45-29"><a href="#cb45-29" tabindex="-1"></a></span>
<span id="cb45-30"><a href="#cb45-30" tabindex="-1"></a>  mat res <span class="op">=</span> X <span class="op">+</span> Y <span class="op">+</span> XX<span class="op">;</span></span>
<span id="cb45-31"><a href="#cb45-31" tabindex="-1"></a></span>
<span id="cb45-32"><a href="#cb45-32" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb45-33"><a href="#cb45-33" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="each-row">Each row<a class="anchor" aria-label="anchor" href="#each-row"></a>
</h2>
<p><code>.each_row()</code>, <code>.each_row(vector_of_indices)</code>,
<code>.each_row(lambdaction)</code> are member functions of
<code>Mat</code>. These apply a vector operation to each row of a
matrix, and are similar to “broadcasting” in Matlab/Octave.</p>
<div class="section level3">
<h3 id="form-1">Form 1<a class="anchor" aria-label="anchor" href="#form-1"></a>
</h3>
<p><code>.each_row()</code> supports the following operations:</p>
<ul>
<li>
<code>+</code> addition</li>
<li>
<code>+=</code> in-place addition</li>
<li>
<code>-</code> subtraction</li>
<li>
<code>-=</code> in-place subtraction</li>
<li>
<code>%</code> element-wise multiplication</li>
<li>
<code>%=</code> in-place element-wise multiplication</li>
<li>
<code>/</code> element-wise division</li>
<li>
<code>/=</code> in-place element-wise division</li>
<li>
<code>=</code> assignment (copy)</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-2">Form 2<a class="anchor" aria-label="anchor" href="#form-2"></a>
</h3>
<p><code>.each_row(vector_of_indices)</code> supports the same
operations as form 1. The argument <code>vector_of_indices</code>
contains a list of indices of the rows to be used, and it must evaluate
to a vector of type <code>uvec</code>.</p>
</div>
<div class="section level3">
<h3 id="form-3">Form 3<a class="anchor" aria-label="anchor" href="#form-3"></a>
</h3>
<p><code>.each_col(lambdaction)</code> applies the given
<code>lambdaction</code> to each column vector. The function must accept
a reference to a <code>Row</code> object with the same element type as
the underlying matrix.</p>
</div>
<div class="section level3">
<h3 id="examples-28">Examples<a class="anchor" aria-label="anchor" href="#examples-28"></a>
</h3>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">each_row1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a>  mat X<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a>  <span class="co">// create a vector with n elements ranging from 5 to 10</span></span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a>  rowvec v <span class="op">=</span> linspace<span class="op">&lt;</span>rowvec<span class="op">&gt;(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb46-6"><a href="#cb46-6" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" tabindex="-1"></a>  <span class="co">// in-place addition of v to each rows vector of X</span></span>
<span id="cb46-8"><a href="#cb46-8" tabindex="-1"></a>  X<span class="op">.</span>each_row<span class="op">()</span> <span class="op">+=</span> v<span class="op">;</span></span>
<span id="cb46-9"><a href="#cb46-9" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" tabindex="-1"></a>  <span class="co">// generate Y by adding v to each rows vector of X</span></span>
<span id="cb46-11"><a href="#cb46-11" tabindex="-1"></a>  mat Y <span class="op">=</span> X<span class="op">.</span>each_row<span class="op">()</span> <span class="op">+</span> v<span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" tabindex="-1"></a>  <span class="co">// subtract v from rows 1 and 2 of X</span></span>
<span id="cb46-14"><a href="#cb46-14" tabindex="-1"></a>  X<span class="op">.</span>rows<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">).</span>each_row<span class="op">()</span> <span class="op">-=</span> v<span class="op">;</span></span>
<span id="cb46-15"><a href="#cb46-15" tabindex="-1"></a></span>
<span id="cb46-16"><a href="#cb46-16" tabindex="-1"></a>  uvec indices<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb46-17"><a href="#cb46-17" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb46-18"><a href="#cb46-18" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb46-19"><a href="#cb46-19" tabindex="-1"></a></span>
<span id="cb46-20"><a href="#cb46-20" tabindex="-1"></a>  X<span class="op">.</span>each_row<span class="op">(</span>indices<span class="op">)</span> <span class="op">=</span> v<span class="op">;</span>       <span class="co">// copy v to columns 1 and 2 of X</span></span>
<span id="cb46-21"><a href="#cb46-21" tabindex="-1"></a></span>
<span id="cb46-22"><a href="#cb46-22" tabindex="-1"></a>  <span class="co">// lambda function with non-const vector</span></span>
<span id="cb46-23"><a href="#cb46-23" tabindex="-1"></a>  X<span class="op">.</span>each_row<span class="op">([](</span>rowvec<span class="op">&amp;</span> a<span class="op">)</span> <span class="op">{</span> a <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb46-24"><a href="#cb46-24" tabindex="-1"></a></span>
<span id="cb46-25"><a href="#cb46-25" tabindex="-1"></a>  <span class="at">const</span> mat<span class="op">&amp;</span> XX <span class="op">=</span> X<span class="op">;</span></span>
<span id="cb46-26"><a href="#cb46-26" tabindex="-1"></a></span>
<span id="cb46-27"><a href="#cb46-27" tabindex="-1"></a>  <span class="co">// lambda function with const vector</span></span>
<span id="cb46-28"><a href="#cb46-28" tabindex="-1"></a>  XX<span class="op">.</span>each_row<span class="op">([](</span><span class="at">const</span> rowvec<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span> b <span class="op">/</span> <span class="dv">3</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb46-29"><a href="#cb46-29" tabindex="-1"></a></span>
<span id="cb46-30"><a href="#cb46-30" tabindex="-1"></a>  mat res <span class="op">=</span> X <span class="op">+</span> Y <span class="op">+</span> XX<span class="op">;</span></span>
<span id="cb46-31"><a href="#cb46-31" tabindex="-1"></a></span>
<span id="cb46-32"><a href="#cb46-32" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb46-33"><a href="#cb46-33" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="each-slice">Each slice<a class="anchor" aria-label="anchor" href="#each-slice"></a>
</h2>
<p><code>.each_slice()</code> is a member function of <code>Cube</code>
that applies a matrix operation to each slice of a cube, with each slice
treated as a matrix. It is similar to “broadcasting” in
Matlab/Octave.</p>
<div class="section level3">
<h3 id="form-1-1">Form 1<a class="anchor" aria-label="anchor" href="#form-1-1"></a>
</h3>
<p><code>.each_slice(vector_of_indices)</code></p>
<p>Supported operations:</p>
<ul>
<li>
<code>+</code> addition</li>
<li>
<code>+=</code> in-place addition</li>
<li>
<code>-</code> subtraction</li>
<li>
<code>-=</code> in-place subtraction</li>
<li>
<code>%</code> element-wise multiplication</li>
<li>
<code>%=</code> in-place element-wise multiplication</li>
<li>
<code>/</code> element-wise division</li>
<li>
<code>/=</code> in-place element-wise division</li>
<li>
<code>*</code> matrix multiplication</li>
<li>
<code>*=</code> in-place matrix multiplication</li>
<li>
<code>=</code> assignment (copy)</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-2-1">Form 2<a class="anchor" aria-label="anchor" href="#form-2-1"></a>
</h3>
<p><code>.each_slice(lambdaction)</code></p>
<ul>
<li>The argument <em>vector_of_indices</em> contains a list of indices
of the slices to be used; it must evaluate to a vector of type
<code>uvec</code>.</li>
<li>Arithmetic operations as per form 1 are supported, except for
<code>*</code> and <code>*=</code> (e.g., matrix multiplication).</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-3-1">Form 3<a class="anchor" aria-label="anchor" href="#form-3-1"></a>
</h3>
<p><code>.each_slice(lambdaction, use_mp)</code></p>
<ul>
<li>Apply the given <code>lambdaction</code> to each slice.</li>
<li>The function must accept a reference to a <code>Mat</code> object
with the same element type as the underlying cube.</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-4">Form 4<a class="anchor" aria-label="anchor" href="#form-4"></a>
</h3>
<ul>
<li>Apply the given <code>lambdaction</code> to each slice, as per form
3.</li>
<li>The argument <code>use_mp</code> is a bool to enable the use of
OpenMP for multi-threaded execution of <code>lambdaction</code> on
multiple slices at the same time.</li>
<li>The order of processing the slices is not deterministic (e.g., slice
2 can be processed before slice 1).</li>
<li>
<code>lambdaction</code> must be thread-safe, e.g., it must not
write to variables outside of its scope.</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-29">Examples:<a class="anchor" aria-label="anchor" href="#examples-29"></a>
</h3>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">each_slice1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a>  cube C<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a>  mat M <span class="op">=</span> repmat<span class="op">(</span>linspace<span class="op">&lt;</span>vec<span class="op">&gt;(</span><span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> n<span class="op">),</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb47-5"><a href="#cb47-5" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" tabindex="-1"></a>  C<span class="op">.</span>each_slice<span class="op">()</span> <span class="op">+=</span> M<span class="op">;</span>  <span class="co">// in-place addition of M to each slice of C</span></span>
<span id="cb47-7"><a href="#cb47-7" tabindex="-1"></a></span>
<span id="cb47-8"><a href="#cb47-8" tabindex="-1"></a>  cube D <span class="op">=</span> C<span class="op">.</span>each_slice<span class="op">()</span> <span class="op">+</span> M<span class="op">;</span>  <span class="co">// generate D by adding M to each slice of C</span></span>
<span id="cb47-9"><a href="#cb47-9" tabindex="-1"></a></span>
<span id="cb47-10"><a href="#cb47-10" tabindex="-1"></a>  <span class="co">// sum all slices of D into a single n x (n + 1) matrix</span></span>
<span id="cb47-11"><a href="#cb47-11" tabindex="-1"></a>  mat D_flat <span class="op">=</span> sum<span class="op">(</span>D<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb47-12"><a href="#cb47-12" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" tabindex="-1"></a>  uvec indices<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb47-14"><a href="#cb47-14" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb47-15"><a href="#cb47-15" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb47-16"><a href="#cb47-16" tabindex="-1"></a></span>
<span id="cb47-17"><a href="#cb47-17" tabindex="-1"></a>  C<span class="op">.</span>each_slice<span class="op">(</span>indices<span class="op">)</span> <span class="op">=</span> M<span class="op">;</span>  <span class="co">// copy M to slices 2 and 4 in C</span></span>
<span id="cb47-18"><a href="#cb47-18" tabindex="-1"></a>  C<span class="op">.</span>each_slice<span class="op">([](</span>mat<span class="op">&amp;</span> X<span class="op">)</span> <span class="op">{</span> X <span class="op">*</span> <span class="fl">2.0</span><span class="op">;</span> <span class="op">});</span>  <span class="co">// lambda function with non-const matrix</span></span>
<span id="cb47-19"><a href="#cb47-19" tabindex="-1"></a>  mat C_flat <span class="op">=</span> sum<span class="op">(</span>C<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb47-20"><a href="#cb47-20" tabindex="-1"></a></span>
<span id="cb47-21"><a href="#cb47-21" tabindex="-1"></a>  <span class="at">const</span> cube<span class="op">&amp;</span> CC <span class="op">=</span> C<span class="op">;</span></span>
<span id="cb47-22"><a href="#cb47-22" tabindex="-1"></a>  CC<span class="op">.</span>each_slice<span class="op">([](</span><span class="at">const</span> mat<span class="op">&amp;</span> X<span class="op">)</span> <span class="op">{</span> X <span class="op">/</span> <span class="fl">3.0</span><span class="op">;</span> <span class="op">});</span>  <span class="co">// lambda function with const matrix</span></span>
<span id="cb47-23"><a href="#cb47-23" tabindex="-1"></a></span>
<span id="cb47-24"><a href="#cb47-24" tabindex="-1"></a>  mat CC_flat <span class="op">=</span> sum<span class="op">(</span>CC<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb47-25"><a href="#cb47-25" tabindex="-1"></a></span>
<span id="cb47-26"><a href="#cb47-26" tabindex="-1"></a>  mat res <span class="op">=</span> C_flat <span class="op">+</span> D_flat <span class="op">+</span> CC_flat<span class="op">;</span></span>
<span id="cb47-27"><a href="#cb47-27" tabindex="-1"></a></span>
<span id="cb47-28"><a href="#cb47-28" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb47-29"><a href="#cb47-29" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="set-real">Set real<a class="anchor" aria-label="anchor" href="#set-real"></a>
</h2>
<p><code>.set_real(X)</code> sets the real part of an object.
<code>X</code> must have the same size as the recipient object.</p>
<div class="section level3">
<h3 id="examples-30">Examples<a class="anchor" aria-label="anchor" href="#examples-30"></a>
</h3>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">set_real1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a>  cx_mat C<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a></span>
<span id="cb48-6"><a href="#cb48-6" tabindex="-1"></a>  C<span class="op">.</span>set_real<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb48-7"><a href="#cb48-7" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" tabindex="-1"></a>  <span class="cf">return</span> as_complex_matrix<span class="op">(</span>C<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb48-9"><a href="#cb48-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-4">Caveat<a class="anchor" aria-label="anchor" href="#caveat-4"></a>
</h3>
<p>To directly construct a complex matrix out of two real matrices, the
following code is faster:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">set_real2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span>    </span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a>  mat B<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb49-4"><a href="#cb49-4" tabindex="-1"></a>  </span>
<span id="cb49-5"><a href="#cb49-5" tabindex="-1"></a>  cx_mat C <span class="op">=</span> cx_mat<span class="op">(</span>A<span class="op">,</span>B<span class="op">);</span></span>
<span id="cb49-6"><a href="#cb49-6" tabindex="-1"></a></span>
<span id="cb49-7"><a href="#cb49-7" tabindex="-1"></a>  <span class="cf">return</span> as_complex_matrix<span class="op">(</span>C<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb49-8"><a href="#cb49-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="set-imaginary">Set imaginary<a class="anchor" aria-label="anchor" href="#set-imaginary"></a>
</h2>
<p><code>.set_imaginary(X)</code> sets the imaginary part of an object.
<code>X</code> must have the same size as the recipient object.</p>
<div class="section level3">
<h3 id="examples-31">Examples<a class="anchor" aria-label="anchor" href="#examples-31"></a>
</h3>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">set_imag1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>  mat B<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a>  cx_mat C<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a>  C<span class="op">.</span>set_imag<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" tabindex="-1"></a>  <span class="cf">return</span> as_complex_matrix<span class="op">(</span>C<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb50-9"><a href="#cb50-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-5">Caveat<a class="anchor" aria-label="anchor" href="#caveat-5"></a>
</h3>
<p>To directly construct a complex matrix out of two real matrices, the
following code is faster:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">set_imag2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span>    </span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb51-3"><a href="#cb51-3" tabindex="-1"></a>  mat B<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb51-4"><a href="#cb51-4" tabindex="-1"></a>  </span>
<span id="cb51-5"><a href="#cb51-5" tabindex="-1"></a>  cx_mat C <span class="op">=</span> cx_mat<span class="op">(</span>A<span class="op">,</span>B<span class="op">);</span></span>
<span id="cb51-6"><a href="#cb51-6" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" tabindex="-1"></a>  <span class="cf">return</span> as_complex_matrix<span class="op">(</span>C<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb51-8"><a href="#cb51-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="insert-columns">Insert columns<a class="anchor" aria-label="anchor" href="#insert-columns"></a>
</h2>
<p><code>.insert_cols()</code> is a member function of <code>Mat</code>,
<code>Row</code> and <code>Cube</code>. The arguments can be
<code>colnumber, X</code> to indicate the column number and the matrix
to insert, or <code>colnumber, number_of_cols</code> to indicate the
column number and the number of columns to insert.</p>
<p>The <code>X</code> argument inserts a copy of <code>X</code> at the
specified column. <code>X</code> must have the same number of rows (and
slices) as the recipient object.</p>
<p>The <code>number_of_cols</code> argument expands the object by
creating new columns that are set to zero.</p>
<div class="section level3">
<h3 id="examples-32">Examples<a class="anchor" aria-label="anchor" href="#examples-32"></a>
</h3>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">insert_columns1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb52-3"><a href="#cb52-3" tabindex="-1"></a>  mat B<span class="op">(</span>n<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb52-4"><a href="#cb52-4" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" tabindex="-1"></a>  <span class="co">// at column n - 1, insert a copy of B</span></span>
<span id="cb52-6"><a href="#cb52-6" tabindex="-1"></a>  <span class="co">// A will now have 3n - 1 columns</span></span>
<span id="cb52-7"><a href="#cb52-7" tabindex="-1"></a>  A<span class="op">.</span>insert_cols<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> B<span class="op">);</span></span>
<span id="cb52-8"><a href="#cb52-8" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" tabindex="-1"></a>  <span class="co">// at column 1, insert 2n zeroed columns</span></span>
<span id="cb52-10"><a href="#cb52-10" tabindex="-1"></a>  <span class="co">// B will now have 3n - 1 columns</span></span>
<span id="cb52-11"><a href="#cb52-11" tabindex="-1"></a>  B<span class="op">.</span>insert_cols<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb52-12"><a href="#cb52-12" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" tabindex="-1"></a>  mat res <span class="op">=</span> A <span class="op">+</span> B<span class="op">;</span></span>
<span id="cb52-14"><a href="#cb52-14" tabindex="-1"></a></span>
<span id="cb52-15"><a href="#cb52-15" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb52-16"><a href="#cb52-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="insert-rows">Insert rows<a class="anchor" aria-label="anchor" href="#insert-rows"></a>
</h2>
<p><code>.insert_rows()</code> is a member function of <code>Mat</code>,
<code>Row</code> and <code>Cube</code>. The arguments can be
<code>rownumber, X</code> to indicate the row number and the matrix to
insert, or <code>rownumber, number_of_rows</code> to indicate the row
number and the number of rows to insert.</p>
<p>The <code>X</code> argument inserts a copy of <code>X</code> at the
specified column. <code>X</code> must have the same number of columns
(and slices) as the recipient object.</p>
<p>The <code>number_of_rows</code> argument expands the object by
creating new rows that are set to zero.</p>
<div class="section level3">
<h3 id="examples-33">Examples<a class="anchor" aria-label="anchor" href="#examples-33"></a>
</h3>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">insert_rows1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb53-3"><a href="#cb53-3" tabindex="-1"></a>  mat B<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb53-4"><a href="#cb53-4" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" tabindex="-1"></a>  <span class="co">// at row n - 1, insert a copy of B</span></span>
<span id="cb53-6"><a href="#cb53-6" tabindex="-1"></a>  <span class="co">// A will now have 3n - 1 rows</span></span>
<span id="cb53-7"><a href="#cb53-7" tabindex="-1"></a>  A<span class="op">.</span>insert_rows<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> B<span class="op">);</span></span>
<span id="cb53-8"><a href="#cb53-8" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" tabindex="-1"></a>  <span class="co">// at row 1, insert 2n zeroed rows</span></span>
<span id="cb53-10"><a href="#cb53-10" tabindex="-1"></a>  <span class="co">// B will now have 3n - 1 columns</span></span>
<span id="cb53-11"><a href="#cb53-11" tabindex="-1"></a>  B<span class="op">.</span>insert_rows<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb53-12"><a href="#cb53-12" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" tabindex="-1"></a>  mat res <span class="op">=</span> A <span class="op">+</span> B<span class="op">;</span></span>
<span id="cb53-14"><a href="#cb53-14" tabindex="-1"></a></span>
<span id="cb53-15"><a href="#cb53-15" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb53-16"><a href="#cb53-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="insert-slice">Insert slice<a class="anchor" aria-label="anchor" href="#insert-slice"></a>
</h2>
<p><code>.insert_slices()</code> is a member function of
<code>Cube</code>. The arguments can be <code>slice_number, X</code> to
indicate the slice number and the matrix to insert, or
<code>slice_number, number_of_slices</code> to indicate the slice number
and the number of slices to insert.</p>
<p>The <code>X</code> argument inserts a copy of <code>X</code> at the
specified slice. <code>X</code> must have the same number of columns and
rows as the recipient object.</p>
<p>The <code>number_of_slices</code> argument expands the object by
creating new slices that are set to zero.</p>
<div class="section level3">
<h3 id="examples-34">Examples<a class="anchor" aria-label="anchor" href="#examples-34"></a>
</h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">insert_slices1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a>  cube A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a>  cube B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a>  <span class="co">// At slice n - 1, insert a copy of B</span></span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a>  <span class="co">// A will now have 3n - 1 slices</span></span>
<span id="cb54-7"><a href="#cb54-7" tabindex="-1"></a>  A<span class="op">.</span>insert_slices<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> B<span class="op">);</span></span>
<span id="cb54-8"><a href="#cb54-8" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" tabindex="-1"></a>  <span class="co">// At slice 1, insert 2n zeroed slices</span></span>
<span id="cb54-10"><a href="#cb54-10" tabindex="-1"></a>  <span class="co">// B will now have 3n - 1 slices</span></span>
<span id="cb54-11"><a href="#cb54-11" tabindex="-1"></a>  B<span class="op">.</span>insert_slices<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb54-12"><a href="#cb54-12" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" tabindex="-1"></a>  mat res <span class="op">=</span> sum<span class="op">(</span>A <span class="op">+</span> B<span class="op">);</span></span>
<span id="cb54-14"><a href="#cb54-14" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb54-16"><a href="#cb54-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shed-columns">Shed columns<a class="anchor" aria-label="anchor" href="#shed-columns"></a>
</h2>
<p><code>.shed_col(row_number)</code> and
<code>.shed_cols(first_row, last_row)</code> are member functions of
<code>Mat</code>, <code>Col</code>, <code>SpMat</code>, and
<code>Cube</code>. With a single scalar argument it remove the specified
column, and with two scalar arguments it removes the specified range of
columns.</p>
<p><code>.shed_cols(vector_of_indices)</code> is a member function of
<code>Mat</code> and <code>Col</code>. With a vector of indices it must
evaluate to a vector of type <code>uvec</code> containing the indices of
the columns to remove.</p>
<div class="section level3">
<h3 id="examples-35">Examples<a class="anchor" aria-label="anchor" href="#examples-35"></a>
</h3>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">shed_columns1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">*</span> <span class="dv">5</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb55-3"><a href="#cb55-3" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" tabindex="-1"></a>  <span class="co">// remove the first column</span></span>
<span id="cb55-5"><a href="#cb55-5" tabindex="-1"></a>  A<span class="op">.</span>shed_col<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb55-6"><a href="#cb55-6" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" tabindex="-1"></a>  <span class="co">// remove columns 1 and 2</span></span>
<span id="cb55-8"><a href="#cb55-8" tabindex="-1"></a>  A<span class="op">.</span>shed_cols<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb55-9"><a href="#cb55-9" tabindex="-1"></a></span>
<span id="cb55-10"><a href="#cb55-10" tabindex="-1"></a>  <span class="co">// remove columns 2 and 4</span></span>
<span id="cb55-11"><a href="#cb55-11" tabindex="-1"></a>  uvec indices<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb55-12"><a href="#cb55-12" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-13"><a href="#cb55-13" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb55-14"><a href="#cb55-14" tabindex="-1"></a>  A<span class="op">.</span>shed_cols<span class="op">(</span>indices<span class="op">);</span></span>
<span id="cb55-15"><a href="#cb55-15" tabindex="-1"></a></span>
<span id="cb55-16"><a href="#cb55-16" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb55-17"><a href="#cb55-17" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shed-rows">Shed rows<a class="anchor" aria-label="anchor" href="#shed-rows"></a>
</h2>
<p><code>.shed_row(row_number)</code> and
<code>.shed_rows(first_row, last_row)</code> are member functions of
<code>Mat</code>, <code>Col</code>, <code>SpMat</code>, and
<code>Cube</code>. With a single scalar argument it remove the specified
rows, and with two scalar arguments it removes the specified range of
rows.</p>
<p><code>.shed_rows(vector_of_indices)</code> is a member function of
<code>Mat</code> and <code>Row</code>. With a vector of indices it must
evaluate to a vector of type <code>uvec</code> containing the indices of
the rows to remove.</p>
<div class="section level3">
<h3 id="examples-36">Examples<a class="anchor" aria-label="anchor" href="#examples-36"></a>
</h3>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">shed_rows1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">*</span> <span class="dv">5</span><span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a>  <span class="co">// remove the first row</span></span>
<span id="cb56-5"><a href="#cb56-5" tabindex="-1"></a>  A<span class="op">.</span>shed_row<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb56-6"><a href="#cb56-6" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" tabindex="-1"></a>  <span class="co">// remove rows 1 and 2</span></span>
<span id="cb56-8"><a href="#cb56-8" tabindex="-1"></a>  A<span class="op">.</span>shed_rows<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb56-9"><a href="#cb56-9" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" tabindex="-1"></a>  <span class="co">// remove rows 2 and 4</span></span>
<span id="cb56-11"><a href="#cb56-11" tabindex="-1"></a>  uvec indices<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb56-12"><a href="#cb56-12" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb56-13"><a href="#cb56-13" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb56-14"><a href="#cb56-14" tabindex="-1"></a>  A<span class="op">.</span>shed_rows<span class="op">(</span>indices<span class="op">);</span></span>
<span id="cb56-15"><a href="#cb56-15" tabindex="-1"></a></span>
<span id="cb56-16"><a href="#cb56-16" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb56-17"><a href="#cb56-17" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shed-slices">Shed slices<a class="anchor" aria-label="anchor" href="#shed-slices"></a>
</h2>
<p><code>.shed_slices()</code> is a member function of
<code>Cube</code>. With a single scalar argument it remove the specified
slices, and with two scalar arguments it removes the specified range of
slices. With a vector of indices it must evaluate to a vector of type
<code>uvec</code> containing the indices of the rows to remove. The
arguments can be <code>slice_number</code> to indicate the slice number
to remove, <code>first_slice, last_slice</code> to indicate the range of
slices to remove, or <code>vector_of_indices</code> to indicate the
indices of the slices to remove.</p>
<div class="section level3">
<h3 id="examples-37">Examples<a class="anchor" aria-label="anchor" href="#examples-37"></a>
</h3>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">shed_slices1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>  cube A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> n <span class="op">*</span> <span class="dv">5</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a>  <span class="co">// remove the first slice</span></span>
<span id="cb57-5"><a href="#cb57-5" tabindex="-1"></a>  A<span class="op">.</span>shed_slice<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb57-6"><a href="#cb57-6" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" tabindex="-1"></a>  <span class="co">// remove slices 1 and 2</span></span>
<span id="cb57-8"><a href="#cb57-8" tabindex="-1"></a>  A<span class="op">.</span>shed_slices<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb57-9"><a href="#cb57-9" tabindex="-1"></a></span>
<span id="cb57-10"><a href="#cb57-10" tabindex="-1"></a>  <span class="co">// remove slices 2 and 4</span></span>
<span id="cb57-11"><a href="#cb57-11" tabindex="-1"></a>  uvec indices<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb57-12"><a href="#cb57-12" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb57-13"><a href="#cb57-13" tabindex="-1"></a>  indices<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb57-14"><a href="#cb57-14" tabindex="-1"></a>  A<span class="op">.</span>shed_slices<span class="op">(</span>indices<span class="op">);</span></span>
<span id="cb57-15"><a href="#cb57-15" tabindex="-1"></a></span>
<span id="cb57-16"><a href="#cb57-16" tabindex="-1"></a>  mat res <span class="op">=</span> sum<span class="op">(</span>A<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb57-17"><a href="#cb57-17" tabindex="-1"></a></span>
<span id="cb57-18"><a href="#cb57-18" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb57-19"><a href="#cb57-19" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="swap-columns">Swap columns<a class="anchor" aria-label="anchor" href="#swap-columns"></a>
</h2>
<p><code>.swap_cols( col1, col2 )</code> is a member functions of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, and
<code>SpMat</code>. It swaps the contents of the specified columns.</p>
<div class="section level3">
<h3 id="examples-38">Examples<a class="anchor" aria-label="anchor" href="#examples-38"></a>
</h3>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">swap_columns1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">*</span> <span class="dv">5</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" tabindex="-1"></a>  <span class="co">// swap columns 1 and 2</span></span>
<span id="cb58-5"><a href="#cb58-5" tabindex="-1"></a>  A<span class="op">.</span>swap_cols<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-6"><a href="#cb58-6" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" tabindex="-1"></a>  <span class="co">// swap columns 2 and 4</span></span>
<span id="cb58-8"><a href="#cb58-8" tabindex="-1"></a>  A<span class="op">.</span>swap_cols<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb58-9"><a href="#cb58-9" tabindex="-1"></a></span>
<span id="cb58-10"><a href="#cb58-10" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb58-11"><a href="#cb58-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="swap-rows">Swap rows<a class="anchor" aria-label="anchor" href="#swap-rows"></a>
</h2>
<p><code>.swap_rows( col1, col2 )</code> is a member functions of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, and
<code>SpMat</code>. It swaps the contents of the specified rows.</p>
<div class="section level3">
<h3 id="examples-39">Examples<a class="anchor" aria-label="anchor" href="#examples-39"></a>
</h3>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">swap_rows1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>  mat A<span class="op">(</span>n <span class="op">*</span> <span class="dv">5</span><span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>  <span class="co">// swap rows 1 and 2</span></span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a>  A<span class="op">.</span>swap_rows<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>  <span class="co">// swap rows 2 and 4</span></span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a>  A<span class="op">.</span>swap_rows<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb59-11"><a href="#cb59-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="swap">Swap<a class="anchor" aria-label="anchor" href="#swap"></a>
</h2>
<p><code>.swap( X )</code> is a member function of <code>Mat</code>,
<code>Col</code>, <code>Row</code>, and <code>Cube</code>. It swaps the
contents with object <code>X</code>.</p>
<div class="section level3">
<h3 id="examples-40">Examples<a class="anchor" aria-label="anchor" href="#examples-40"></a>
</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">swap1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>  mat B<span class="op">(</span>n <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" tabindex="-1"></a>  A<span class="op">.</span>swap<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb60-6"><a href="#cb60-6" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb60-8"><a href="#cb60-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="memory-pointer">Memory pointer<a class="anchor" aria-label="anchor" href="#memory-pointer"></a>
</h2>
<p><code>.memptr()</code> is a member function of <code>Mat</code>,
<code>Col</code>, <code>Row</code>, and <code>Cube</code>. It obtains a
raw pointer to the memory used for storing elements. Data for matrices
is stored in a column-by-column order. Data for cubes is stored in a
slice-by-slice (matrix-by-matrix) order.</p>
<div class="section level3">
<h3 id="examples-41">Examples<a class="anchor" aria-label="anchor" href="#examples-41"></a>
</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">memptr1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb61-3"><a href="#cb61-3" tabindex="-1"></a>  <span class="at">const</span> mat B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb61-4"><a href="#cb61-4" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" tabindex="-1"></a>  <span class="dt">double</span><span class="op">*</span> A_mem <span class="op">=</span> A<span class="op">.</span>memptr<span class="op">();</span></span>
<span id="cb61-6"><a href="#cb61-6" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span><span class="op">*</span> B_mem <span class="op">=</span> B<span class="op">.</span>memptr<span class="op">();</span></span>
<span id="cb61-7"><a href="#cb61-7" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" tabindex="-1"></a>  <span class="co">// alter A_mem</span></span>
<span id="cb61-9"><a href="#cb61-9" tabindex="-1"></a>  <span class="co">// B_mem is const, so it cannot be altered</span></span>
<span id="cb61-10"><a href="#cb61-10" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">*</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-11"><a href="#cb61-11" tabindex="-1"></a>    A_mem<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> <span class="fl">123.0</span> <span class="op">+</span> B_mem<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb61-12"><a href="#cb61-12" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb61-13"><a href="#cb61-13" tabindex="-1"></a></span>
<span id="cb61-14"><a href="#cb61-14" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb61-15"><a href="#cb61-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-4">Caveats<a class="anchor" aria-label="anchor" href="#caveats-4"></a>
</h3>
<ul>
<li>The pointer becomes invalid after any operation involving a size
change or aliasing.</li>
<li>This function is not recommended for use unless you know what you
are doing.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="column-pointer">Column pointer<a class="anchor" aria-label="anchor" href="#column-pointer"></a>
</h2>
<p><code>.colptr( col_number )</code> is a member function of the
<code>Mat</code> class that obtains a raw pointer to the memory used by
elements in the specified column.</p>
<div class="section level3">
<h3 id="examples-42">Examples<a class="anchor" aria-label="anchor" href="#examples-42"></a>
</h3>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">colptr1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a>  <span class="co">// pointer to the memory of the first column of A</span></span>
<span id="cb62-5"><a href="#cb62-5" tabindex="-1"></a>  <span class="dt">double</span><span class="op">*</span> Acol1_mem <span class="op">=</span> A<span class="op">.</span>colptr<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb62-6"><a href="#cb62-6" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" tabindex="-1"></a>  <span class="co">// alter memory</span></span>
<span id="cb62-8"><a href="#cb62-8" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-9"><a href="#cb62-9" tabindex="-1"></a>    Acol1_mem<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb62-10"><a href="#cb62-10" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb62-11"><a href="#cb62-11" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb62-13"><a href="#cb62-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-5">Caveats<a class="anchor" aria-label="anchor" href="#caveats-5"></a>
</h3>
<ul>
<li>The pointer becomes invalid after any operation involving a size
change or aliasing.</li>
<li>This function is not recommended for use unless you know what you
are doing.</li>
<li>It is safer to use <code>submat()</code> instead.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="iterators">Iterators<a class="anchor" aria-label="anchor" href="#iterators"></a>
</h2>
<p>Iterators for traverse over all elements within the specified range.
These return the column/row/slice of an object as a <code>uword</code>
type.</p>
<div class="section level3">
<h3 id="member-functions">Member functions<a class="anchor" aria-label="anchor" href="#member-functions"></a>
</h3>
<p>Dense matrices and vectors (<code>Mat</code>, <code>Col</code>, and
<code>Row</code>):</p>
<ul>
<li>
<code>.begin()</code> is an iterator referring to the first
element.</li>
<li>
<code>.end()</code> is an iterator referring to the past the end
element.</li>
<li>
<code>.begin_col(col_number)</code> is an iterator referring to the
first element of the specified column.</li>
<li>
<code>.end_col(col_number)</code> is an iterator referring to the
past-the-end element of the specified column.</li>
<li>
<code>begin_row(row_number)</code> is an iterator referring to the
first element of the specified row.</li>
<li>
<code>end_row(row_number)</code> is an iterator referring to the
past-the-end element of the specified row.</li>
</ul>
<p>Cubes (<code>Cube</code>):</p>
<ul>
<li>
<code>begin()</code> is an iterator referring to the first
element.</li>
<li>
<code><a href="https://rdrr.io/r/stats/start.html" class="external-link">end()</a></code> is an iterator referring to the past-the-end
element.</li>
<li>
<code>begin_slice(slice_number)</code> iterator referring to the
first element of the specified slice.</li>
<li>
<code>end_slice(slice_number)</code> iterator referring to the
past-the-end element of the specified slice.</li>
</ul>
<p>Sparse matrices (<code>SpMat</code>):</p>
<ul>
<li>
<code>begin()</code> is an iterator referring to the first
element.</li>
<li>
<code><a href="https://rdrr.io/r/stats/start.html" class="external-link">end()</a></code> is an iterator referring to the past-the-end
element.</li>
<li>
<code>begin_col(col_number)</code> is an iterator referring to the
first element of the specified column.</li>
<li>
<code>end_col(col_number)</code> is an iterator referring to the
past-the-end element of the specified column.</li>
<li>
<code>begin_row(row_number)</code> is an iterator referring to the
first element of the specified row.</li>
<li>
<code>end_row(row_number)</code> is an iterator referring to the
past-the-end element of the specified row.</li>
</ul>
<p>Dense submatrices and subcubes (<code>submatrix</code> and
<code>subcube</code>):</p>
<ul>
<li>
<code>span(row, col)</code> and <code>span(row, col, slice)</code>
can be used to specify the range of elements to iterate over.</li>
</ul>
</div>
<div class="section level3">
<h3 id="iterator-types">Iterator types<a class="anchor" aria-label="anchor" href="#iterator-types"></a>
</h3>
<p>Dense matrices and vectors (<code>Mat</code>, <code>Col</code>, and
<code>Row</code>):</p>
<ul>
<li>
<code>mat::iterator</code>, <code>vec::iterator</code> and
<code>rowvec::iterator</code> are random access iterators, for
read/write access to elements (which are stored column by column).</li>
<li>
<code>mat::const_iterator</code>, <code>vec::const_iterator</code>
and <code>rowvec::const_iterator</code> are random access iterators, for
read-only access to elements (which are stored column by column)</li>
<li>
<code>mat::col_iterator</code>, <code>vec::col_iterator</code> and
<code>rowvec::col_iterator</code> random access iterators, for
read/write access to the elements of specified columns.</li>
<li>
<code>mat::const_col_iterator</code>,
<code>vec::const_col_iterator</code> and
<code>rowvec::const_col_iterator</code> are random access iterators, for
read-only access to the elements of specified columns.</li>
<li>
<code>mat::row_iterator</code> is a bidirectional iterator, for
read/write access to the elements of specified rows.</li>
<li>
<code>mat::const_row_iterator</code> is a bidirectional iterator,
for read-only access to the elements of specified rows.</li>
<li>
<code>vec::row_iterator</code> and <code>rowvec::row_iterator</code>
are random access iterators, for read/write access to the elements of
specified rows.</li>
<li>
<code>vec::const_row_iterator</code> and
<code>rowvec::const_row_iterator</code> are random access iterators, for
read-only access to the elements of specified rows.</li>
</ul>
<p>Cubes (<code>Cube</code>):</p>
<ul>
<li>
<code>cube::iterator</code> is a random access iterator, for
read/write access to elements. The elements are ordered slice by slice;
the elements within each slice are ordered column by column.</li>
<li>
<code>cube::const_iterator</code> is a random access iterator, for
read-only access to elements.</li>
<li>
<code>cube::slice_iterator</code> is a random access iterator, for
read/write access to the elements of a particular slice. The elements
are ordered column by column.</li>
<li>
<code>cube::const_slice_iterator</code> is a random access iterator,
for read-only access to the elements of a particular slice.</li>
</ul>
<p>Sparse matrices (<code>SpMat</code>):</p>
<ul>
<li>
<code>sp_mat::iterator</code> is a bidirectional iterator, for
read/write access to elements (which are stored column by column).</li>
<li>
<code>sp_mat::const_iterator</code> is a bidirectional iterator, for
read-only access to elements (which are stored column by column).</li>
<li>
<code>sp_mat::col_iterator</code> is a bidirectional iterator, for
read/write access to the elements of a specific column.</li>
<li>
<code>sp_mat::const_col_iterator</code> is a bidirectional iterator,
for read-only access to the elements of a specific column.</li>
<li>
<code>sp_mat::row_iterator</code> is a bidirectional iterator, for
read/write access to the elements of a specific row.</li>
<li>
<code>sp_mat::const_row_iterator</code> is a bidirectional iterator,
for read-only access to the elements of a specific row.</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-43">Examples<a class="anchor" aria-label="anchor" href="#examples-43"></a>
</h3>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">iterators1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb63-3"><a href="#cb63-3" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" tabindex="-1"></a>  mat<span class="op">::</span>iterator it <span class="op">=</span> X<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb63-5"><a href="#cb63-5" tabindex="-1"></a>  mat<span class="op">::</span>iterator it_end <span class="op">=</span> X<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb63-6"><a href="#cb63-6" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;</span> it <span class="op">!=</span> it_end<span class="op">;</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-8"><a href="#cb63-8" tabindex="-1"></a>    <span class="op">(*</span>it<span class="op">)</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb63-9"><a href="#cb63-9" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb63-10"><a href="#cb63-10" tabindex="-1"></a></span>
<span id="cb63-11"><a href="#cb63-11" tabindex="-1"></a>  mat<span class="op">::</span>col_iterator col_it <span class="op">=</span> X<span class="op">.</span>begin_col<span class="op">(</span><span class="dv">1</span><span class="op">);</span>    <span class="co">// start of column 1</span></span>
<span id="cb63-12"><a href="#cb63-12" tabindex="-1"></a>  mat<span class="op">::</span>col_iterator col_it_end <span class="op">=</span> X<span class="op">.</span>end_col<span class="op">(</span>n<span class="op">);</span>  <span class="co">//   end of column n</span></span>
<span id="cb63-13"><a href="#cb63-13" tabindex="-1"></a></span>
<span id="cb63-14"><a href="#cb63-14" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;</span> col_it <span class="op">!=</span> col_it_end<span class="op">;</span> <span class="op">++</span>col_it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-15"><a href="#cb63-15" tabindex="-1"></a>    <span class="op">(*</span>col_it<span class="op">)</span> <span class="op">=</span> <span class="fl">321.0</span><span class="op">;</span></span>
<span id="cb63-16"><a href="#cb63-16" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb63-17"><a href="#cb63-17" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>X<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb63-19"><a href="#cb63-19" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">iterators2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a>  cube X<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>  cube<span class="op">::</span>iterator it <span class="op">=</span> X<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb64-5"><a href="#cb64-5" tabindex="-1"></a>  cube<span class="op">::</span>iterator it_end <span class="op">=</span> X<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb64-6"><a href="#cb64-6" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;</span> it <span class="op">!=</span> it_end<span class="op">;</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-8"><a href="#cb64-8" tabindex="-1"></a>    <span class="op">(*</span>it<span class="op">)</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb64-9"><a href="#cb64-9" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb64-10"><a href="#cb64-10" tabindex="-1"></a></span>
<span id="cb64-11"><a href="#cb64-11" tabindex="-1"></a>  cube<span class="op">::</span>slice_iterator <span class="va">s_it</span> <span class="op">=</span> X<span class="op">.</span>begin_slice<span class="op">(</span><span class="dv">1</span><span class="op">);</span>    <span class="co">// start of slice 1</span></span>
<span id="cb64-12"><a href="#cb64-12" tabindex="-1"></a>  cube<span class="op">::</span>slice_iterator <span class="va">s_it_end</span> <span class="op">=</span> X<span class="op">.</span>end_slice<span class="op">(</span>n<span class="op">);</span>  <span class="co">// end of slice n</span></span>
<span id="cb64-13"><a href="#cb64-13" tabindex="-1"></a></span>
<span id="cb64-14"><a href="#cb64-14" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;</span> <span class="va">s_it</span> <span class="op">!=</span> <span class="va">s_it_end</span><span class="op">;</span> <span class="op">++</span><span class="va">s_it</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-15"><a href="#cb64-15" tabindex="-1"></a>    <span class="op">(*</span><span class="va">s_it</span><span class="op">)</span> <span class="op">=</span> <span class="fl">321.0</span><span class="op">;</span></span>
<span id="cb64-16"><a href="#cb64-16" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb64-17"><a href="#cb64-17" tabindex="-1"></a></span>
<span id="cb64-18"><a href="#cb64-18" tabindex="-1"></a>  mat res <span class="op">=</span> sum<span class="op">(</span>X<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb64-19"><a href="#cb64-19" tabindex="-1"></a></span>
<span id="cb64-20"><a href="#cb64-20" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb64-21"><a href="#cb64-21" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">iterators3_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a>  sp_mat X <span class="op">=</span> sprandu<span class="op">&lt;</span>sp_mat<span class="op">&gt;(</span>n<span class="op">,</span> n <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" tabindex="-1"></a>  sp_mat<span class="op">::</span>iterator it <span class="op">=</span> X<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb65-5"><a href="#cb65-5" tabindex="-1"></a>  sp_mat<span class="op">::</span>iterator it_end <span class="op">=</span> X<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb65-6"><a href="#cb65-6" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;</span> it <span class="op">!=</span> it_end<span class="op">;</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-8"><a href="#cb65-8" tabindex="-1"></a>    <span class="op">(*</span>it<span class="op">)</span> <span class="op">+=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb65-9"><a href="#cb65-9" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb65-10"><a href="#cb65-10" tabindex="-1"></a></span>
<span id="cb65-11"><a href="#cb65-11" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>X<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb65-12"><a href="#cb65-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">iterators4_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">double</span><span class="op">&amp;</span> val <span class="op">:</span> X<span class="op">(</span>span<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">),</span> span<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">)))</span> <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a>    val <span class="op">=</span> <span class="fl">123.0</span><span class="op">;</span></span>
<span id="cb66-6"><a href="#cb66-6" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb66-7"><a href="#cb66-7" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>X<span class="op">);</span>  <span class="co">// Convert from C++ to R</span></span>
<span id="cb66-9"><a href="#cb66-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-6">Caveats<a class="anchor" aria-label="anchor" href="#caveats-6"></a>
</h3>
<ul>
<li>Writing a zero value into a sparse matrix through an iterator will
invalidate all current iterators associated with the sparse matrix.</li>
<li>To modify the non-zero elements in a safer manner, use
<code>.transform()</code> or <code>.for_each()</code> instead of
iterators.</li>
<li>For <code>submatrix</code> and <code>subcube</code> the iterators
are intended only to be used with range-based for loops. Any other use
is not supported. For example, the direct use of the
<code>.begin()</code> and <code>.end()</code> functions, as well as the
underlying iterators types is not supported. The implementation of
submatrices and subcubes uses short-lived temporary objects that are
subject to automatic deletion, and as such are error-prone to handle
manually.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="compatibility-container-functions">Compatibility container functions<a class="anchor" aria-label="anchor" href="#compatibility-container-functions"></a>
</h2>
<p>Member functions for the <code>Col</code> and <code>Row</code>
classes to mimic the functionality of containers in the C++ standard
library:</p>
<ul>
<li>
<code>.front()</code> accesses the first element in a vector.</li>
<li>
<code>.back()</code> accesses the last element in a vector.</li>
</ul>
<p>Member functions for the <code>Col</code>, <code>Row</code>,
<code>Mat</code>, <code>Cube</code> and <code>SpMat</code> classes to
mimic the functionality of containers in the C++ standard library:</p>
<ul>
<li>
<code>.clear()</code> removes the elements from an object.</li>
<li>
<code>.empty()</code> returns <code>true</code> if the object has no
elements and <code>false</code> if the object has one or more
elements.<br>
</li>
<li>
<code>.size()</code> returns the total number of elements in an
object.</li>
</ul>
<div class="section level3">
<h3 id="examples-44">Examples<a class="anchor" aria-label="anchor" href="#examples-44"></a>
</h3>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">compatibility1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a>  vec X<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" tabindex="-1"></a>  writable<span class="op">::</span>doubles res <span class="op">=</span> <span class="op">{</span>X<span class="op">.</span>front<span class="op">(),</span> X<span class="op">.</span>back<span class="op">()};</span></span>
<span id="cb67-5"><a href="#cb67-5" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"front"</span><span class="op">,</span> <span class="st">"back"</span><span class="op">});</span></span>
<span id="cb67-7"><a href="#cb67-7" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb67-9"><a href="#cb67-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">compatibility2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a>  writable<span class="op">::</span>integers res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> X<span class="op">.</span>n_rows<span class="op">;</span></span>
<span id="cb68-6"><a href="#cb68-6" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" tabindex="-1"></a>  X<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb68-8"><a href="#cb68-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> X<span class="op">.</span>n_rows<span class="op">;</span></span>
<span id="cb68-9"><a href="#cb68-9" tabindex="-1"></a></span>
<span id="cb68-10"><a href="#cb68-10" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"before"</span><span class="op">,</span> <span class="st">"after"</span><span class="op">});</span></span>
<span id="cb68-11"><a href="#cb68-11" tabindex="-1"></a></span>
<span id="cb68-12"><a href="#cb68-12" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb68-13"><a href="#cb68-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-matrix-to-column">Convert matrix to column<a class="anchor" aria-label="anchor" href="#convert-matrix-to-column"></a>
</h2>
<p><code>.as_col()</code> is a member function of the <code>Mat</code>
class, it returns a flattened version of the matrix as a column vector.
Flattening is done by concatenating all columns.</p>
<div class="section level3">
<h3 id="examples-45">Examples<a class="anchor" aria-label="anchor" href="#examples-45"></a>
</h3>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">as_col1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>  mat M<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>  vec V <span class="op">=</span> M<span class="op">.</span>as_col<span class="op">();</span></span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>V<span class="op">);</span></span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-matrix-to-row">Convert matrix to row<a class="anchor" aria-label="anchor" href="#convert-matrix-to-row"></a>
</h2>
<p><code>.as_row()</code> is a member function of the <code>Mat</code>
class, it returns a flattened version of the matrix as a row vector.
Flattening is done by concatenating all rows.</p>
<div class="section level3">
<h3 id="examples-46">Examples<a class="anchor" aria-label="anchor" href="#examples-46"></a>
</h3>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">as_row1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb70-2"><a href="#cb70-2" tabindex="-1"></a>  mat M<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb70-3"><a href="#cb70-3" tabindex="-1"></a>  vec V <span class="op">=</span> M<span class="op">.</span>as_row<span class="op">();</span></span>
<span id="cb70-4"><a href="#cb70-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>V<span class="op">);</span></span>
<span id="cb70-5"><a href="#cb70-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-6">Caveat<a class="anchor" aria-label="anchor" href="#caveat-6"></a>
</h3>
<p>Converting columns to rows is faster than converting rows to
columns.</p>
</div>
</div>
<div class="section level2">
<h2 id="convert-column-to-matrix">Convert column to matrix<a class="anchor" aria-label="anchor" href="#convert-column-to-matrix"></a>
</h2>
<p><code>.col_as_mat(col_number)</code> is a member function of the
<code>Cube</code> class, it returns a matrix of the specified cube
column and the number of rows is preserved. Given a cube of size
<code>R x C x S</code>, the resultant matrix size is
<code>R x S</code>.</p>
<div class="section level3">
<h3 id="examples-47">Examples<a class="anchor" aria-label="anchor" href="#examples-47"></a>
</h3>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">col_as_mat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2" tabindex="-1"></a>  cube C<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb71-3"><a href="#cb71-3" tabindex="-1"></a>  mat M <span class="op">=</span> C<span class="op">.</span>col_as_mat<span class="op">(</span><span class="dv">0</span><span class="op">);</span>  <span class="co">// size n x (n + 1)</span></span>
<span id="cb71-4"><a href="#cb71-4" tabindex="-1"></a>  </span>
<span id="cb71-5"><a href="#cb71-5" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb71-6"><a href="#cb71-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb71-7"><a href="#cb71-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb71-8"><a href="#cb71-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">2</span><span class="op">));</span></span>
<span id="cb71-9"><a href="#cb71-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">3</span><span class="op">));</span></span>
<span id="cb71-10"><a href="#cb71-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>M<span class="op">);</span></span>
<span id="cb71-11"><a href="#cb71-11" tabindex="-1"></a></span>
<span id="cb71-12"><a href="#cb71-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"slice0"</span><span class="op">,</span> <span class="st">"slice1"</span><span class="op">,</span> <span class="st">"slice2"</span><span class="op">,</span> <span class="st">"slice3"</span><span class="op">,</span></span>
<span id="cb71-13"><a href="#cb71-13" tabindex="-1"></a>    <span class="st">"col_as_mat"</span><span class="op">});</span></span>
<span id="cb71-14"><a href="#cb71-14" tabindex="-1"></a></span>
<span id="cb71-15"><a href="#cb71-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb71-16"><a href="#cb71-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-column-to-matrix-1">Convert column to matrix<a class="anchor" aria-label="anchor" href="#convert-column-to-matrix-1"></a>
</h2>
<p><code>.row_as_mat(row_number)</code> is a member function of the
<code>Cube</code> class, it returns a matrix of the specified cube row
and the number of columns is preserved. Given a cube of size
<code>R x C x S</code>, the resultant matrix size is
<code>S x C</code>.</p>
<div class="section level3">
<h3 id="examples-48">Examples<a class="anchor" aria-label="anchor" href="#examples-48"></a>
</h3>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">row_as_mat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a>  cube C<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb72-3"><a href="#cb72-3" tabindex="-1"></a>  mat M <span class="op">=</span> C<span class="op">.</span>row_as_mat<span class="op">(</span><span class="dv">0</span><span class="op">);</span>  <span class="co">// size (n + 2) x (n + 1)</span></span>
<span id="cb72-4"><a href="#cb72-4" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb72-6"><a href="#cb72-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb72-7"><a href="#cb72-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb72-8"><a href="#cb72-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">2</span><span class="op">));</span></span>
<span id="cb72-9"><a href="#cb72-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">.</span>slice<span class="op">(</span><span class="dv">3</span><span class="op">));</span></span>
<span id="cb72-10"><a href="#cb72-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>M<span class="op">);</span></span>
<span id="cb72-11"><a href="#cb72-11" tabindex="-1"></a></span>
<span id="cb72-12"><a href="#cb72-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"slice0"</span><span class="op">,</span> <span class="st">"slice1"</span><span class="op">,</span> <span class="st">"slice2"</span><span class="op">,</span> <span class="st">"slice3"</span><span class="op">,</span></span>
<span id="cb72-13"><a href="#cb72-13" tabindex="-1"></a>    <span class="st">"row_as_mat"</span><span class="op">});</span></span>
<span id="cb72-14"><a href="#cb72-14" tabindex="-1"></a></span>
<span id="cb72-15"><a href="#cb72-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb72-16"><a href="#cb72-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-sparse-matrix-to-dense-matrix">Convert sparse matrix to dense matrix<a class="anchor" aria-label="anchor" href="#convert-sparse-matrix-to-dense-matrix"></a>
</h2>
<p><code>.as_dense()</code> is a member function of the
<code>SpMat</code> class, it avoids the construction of an intermediate
sparse matrix representation of the expression.</p>
<div class="section level3">
<h3 id="examples-49">Examples<a class="anchor" aria-label="anchor" href="#examples-49"></a>
</h3>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">as_dense1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a>  sp_mat A<span class="op">;</span></span>
<span id="cb73-3"><a href="#cb73-3" tabindex="-1"></a>  A<span class="op">.</span>sprandu<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb73-4"><a href="#cb73-4" tabindex="-1"></a></span>
<span id="cb73-5"><a href="#cb73-5" tabindex="-1"></a>  <span class="co">// extract column 1 of A directly into dense column vector</span></span>
<span id="cb73-6"><a href="#cb73-6" tabindex="-1"></a>  colvec c <span class="op">=</span> A<span class="op">.</span>col<span class="op">(</span><span class="dv">0</span><span class="op">).</span>as_dense<span class="op">();</span></span>
<span id="cb73-7"><a href="#cb73-7" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" tabindex="-1"></a>  <span class="co">// store the sum of each column of A directly in dense row vector</span></span>
<span id="cb73-9"><a href="#cb73-9" tabindex="-1"></a>  rowvec r <span class="op">=</span> sum<span class="op">(</span>A<span class="op">).</span>as_dense<span class="op">();</span></span>
<span id="cb73-10"><a href="#cb73-10" tabindex="-1"></a></span>
<span id="cb73-11"><a href="#cb73-11" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>c <span class="op">+</span> r<span class="op">.</span>t<span class="op">());</span></span>
<span id="cb73-12"><a href="#cb73-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="dense-matrix-and-vector-transposition">Dense matrix and vector transposition<a class="anchor" aria-label="anchor" href="#dense-matrix-and-vector-transposition"></a>
</h2>
<p><code>.t()</code> is a member function of the <code>Mat</code>,
<code>Col</code> and <code>Row</code> classes, it returns a transposed
copy of the object. For real matrices, the transpose is a simple
transposition of the elements. For complex matrices, the transpose is a
Hermitian conjugate transposition of the elements (e.g., the signs of
the imaginary components are flipped).</p>
<div class="section level3">
<h3 id="examples-50">Examples<a class="anchor" aria-label="anchor" href="#examples-50"></a>
</h3>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">transpose1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb74-3"><a href="#cb74-3" tabindex="-1"></a>  mat B <span class="op">=</span> A<span class="op">.</span>t<span class="op">();</span></span>
<span id="cb74-4"><a href="#cb74-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb74-5"><a href="#cb74-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sparse-matrix-transposition">Sparse matrix transposition<a class="anchor" aria-label="anchor" href="#sparse-matrix-transposition"></a>
</h2>
<p><code>.st()</code> is a member function of the <code>SpMat</code>
classe, it returns a transposed copy of the object. For real matrices,
it is not applicable. For complex matrices, the transpose is a simple
transposition of the elements (e.g., the signs of imaginary components
are not flipped).</p>
<div class="section level3">
<h3 id="examples-51">Examples<a class="anchor" aria-label="anchor" href="#examples-51"></a>
</h3>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">transpose2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" tabindex="-1"></a>  sp_mat A<span class="op">;</span></span>
<span id="cb75-3"><a href="#cb75-3" tabindex="-1"></a>  A<span class="op">.</span>sprandu<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb75-4"><a href="#cb75-4" tabindex="-1"></a>  sp_mat B <span class="op">=</span> A<span class="op">.</span>t<span class="op">();</span></span>
<span id="cb75-5"><a href="#cb75-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb75-6"><a href="#cb75-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="matrix-inversion">Matrix inversion<a class="anchor" aria-label="anchor" href="#matrix-inversion"></a>
</h2>
<p><code>.i()</code> is a member function of the <code>Mat</code> class,
it provides an inverse of the matrix. If the matrix is not square sized,
a <code>std::logic_error</code> exception is thrown. If the matrix
appears to be singular, the output matrix is reset and a
<code>std::runtime_error</code> exception is thrown.</p>
<div class="section level3">
<h3 id="examples-52">Examples<a class="anchor" aria-label="anchor" href="#examples-52"></a>
</h3>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">inverse1_</span><span class="op">(</span><span class="at">const</span> doubles_matrix<span class="op">&lt;&gt;&amp;</span> a<span class="op">,</span></span>
<span id="cb76-2"><a href="#cb76-2" tabindex="-1"></a>                                      <span class="at">const</span> doubles b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb76-3"><a href="#cb76-3" tabindex="-1"></a>  mat A <span class="op">=</span> as_Mat<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb76-4"><a href="#cb76-4" tabindex="-1"></a>  vec B <span class="op">=</span> as_Col<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb76-5"><a href="#cb76-5" tabindex="-1"></a></span>
<span id="cb76-6"><a href="#cb76-6" tabindex="-1"></a>  mat X <span class="op">=</span> inv<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb76-7"><a href="#cb76-7" tabindex="-1"></a>  vec Y <span class="op">=</span> X <span class="op">*</span> B<span class="op">;</span></span>
<span id="cb76-8"><a href="#cb76-8" tabindex="-1"></a></span>
<span id="cb76-9"><a href="#cb76-9" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>Y<span class="op">);</span></span>
<span id="cb76-10"><a href="#cb76-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-7">Caveats<a class="anchor" aria-label="anchor" href="#caveats-7"></a>
</h3>
<ul>
<li>If the matrix is known to be symmetric positive definite,
<code>inv_sympd()</code>.</li>
<li>To solve a system of linear equations, such as
<code>Z = inv(X) * Y</code>, <code><a href="https://rdrr.io/r/base/solve.html" class="external-link">solve()</a></code> can be faster and/or
more accurate.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="maximum-and-minimum">Maximum and minimum<a class="anchor" aria-label="anchor" href="#maximum-and-minimum"></a>
</h2>
<p><code>.min()</code> and <code>.max()</code> are member functions of
the <code>Mat</code>, <code>Col</code>, <code>Row</code>, and
<code>Cube</code> classes. These return the minimum and maximum values
of the object, respectively. For objects with complex numbers, absolute
values are used for comparison.</p>
<div class="section level3">
<h3 id="examples-53">Examples<a class="anchor" aria-label="anchor" href="#examples-53"></a>
</h3>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">maxmin1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a>  mat A <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb77-3"><a href="#cb77-3" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" tabindex="-1"></a>  writable<span class="op">::</span>doubles res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb77-5"><a href="#cb77-5" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>max<span class="op">();</span></span>
<span id="cb77-6"><a href="#cb77-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>min<span class="op">();</span></span>
<span id="cb77-7"><a href="#cb77-7" tabindex="-1"></a></span>
<span id="cb77-8"><a href="#cb77-8" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"max"</span><span class="op">,</span> <span class="st">"min"</span><span class="op">});</span></span>
<span id="cb77-9"><a href="#cb77-9" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb77-11"><a href="#cb77-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="linear-index-of-maximum-and-minimum">Linear index of maximum and minimum<a class="anchor" aria-label="anchor" href="#linear-index-of-maximum-and-minimum"></a>
</h2>
<p><code>.index_min()</code> and <code>.index_max()</code> are member
functions of the <code>Mat</code>, <code>Col</code>, <code>Row</code>,
and <code>Cube</code> classes. They return the linear index of the
minimum and maximum values of the object, respectively. For objects with
complex numbers, absolute values are used for comparison. The returned
index is of type <code>uword</code>.</p>
<div class="section level3">
<h3 id="examples-54">Examples<a class="anchor" aria-label="anchor" href="#examples-54"></a>
</h3>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">index_maxmin1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb78-2"><a href="#cb78-2" tabindex="-1"></a>  mat A <span class="op">=</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb78-3"><a href="#cb78-3" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" tabindex="-1"></a>  writable<span class="op">::</span>doubles res<span class="op">(</span><span class="dv">6</span><span class="op">);</span></span>
<span id="cb78-5"><a href="#cb78-5" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>A<span class="op">.</span>index_max<span class="op">());</span></span>
<span id="cb78-6"><a href="#cb78-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>A<span class="op">.</span>index_min<span class="op">());</span></span>
<span id="cb78-7"><a href="#cb78-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb78-8"><a href="#cb78-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb78-9"><a href="#cb78-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb78-10"><a href="#cb78-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb78-11"><a href="#cb78-11" tabindex="-1"></a></span>
<span id="cb78-12"><a href="#cb78-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"index_max"</span><span class="op">,</span> <span class="st">"index_min"</span><span class="op">,</span> <span class="st">"element0"</span><span class="op">,</span> <span class="st">"element1"</span><span class="op">,</span></span>
<span id="cb78-13"><a href="#cb78-13" tabindex="-1"></a>    <span class="st">"element2"</span><span class="op">,</span> <span class="st">"element3"</span><span class="op">});</span></span>
<span id="cb78-14"><a href="#cb78-14" tabindex="-1"></a></span>
<span id="cb78-15"><a href="#cb78-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb78-16"><a href="#cb78-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="in-range">In-range<a class="anchor" aria-label="anchor" href="#in-range"></a>
</h2>
<p><code>.in_range(** i **)</code> is a member function of
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>SpMat</code> and <code>field</code>, it returns <code>true</code>
if the given location or span is currently valid and <code>false</code>
if the object is empty, the location is out of bounds, or the span is
out of bounds.</p>
<table class="table">
<colgroup>
<col width="73%">
<col width="3%">
<col width="3%">
<col width="3%">
<col width="4%">
<col width="5%">
<col width="5%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
<th>SpMat</th>
<th>Field</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.in_range(span(start, end))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.in_range(row, col)</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(span(start_row, end_row), span(start_col, end_col))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.in_range(row, col, slice)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(span(start_row, end_row), span(start_col, end_col), span(start_slice, end_slice))</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr class="even">
<td>
<code>.in_range(first_row, first_col, size(X))</code>
(<code>X</code> is a matrix or field)</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(first_row, first_col, size(n_rows, n_cols))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td>
<code>.in_range(first_row, first_col, first_slice, size(Q))</code>
(<code>Q</code> is a cube or field)</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Instances of <code>span(a,b)</code> can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code> to indicate the entire
range.</li>
<li>
<code>span(a)</code> to indicate a particular row, column, or
slice.</li>
</ul>
<div class="section level3">
<h3 id="examples-55">Examples<a class="anchor" aria-label="anchor" href="#examples-55"></a>
</h3>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">in_range1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-2"><a href="#cb79-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb79-3"><a href="#cb79-3" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb79-5"><a href="#cb79-5" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>in_range<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb79-6"><a href="#cb79-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>in_range<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb79-7"><a href="#cb79-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>in_range<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb79-8"><a href="#cb79-8" tabindex="-1"></a></span>
<span id="cb79-9"><a href="#cb79-9" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"in_range00"</span><span class="op">,</span> <span class="st">"in_range34"</span><span class="op">,</span> <span class="st">"in_range45"</span><span class="op">});</span></span>
<span id="cb79-10"><a href="#cb79-10" tabindex="-1"></a></span>
<span id="cb79-11"><a href="#cb79-11" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb79-12"><a href="#cb79-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-empty">Is empty<a class="anchor" aria-label="anchor" href="#is-empty"></a>
</h2>
<p><code>.is_empty()</code> is a member function of the
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
<code>SpMat</code>, and <code>field</code> classes. It returns
<code>true</code> if the object has no elements and <code>false</code>
if the object has one or more elements.</p>
<div class="section level3">
<h3 id="examples-56">Examples<a class="anchor" aria-label="anchor" href="#examples-56"></a>
</h3>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_empty1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a></span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_empty<span class="op">();</span></span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a></span>
<span id="cb80-7"><a href="#cb80-7" tabindex="-1"></a>  A<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb80-8"><a href="#cb80-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_empty<span class="op">();</span></span>
<span id="cb80-9"><a href="#cb80-9" tabindex="-1"></a></span>
<span id="cb80-10"><a href="#cb80-10" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"before_reset"</span><span class="op">,</span> <span class="st">"after_reset"</span><span class="op">});</span></span>
<span id="cb80-11"><a href="#cb80-11" tabindex="-1"></a></span>
<span id="cb80-12"><a href="#cb80-12" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb80-13"><a href="#cb80-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-vectorcolumn-vectorrow-vector">Is vector/column vector/row vector<a class="anchor" aria-label="anchor" href="#is-vectorcolumn-vectorrow-vector"></a>
</h2>
<p><code>.is_vec()</code>, <code>.is_colvec()</code> and
<code>.is_rowvec()</code> are member functions of <code>Mat</code> and
<code>SpMat</code>.</p>
<ul>
<li>
<code>.is_vec()</code> returns <code>true</code> if the matrix can
be interpreted as a vector (either column or row vector) and
<code>false</code> otherwise.</li>
<li>
<code>.is_colvec()</code> returns <code>true</code> if the matrix
can be interpreted as a column vector and <code>false</code>
otherwise.<br>
</li>
<li>
<code>.is_rowvec()</code> returns <code>true</code> if the matrix
can be interpreted as a row vector and <code>false</code>
otherwise.</li>
</ul>
<div class="section level3">
<h3 id="examples-57">Examples<a class="anchor" aria-label="anchor" href="#examples-57"></a>
</h3>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_vec1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb81-2"><a href="#cb81-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb81-3"><a href="#cb81-3" tabindex="-1"></a>  mat B<span class="op">(</span><span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb81-4"><a href="#cb81-4" tabindex="-1"></a>  mat C<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb81-5"><a href="#cb81-5" tabindex="-1"></a>  mat D<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb81-6"><a href="#cb81-6" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb81-8"><a href="#cb81-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_vec<span class="op">();</span></span>
<span id="cb81-9"><a href="#cb81-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_colvec<span class="op">();</span></span>
<span id="cb81-10"><a href="#cb81-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_rowvec<span class="op">();</span></span>
<span id="cb81-11"><a href="#cb81-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> C<span class="op">.</span>is_colvec<span class="op">();</span></span>
<span id="cb81-12"><a href="#cb81-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> D<span class="op">.</span>is_rowvec<span class="op">();</span></span>
<span id="cb81-13"><a href="#cb81-13" tabindex="-1"></a></span>
<span id="cb81-14"><a href="#cb81-14" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"Nx1_is_vec"</span><span class="op">,</span> <span class="st">"Nx1_is_colvec"</span><span class="op">,</span> <span class="st">"1xN_is_rowvec"</span><span class="op">,</span></span>
<span id="cb81-15"><a href="#cb81-15" tabindex="-1"></a>    <span class="st">"0x1_is_colvec"</span><span class="op">,</span> <span class="st">"1x0_is_rowvec"</span><span class="op">});</span></span>
<span id="cb81-16"><a href="#cb81-16" tabindex="-1"></a></span>
<span id="cb81-17"><a href="#cb81-17" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb81-18"><a href="#cb81-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-7">Caveat<a class="anchor" aria-label="anchor" href="#caveat-7"></a>
</h3>
<p>Do not assume that the vector has elements if these functions return
<code>true</code>. It is possible to have an empty vector (e.g., 0x1 as
in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-sorted">Is sorted<a class="anchor" aria-label="anchor" href="#is-sorted"></a>
</h2>
<p><code>.is_sorted()</code>, <code>.is_sorted(sort_direction)</code>
and <code>.is_sorted(sort_direction, dim)</code> are member function of
<code>Mat</code>, <code>Row</code>, and <code>Col</code>. For matrices
and vectors with complex numbers, order is checked via absolute
values.</p>
<p>If the object is a vector, these return a <code>bool</code>
indicating whether the elements are sorted. If the object is a matrix,
these return a <code>bool</code> indicating whether the elements are
sorted in each column (<code>dim = 0</code>, default) or each row
(<code>dim = 1</code>), and the <code>dim</code> argument is
optional.</p>
<p>The <code>sort_direction</code> argument is optional,
<code>sort_direction</code> can be one of the following strings:</p>
<ul>
<li>
<code>"ascend"</code>: the elements are ascending, consecutive
elements can be equal, and this is the default operation.</li>
<li>
<code>"descend"</code>: the elements are descending, and consecutive
elements can be equal.</li>
<li>
<code>"strictascend"</code>: the elements are strictly ascending,
and consecutive elements cannot be equal.</li>
<li>
<code>"strictdescend"</code>: the elements are strictly descending,
and consecutive elements cannot be equal.</li>
</ul>
<div class="section level3">
<h3 id="examples-58">Examples<a class="anchor" aria-label="anchor" href="#examples-58"></a>
</h3>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_sorted1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>  vec a<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a>  vec b <span class="op">=</span> sort<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a>  mat A<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb82-7"><a href="#cb82-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> a<span class="op">.</span>is_sorted<span class="op">();</span></span>
<span id="cb82-8"><a href="#cb82-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> b<span class="op">.</span>is_sorted<span class="op">();</span></span>
<span id="cb82-9"><a href="#cb82-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_sorted<span class="op">(</span><span class="st">"descend"</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb82-10"><a href="#cb82-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_sorted<span class="op">(</span><span class="st">"ascend"</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb82-11"><a href="#cb82-11" tabindex="-1"></a></span>
<span id="cb82-12"><a href="#cb82-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"a_sorted"</span><span class="op">,</span> <span class="st">"b_sorted"</span><span class="op">,</span> <span class="st">"A_descend"</span><span class="op">,</span></span>
<span id="cb82-13"><a href="#cb82-13" tabindex="-1"></a>    <span class="st">"A_ascend"</span><span class="op">});</span></span>
<span id="cb82-14"><a href="#cb82-14" tabindex="-1"></a></span>
<span id="cb82-15"><a href="#cb82-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb82-16"><a href="#cb82-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-upper-triangularlower-triangular">Is upper triangular/lower triangular<a class="anchor" aria-label="anchor" href="#is-upper-triangularlower-triangular"></a>
</h2>
<p><code>.is_trimatu()</code> and <code>.is_trimatl()</code> are member
functions of <code>Mat</code> and <code>SpMat</code>.
<code>.is_trimatu()</code> returns <code>true</code> if the matrix is
upper triangular (e.g., the matrix is square sized and all elements
below the main diagonal are zero) and <code>false</code> otherwise.
<code>.is_trimatl()</code> returns <code>true</code> if the matrix is
lower triangular (e.g., the matrix is square sized and all elements
above the main diagonal are zero) and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-59">Examples<a class="anchor" aria-label="anchor" href="#examples-59"></a>
</h3>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_triangular1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a>  mat B <span class="op">=</span> trimatl<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb83-4"><a href="#cb83-4" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb83-6"><a href="#cb83-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_trimatu<span class="op">();</span></span>
<span id="cb83-7"><a href="#cb83-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_trimatl<span class="op">();</span></span>
<span id="cb83-8"><a href="#cb83-8" tabindex="-1"></a></span>
<span id="cb83-9"><a href="#cb83-9" tabindex="-1"></a>  B<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb83-10"><a href="#cb83-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_trimatu<span class="op">();</span></span>
<span id="cb83-11"><a href="#cb83-11" tabindex="-1"></a></span>
<span id="cb83-12"><a href="#cb83-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"is_trimatu"</span><span class="op">,</span> <span class="st">"is_trimatl"</span><span class="op">,</span></span>
<span id="cb83-13"><a href="#cb83-13" tabindex="-1"></a>    <span class="st">"is_trimatu_after_reset"</span><span class="op">});</span></span>
<span id="cb83-14"><a href="#cb83-14" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb83-16"><a href="#cb83-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-8">Caveat<a class="anchor" aria-label="anchor" href="#caveat-8"></a>
</h3>
<p>If these functions return <code>true</code>, do not assume that the
matrix contains non-zero elements on or above/below the main diagonal.
It is possible to have an empty matrix (e.g., 0x0 as in the
examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-diagonal">Is diagonal<a class="anchor" aria-label="anchor" href="#is-diagonal"></a>
</h2>
<p><code>is_diagmat()</code> is a member function of <code>Mat</code>
and <code>SpMat</code>. It returns <code>true</code> if the matrix is
diagonal (e.g., all elements outside of the main diagonal are zero). If
the matrix is not square sized, a <code>std::logic_error</code>
exception is thrown.</p>
<div class="section level3">
<h3 id="examples-60">Examples<a class="anchor" aria-label="anchor" href="#examples-60"></a>
</h3>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_diagonal1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb84-2"><a href="#cb84-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb84-3"><a href="#cb84-3" tabindex="-1"></a>  mat B <span class="op">=</span> diagmat<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb84-4"><a href="#cb84-4" tabindex="-1"></a></span>
<span id="cb84-5"><a href="#cb84-5" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb84-6"><a href="#cb84-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_diagmat<span class="op">();</span></span>
<span id="cb84-7"><a href="#cb84-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_diagmat<span class="op">();</span></span>
<span id="cb84-8"><a href="#cb84-8" tabindex="-1"></a></span>
<span id="cb84-9"><a href="#cb84-9" tabindex="-1"></a>  A<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb84-10"><a href="#cb84-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_diagmat<span class="op">();</span></span>
<span id="cb84-11"><a href="#cb84-11" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_diagmat"</span><span class="op">,</span> <span class="st">"B_diagmat"</span><span class="op">,</span></span>
<span id="cb84-13"><a href="#cb84-13" tabindex="-1"></a>    <span class="st">"A_diagmat_after_reset"</span><span class="op">});</span></span>
<span id="cb84-14"><a href="#cb84-14" tabindex="-1"></a></span>
<span id="cb84-15"><a href="#cb84-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb84-16"><a href="#cb84-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-9">Caveat<a class="anchor" aria-label="anchor" href="#caveat-9"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the
matrix contains non-zero elements on the main diagonal only. It is
possible to have an empty matrix (e.g., 0x0 as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-square">Is square<a class="anchor" aria-label="anchor" href="#is-square"></a>
</h2>
<p><code>.is_square()</code> is a member function of the
<code>Mat</code> and <code>SpMat</code> classes. It returns
<code>true</code> if the matrix is square sized (e.g., the number of
rows is equal to the number of columns) and <code>false</code>
otherwise.</p>
<div class="section level3">
<h3 id="examples-61">Examples<a class="anchor" aria-label="anchor" href="#examples-61"></a>
</h3>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_square1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-2"><a href="#cb85-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb85-3"><a href="#cb85-3" tabindex="-1"></a>  mat B <span class="op">=</span> diagmat<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb85-4"><a href="#cb85-4" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb85-6"><a href="#cb85-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_square<span class="op">();</span></span>
<span id="cb85-7"><a href="#cb85-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_square<span class="op">();</span></span>
<span id="cb85-8"><a href="#cb85-8" tabindex="-1"></a></span>
<span id="cb85-9"><a href="#cb85-9" tabindex="-1"></a>  A<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb85-10"><a href="#cb85-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_square<span class="op">();</span></span>
<span id="cb85-11"><a href="#cb85-11" tabindex="-1"></a></span>
<span id="cb85-12"><a href="#cb85-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_square"</span><span class="op">,</span> <span class="st">"B_square"</span><span class="op">,</span></span>
<span id="cb85-13"><a href="#cb85-13" tabindex="-1"></a>    <span class="st">"A_square_after_reset"</span><span class="op">});</span></span>
<span id="cb85-14"><a href="#cb85-14" tabindex="-1"></a></span>
<span id="cb85-15"><a href="#cb85-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb85-16"><a href="#cb85-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-8">Caveats<a class="anchor" aria-label="anchor" href="#caveats-8"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the
matrix is non-empty. It is possible to have an empty matrix (e.g., 0x0
as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-symmetric">Is symmetric<a class="anchor" aria-label="anchor" href="#is-symmetric"></a>
</h2>
<p><code>.is_symmetric()</code> is a member function of the
<code>Mat</code> and <code>SpMat</code> classes. It returns
<code>true</code> if the matrix is symmetric (e.g., the matrix is square
sized and the transpose is equal to the original matrix) and
<code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-62">Examples<a class="anchor" aria-label="anchor" href="#examples-62"></a>
</h3>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_symmetric1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-2"><a href="#cb86-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb86-3"><a href="#cb86-3" tabindex="-1"></a>  mat B <span class="op">=</span> symmatu<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb86-4"><a href="#cb86-4" tabindex="-1"></a></span>
<span id="cb86-5"><a href="#cb86-5" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb86-6"><a href="#cb86-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_symmetric<span class="op">();</span></span>
<span id="cb86-7"><a href="#cb86-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_symmetric<span class="op">();</span></span>
<span id="cb86-8"><a href="#cb86-8" tabindex="-1"></a></span>
<span id="cb86-9"><a href="#cb86-9" tabindex="-1"></a>  A<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb86-10"><a href="#cb86-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_symmetric<span class="op">();</span></span>
<span id="cb86-11"><a href="#cb86-11" tabindex="-1"></a></span>
<span id="cb86-12"><a href="#cb86-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_symmetric"</span><span class="op">,</span> <span class="st">"B_symmetric"</span><span class="op">,</span></span>
<span id="cb86-13"><a href="#cb86-13" tabindex="-1"></a>    <span class="st">"A_symmetric_after_reset"</span><span class="op">});</span></span>
<span id="cb86-14"><a href="#cb86-14" tabindex="-1"></a></span>
<span id="cb86-15"><a href="#cb86-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb86-16"><a href="#cb86-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-9">Caveats<a class="anchor" aria-label="anchor" href="#caveats-9"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the
matrix is non-empty. It is possible to have an empty matrix (e.g., 0x0
as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-hermitian">Is hermitian<a class="anchor" aria-label="anchor" href="#is-hermitian"></a>
</h2>
<p><code>.is_hermitian()</code> is a member function of the
<code>Mat</code> and <code>SpMat</code> classes. It returns
<code>true</code> if the matrix is Hermitian or self-adjoint (e.g., the
matrix is square sized and the conjugate transpose is equal to the
original matrix) and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-63">Examples<a class="anchor" aria-label="anchor" href="#examples-63"></a>
</h3>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_hermitian1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb87-2"><a href="#cb87-2" tabindex="-1"></a>  cx_mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb87-3"><a href="#cb87-3" tabindex="-1"></a>  cx_mat B <span class="op">=</span> A<span class="op">.</span>t<span class="op">()</span> <span class="op">*</span> A<span class="op">;</span></span>
<span id="cb87-4"><a href="#cb87-4" tabindex="-1"></a></span>
<span id="cb87-5"><a href="#cb87-5" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb87-6"><a href="#cb87-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_hermitian<span class="op">();</span></span>
<span id="cb87-7"><a href="#cb87-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_hermitian<span class="op">();</span></span>
<span id="cb87-8"><a href="#cb87-8" tabindex="-1"></a></span>
<span id="cb87-9"><a href="#cb87-9" tabindex="-1"></a>  A<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb87-10"><a href="#cb87-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_hermitian<span class="op">();</span></span>
<span id="cb87-11"><a href="#cb87-11" tabindex="-1"></a></span>
<span id="cb87-12"><a href="#cb87-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_hermitian"</span><span class="op">,</span> <span class="st">"B_hermitian"</span><span class="op">,</span></span>
<span id="cb87-13"><a href="#cb87-13" tabindex="-1"></a>    <span class="st">"A_hermitian_after_reset"</span><span class="op">});</span></span>
<span id="cb87-14"><a href="#cb87-14" tabindex="-1"></a></span>
<span id="cb87-15"><a href="#cb87-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb87-16"><a href="#cb87-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-10">Caveats<a class="anchor" aria-label="anchor" href="#caveats-10"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the
matrix is non-empty. It is possible to have an empty matrix (e.g., 0x0
as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-symmetrichermitian-positive-definite">Is symmetric/hermitian positive definite<a class="anchor" aria-label="anchor" href="#is-symmetrichermitian-positive-definite"></a>
</h2>
<p><code>.is_sympd()</code> and <code>.is_sympd(tol)</code> are a member
function of the <code>Mat</code> and <code>SpMat</code> classes. It
returns <code>true</code> if the matrix is symmetric/hermitian positive
definite within a tolerance (e.g., the matrix is square sized and all
its eigenvalues are positive) and <code>false</code> otherwise. The
<code>tol</code> argument is optional, the default is
<code>tol = 100 * datum::eps * norm(X, "fro")</code>.</p>
<div class="section level3">
<h3 id="examples-64">Examples<a class="anchor" aria-label="anchor" href="#examples-64"></a>
</h3>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_sympd1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb88-3"><a href="#cb88-3" tabindex="-1"></a>  mat B <span class="op">=</span> A <span class="op">*</span> A<span class="op">.</span>t<span class="op">();</span></span>
<span id="cb88-4"><a href="#cb88-4" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb88-6"><a href="#cb88-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_sympd<span class="op">();</span></span>
<span id="cb88-7"><a href="#cb88-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_sympd<span class="op">();</span></span>
<span id="cb88-8"><a href="#cb88-8" tabindex="-1"></a></span>
<span id="cb88-9"><a href="#cb88-9" tabindex="-1"></a>  A<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb88-10"><a href="#cb88-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_sympd<span class="op">();</span></span>
<span id="cb88-11"><a href="#cb88-11" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_sympd"</span><span class="op">,</span> <span class="st">"B_sympd"</span><span class="op">,</span></span>
<span id="cb88-13"><a href="#cb88-13" tabindex="-1"></a>    <span class="st">"A_sympd_after_reset"</span><span class="op">});</span></span>
<span id="cb88-14"><a href="#cb88-14" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb88-16"><a href="#cb88-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-zero">Is zero<a class="anchor" aria-label="anchor" href="#is-zero"></a>
</h2>
<p><code>.is_zero()</code> and <code>.is_zero(tol)</code> are a member
function of the <code>Mat</code>, <code>Col</code>, <code>Row</code>,
<code>Cube</code>, and <code>SpMat</code> classes. It returns
<code>true</code> if all elements are zero within a tolerance and
<code>false</code> otherwise. For complex numbers, each component (real
and imaginary) is checked separately. The <code>tol</code> argument is
optional.</p>
<div class="section level3">
<h3 id="examples-65">Examples<a class="anchor" aria-label="anchor" href="#examples-65"></a>
</h3>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_zero1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb89-2"><a href="#cb89-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb89-3"><a href="#cb89-3" tabindex="-1"></a>  cube B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb89-4"><a href="#cb89-4" tabindex="-1"></a>  sp_mat C<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb89-5"><a href="#cb89-5" tabindex="-1"></a></span>
<span id="cb89-6"><a href="#cb89-6" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb89-7"><a href="#cb89-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_zero<span class="op">(</span><span class="fl">0.005</span><span class="op">);</span></span>
<span id="cb89-8"><a href="#cb89-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_zero<span class="op">(</span><span class="fl">0.005</span><span class="op">);</span></span>
<span id="cb89-9"><a href="#cb89-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> C<span class="op">.</span>is_zero<span class="op">(</span><span class="fl">0.005</span><span class="op">);</span></span>
<span id="cb89-10"><a href="#cb89-10" tabindex="-1"></a></span>
<span id="cb89-11"><a href="#cb89-11" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_is_zero"</span><span class="op">,</span> <span class="st">"B_is_zero"</span><span class="op">,</span> <span class="st">"C_is_zero"</span><span class="op">});</span></span>
<span id="cb89-12"><a href="#cb89-12" tabindex="-1"></a></span>
<span id="cb89-13"><a href="#cb89-13" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb89-14"><a href="#cb89-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-finite">Is finite<a class="anchor" aria-label="anchor" href="#is-finite"></a>
</h2>
<p><code>.is_finite()</code> is a member function of the
<code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>,
and <code>SpMat</code> classes. It returns <code>true</code> if all
elements are finite and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-66">Examples<a class="anchor" aria-label="anchor" href="#examples-66"></a>
</h3>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">is_finite1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb90-2"><a href="#cb90-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb90-3"><a href="#cb90-3" tabindex="-1"></a>  cube B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb90-4"><a href="#cb90-4" tabindex="-1"></a>  sp_mat C<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb90-5"><a href="#cb90-5" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" tabindex="-1"></a>  <span class="co">// Insert infinite values</span></span>
<span id="cb90-7"><a href="#cb90-7" tabindex="-1"></a>  B<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> datum<span class="op">::</span>inf<span class="op">;</span></span>
<span id="cb90-8"><a href="#cb90-8" tabindex="-1"></a>  C<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span> datum<span class="op">::</span>inf<span class="op">;</span></span>
<span id="cb90-9"><a href="#cb90-9" tabindex="-1"></a></span>
<span id="cb90-10"><a href="#cb90-10" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb90-11"><a href="#cb90-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>is_finite<span class="op">();</span></span>
<span id="cb90-12"><a href="#cb90-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>is_finite<span class="op">();</span></span>
<span id="cb90-13"><a href="#cb90-13" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> C<span class="op">.</span>is_finite<span class="op">();</span></span>
<span id="cb90-14"><a href="#cb90-14" tabindex="-1"></a></span>
<span id="cb90-15"><a href="#cb90-15" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_is_finite"</span><span class="op">,</span> <span class="st">"B_is_finite"</span><span class="op">,</span> <span class="st">"C_is_finite"</span><span class="op">});</span></span>
<span id="cb90-16"><a href="#cb90-16" tabindex="-1"></a></span>
<span id="cb90-17"><a href="#cb90-17" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb90-18"><a href="#cb90-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="has-infinity">Has infinity<a class="anchor" aria-label="anchor" href="#has-infinity"></a>
</h2>
<p><code>.has_inf()</code> is a member function of the <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>Cube</code>, and
<code>SpMat</code> classes. It returns <code>true</code> if the object
contains at least one infinite value and <code>false</code>
otherwise.</p>
<div class="section level3">
<h3 id="examples-67">Examples<a class="anchor" aria-label="anchor" href="#examples-67"></a>
</h3>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">has_inf1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-2"><a href="#cb91-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb91-3"><a href="#cb91-3" tabindex="-1"></a>  cube B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb91-4"><a href="#cb91-4" tabindex="-1"></a>  sp_mat C<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb91-5"><a href="#cb91-5" tabindex="-1"></a></span>
<span id="cb91-6"><a href="#cb91-6" tabindex="-1"></a>  <span class="co">// Insert infinite values</span></span>
<span id="cb91-7"><a href="#cb91-7" tabindex="-1"></a>  B<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> datum<span class="op">::</span>inf<span class="op">;</span></span>
<span id="cb91-8"><a href="#cb91-8" tabindex="-1"></a>  C<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span> datum<span class="op">::</span>inf<span class="op">;</span></span>
<span id="cb91-9"><a href="#cb91-9" tabindex="-1"></a></span>
<span id="cb91-10"><a href="#cb91-10" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb91-11"><a href="#cb91-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>has_inf<span class="op">();</span></span>
<span id="cb91-12"><a href="#cb91-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>has_inf<span class="op">();</span></span>
<span id="cb91-13"><a href="#cb91-13" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> C<span class="op">.</span>has_inf<span class="op">();</span></span>
<span id="cb91-14"><a href="#cb91-14" tabindex="-1"></a></span>
<span id="cb91-15"><a href="#cb91-15" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_has_inf"</span><span class="op">,</span> <span class="st">"B_has_inf"</span><span class="op">,</span> <span class="st">"C_has_inf"</span><span class="op">});</span></span>
<span id="cb91-16"><a href="#cb91-16" tabindex="-1"></a></span>
<span id="cb91-17"><a href="#cb91-17" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb91-18"><a href="#cb91-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="has-not-a-number">Has not-a-number<a class="anchor" aria-label="anchor" href="#has-not-a-number"></a>
</h2>
<p><code>.has_nan()</code> is a member function of the <code>Mat</code>,
<code>Col</code>, <code>Row</code>, <code>Cube</code>, and
<code>SpMat</code> classes. It returns <code>true</code> if the object
contains at least one not-a-number (NaN) value and <code>false</code>
otherwise.</p>
<div class="section level3">
<h3 id="examples-68">Examples<a class="anchor" aria-label="anchor" href="#examples-68"></a>
</h3>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">has_nan1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb92-2"><a href="#cb92-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb92-3"><a href="#cb92-3" tabindex="-1"></a>  cube B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb92-4"><a href="#cb92-4" tabindex="-1"></a>  sp_mat C<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb92-5"><a href="#cb92-5" tabindex="-1"></a></span>
<span id="cb92-6"><a href="#cb92-6" tabindex="-1"></a>  <span class="co">// Insert NaN values</span></span>
<span id="cb92-7"><a href="#cb92-7" tabindex="-1"></a>  B<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> datum<span class="op">::</span>nan<span class="op">;</span></span>
<span id="cb92-8"><a href="#cb92-8" tabindex="-1"></a>  C<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span> datum<span class="op">::</span>nan<span class="op">;</span></span>
<span id="cb92-9"><a href="#cb92-9" tabindex="-1"></a></span>
<span id="cb92-10"><a href="#cb92-10" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb92-11"><a href="#cb92-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> A<span class="op">.</span>has_nan<span class="op">();</span></span>
<span id="cb92-12"><a href="#cb92-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> B<span class="op">.</span>has_nan<span class="op">();</span></span>
<span id="cb92-13"><a href="#cb92-13" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> C<span class="op">.</span>has_nan<span class="op">();</span></span>
<span id="cb92-14"><a href="#cb92-14" tabindex="-1"></a></span>
<span id="cb92-15"><a href="#cb92-15" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"A_has_nan"</span><span class="op">,</span> <span class="st">"B_has_nan"</span><span class="op">,</span> <span class="st">"C_has_nan"</span><span class="op">});</span></span>
<span id="cb92-16"><a href="#cb92-16" tabindex="-1"></a></span>
<span id="cb92-17"><a href="#cb92-17" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb92-18"><a href="#cb92-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-10">Caveat<a class="anchor" aria-label="anchor" href="#caveat-10"></a>
</h3>
<p><code>NaN</code> is not equal to anything, even itself.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Mauricio Vargas Sepulveda, Conrad Sanderson.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
