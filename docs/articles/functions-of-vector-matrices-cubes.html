<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Functions of vectors, matrices, and cubes • cpp11armadillo</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Functions of vectors, matrices, and cubes">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">cpp11armadillo</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/basic-usage.html">Basic 'cpp11armadillo' usage</a></li>
    <li><a class="dropdown-item" href="../articles/configuration.html">Armadillo configuration</a></li>
    <li><a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-dense.html">Decompositions, factorisations, inverses and equation solvers (dense matrices)</a></li>
    <li><a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-sparse.html">Decompositions, factorisations, inverses and equation solvers (sparse matrices)</a></li>
    <li><a class="dropdown-item" href="../articles/functions-of-vector-matrices-cubes.html">Functions of vectors, matrices, and cubes</a></li>
    <li><a class="dropdown-item" href="../articles/generated-vectors-matrices-cubes.html">Generated vectors, matrices, and cubes</a></li>
    <li><a class="dropdown-item" href="../articles/linear-model.html">Fitting regressions with Armadillo</a></li>
    <li><a class="dropdown-item" href="../articles/matrix-vector-cube-and-field-classes.html">Matrix, vector, cube and field classes</a></li>
    <li><a class="dropdown-item" href="../articles/member-functions-and-variables.html">Member functions and variables</a></li>
    <li><a class="dropdown-item" href="../articles/miscellaneous.html">Miscellaneous</a></li>
    <li><a class="dropdown-item" href="../articles/save-load.html">Saving and loading Armadillo objects on C++ side</a></li>
    <li><a class="dropdown-item" href="../articles/signal-and-image-processing.html">Signal and image processing</a></li>
    <li><a class="dropdown-item" href="../articles/sparse-matrices.html">Sparse matrices</a></li>
    <li><a class="dropdown-item" href="../articles/statistics-and-clustering.html">Statistics and clustering</a></li>
    <li><a class="dropdown-item" href="../articles/syntax-comparison-for-matlab-users.html">Syntax comparison for MATLAB/Octave users</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/pachadotdev/cpp11armadillo/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">



<script src="functions-of-vector-matrices-cubes_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Functions of vectors, matrices, and cubes</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/pachadotdev/cpp11armadillo/blob/HEAD/vignettes/functions-of-vector-matrices-cubes.Rmd"><code>vignettes/functions-of-vector-matrices-cubes.Rmd</code></a></small>
      <div class="d-none name"><code>functions-of-vector-matrices-cubes.Rmd</code></div>
    </div>

    
    
<p><strong>This vignette is adapted from the official Armadillo <a href="https://arma.sourceforge.net/docs.html" class="external-link">documentation</a>.</strong></p>
<div class="section level2">
<h2 id="abs">Absolute value<a class="anchor" aria-label="anchor" href="#abs"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs()</a></code> function computes the absolute value of each element in a vector, matrix, or cube.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>Y = abs(X); <span class="co">// for non-complex X</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="dt">real_object_type</span> Y = abs(X); <span class="co">// for complex X</span></span></code></pre></div>
<p>For the non-complex case, <code>X</code> and <code>Y</code> must have the same type, such as mat or cube.</p>
<p>For the complex case, <code>Y</code> must be the real counterpart to the type of <code>X</code>. If <code>X</code> has the type <code>cx_mat</code>, then the type of <code>Y</code> must be <code>mat</code>.</p>
<div class="section level3">
<h3 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">abs1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  mat B = abs(A);</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  cx_mat X(n, n, fill::randu);</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  mat Y = abs(X);</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  mat res = B + Y;</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="accu">Accumulate (sum) all elements<a class="anchor" aria-label="anchor" href="#accu"></a>
</h2>
<p>The <code>accu()</code> function computes the sum of all elements in a vector, matrix, or cube.</p>
<div class="section level3">
<h3 id="examples-1">Examples<a class="anchor" aria-label="anchor" href="#examples-1"></a>
</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] <span class="dt">double</span> <span class="va">accu1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  mat B(n, n, fill::randu);</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  <span class="dt">double</span> x = accu(A);</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>  <span class="co">// accu(A % B) is a "multiply-and-accumulate" operation</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>  <span class="co">// as operator % performs element-wise multiplication</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  <span class="dt">double</span> y = accu(A % B);</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>  <span class="cf">return</span> (x + y);</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="affmul">Affine matrix multiplication<a class="anchor" aria-label="anchor" href="#affmul"></a>
</h2>
<p>The <code>affmul()</code> function computes matrix multiplication for <code>A</code> and <code>B</code> with an extended form of <code>B</code>. <code>A</code> is typically an affine transformation matrix. <code>B</code> can be a vector or matrix, and is treated as having an additional row of ones.</p>
<p>The number of columns in <code>A</code> must be equal to number of rows in the extended form of <code>B</code> (e.g., <code>A.n_cols = B.n_rows + 1</code>).</p>
<p>If <code>A</code>has dimensions 3x3 and <code>B</code> 2x1, the equivalent matrix multiplication is:</p>
<pre><code>⎡ C0 ⎤   ⎡ A00 A01 A02 ⎤   ⎡ B0 ⎤
⎢ C1 ⎥ = ⎢ A10 A11 A12 ⎥ x ⎢ B1 ⎥
⎣ C2 ⎦   ⎣ A20 A21 A22 ⎦   ⎣ 1  ⎦</code></pre>
<p>If <code>A</code> has dimensions 2x3 and <code>B</code> 2x1, the equivalent matrix multiplication is:</p>
<pre><code>⎡ C0 ⎤   ⎡ A00 A01 A02 ⎤   ⎡ B0 ⎤
⎢ C1 ⎥ = ⎢ A10 A11 A12 ⎥ x ⎢ B1 ⎥
                           ⎣ 1  ⎦</code></pre>
<div class="section level3">
<h3 id="examples-2">Examples<a class="anchor" aria-label="anchor" href="#examples-2"></a>
</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">affmul1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  vec B(n, fill::randu);</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>  vec C = affmul(A, B);</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(C);</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="all">Check whether all elements are non-zero, or satisfy a relational condition<a class="anchor" aria-label="anchor" href="#all"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/all.html" class="external-link">all()</a></code> function checks whether all elements in a vector, matrix or cube are non-zero, or satisfy a relational condition. It returns true/false booleans for vectors and 0/1 vectors for matrices to indicate if the condition is met for each row or column.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>all(vector);</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>all(matrix);</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>all(matrix, dimension); <span class="co">// dimension = 0 -&gt; returns a row vector urowvec/umat</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>                        <span class="co">// dimension = 1 -&gt; returns a column vector ucolvec/umat</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-3">Examples<a class="anchor" aria-label="anchor" href="#examples-3"></a>
</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">all1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  vec V(n, fill::randu);</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  <span class="co">// true if vector V has all non-zero elements</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="dt">bool</span> status1 = all(V);</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  <span class="co">// true if vector V has all elements greater than 0.5</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>  <span class="dt">bool</span> status2 = all(V &gt; <span class="fl">0.5</span>);</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  <span class="co">// true if matrix X has all elements greater than 0.6;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  <span class="co">// note the use of vectorise()</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  <span class="dt">bool</span> status3 = all(vectorise(X) &gt; <span class="fl">0.6</span>);</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>  <span class="co">// row vector indicating which columns of X have all elements greater than 0.7</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>  umat A = all(X &gt; <span class="fl">0.7</span>);</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>  writable::logicals res(<span class="dv">4</span>);</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>  res[<span class="dv">0</span>] = status1;</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>  res[<span class="dv">1</span>] = status2;</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a>  res[<span class="dv">2</span>] = status3;</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>  res[<span class="dv">3</span>] = all(vectorise(A) == <span class="dv">1</span>);  <span class="co">// true if all elements of A are 1</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="any">Check whether any element is non-zero, or satisfies a relational condition<a class="anchor" aria-label="anchor" href="#any"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/any.html" class="external-link">any()</a></code> function checks whether any element in a vector, matrix or cube is non-zero, or satisfies a relational condition. It returns true/false booleans for vectors and 0/1 vectors for matrices to indicate if the condition is met for any row or column.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>any(vector);</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>any(matrix);</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>any(matrix, dimension); <span class="co">// dimension = 0 -&gt; returns a row vector urowvec/umat</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>                        <span class="co">// dimension = 1 -&gt; returns a column vector ucolvec/umat</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-4">Examples<a class="anchor" aria-label="anchor" href="#examples-4"></a>
</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">any1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  vec V(n, fill::randu);</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>  <span class="co">// true if vector V has any non-zero elements</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  <span class="dt">bool</span> status1 = any(V);</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  <span class="co">// true if vector V has any elements greater than 0.5</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>  <span class="dt">bool</span> status2 = any(V &gt; <span class="fl">0.5</span>);</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>  <span class="co">// true if matrix X has any elements greater than 0.6;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>  <span class="co">// note the use of vectorise()</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>  <span class="dt">bool</span> status3 = any(vectorise(X) &gt; <span class="fl">0.6</span>);</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>  <span class="co">// row vector indicating which columns of X have any elements greater than 0.7</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>  umat A = any(X &gt; <span class="fl">0.7</span>);</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>  writable::logicals res(<span class="dv">4</span>);</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>  res[<span class="dv">0</span>] = status1;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a>  res[<span class="dv">1</span>] = status2;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>  res[<span class="dv">2</span>] = status3;</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>  res[<span class="dv">3</span>] = any(vectorise(A) == <span class="dv">1</span>);  <span class="co">// true if any element of A is 1</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="approx_equal">Approximate equality<a class="anchor" aria-label="anchor" href="#approx_equal"></a>
</h2>
<p>The <code>approx_equal()</code> function checks whether two vectors, matrices or cubes are approximately equal. It returns true if all corresponding elements have differences less than or equal to a given tolerance.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>approx_equal(A, B, method, tol)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>approx_equal(A, B, method, abs_tol, rel_tol)</span></code></pre></div>
<p>The <code>method</code> parameter specifies the method used to compare the elements:</p>
<ul>
<li>
<code>method = "absdiff"</code>: absolute difference (e.g., <code>|A - B| &lt;= tol</code>)</li>
<li>
<code>method = "reldiff"</code>: relative difference (e.g., <code>|A - B| / max(|A|, |B|) &lt;= tol</code>)</li>
<li>
<code>method = "both"</code>: absolute or relative difference (e.g., <code>|A - B| &lt;= tol || |A - B| / max(|A|, |B|) &lt;= tol</code>)</li>
</ul>
<div class="section level3">
<h3 id="examples-5">Examples<a class="anchor" aria-label="anchor" href="#examples-5"></a>
</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] <span class="dt">bool</span> <span class="va">approx_equal1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  mat B = A + <span class="fl">0.001</span>;</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  <span class="dt">bool</span> same1 = approx_equal(A, B, <span class="st">"absdiff"</span>, <span class="fl">0.002</span>);</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  mat C = <span class="dv">1000</span> * randu&lt;mat&gt;(n, n);</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  mat D = C + <span class="dv">1</span>;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  <span class="dt">bool</span> same2 = approx_equal(C, D, <span class="st">"reldiff"</span>, <span class="fl">0.1</span>);</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>  <span class="dt">bool</span> same3 = approx_equal(C, D, <span class="st">"both"</span>, <span class="dv">2</span>, <span class="fl">0.1</span>);</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>  <span class="dt">bool</span> all_same = same1 &amp;&amp; same2 &amp;&amp; same3;</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>  <span class="cf">return</span> all_same;</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="arg">Phase angle of each element<a class="anchor" aria-label="anchor" href="#arg"></a>
</h2>
<p>The <code>arg()</code> function computes the phase angle of each element in a vector, matrix or cube. For non-complex elements, the input is treated as a complex element with zero imaginary component. For complex elements, the input must be of the same and the output the real counterpart type.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="dt">real_object_type</span> Y = arg(X);</span></code></pre></div>
<div class="section level3">
<h3 id="examples-6">Examples<a class="anchor" aria-label="anchor" href="#examples-6"></a>
</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">arg1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  cx_mat X(n, n, fill::randu);</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  mat Y = arg(X);</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(Y);</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="as_scalar">Convert 1x1 matrix to pure scalar<a class="anchor" aria-label="anchor" href="#as_scalar"></a>
</h2>
<p>The <code>as_scalar()</code> function converts a 1x1 matrix to a scalar (e.g., <code>double/int</code>). It is useful when you want to extract a single element from a matrix or an operation (e.g., converting the result of a dot/inner product to a scalar).</p>
<div class="section level3">
<h3 id="examples-7">Examples<a class="anchor" aria-label="anchor" href="#examples-7"></a>
</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] <span class="dt">double</span> <span class="va">as_scalar1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  rowvec r(n, fill::randu);</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  colvec q(n, fill::randu);</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="co">// examples of expressions which have optimised implementations</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>  <span class="dt">double</span> a = as_scalar(r*q);</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>  <span class="dt">double</span> b = as_scalar(r*X*q);</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>  <span class="dt">double</span> c = as_scalar(r*diagmat(X)*q);</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>  <span class="dt">double</span> d = as_scalar(r*inv(diagmat(X))*q);</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>  <span class="cf">return</span> (a + b + c + d);</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="clamp">Obtain clamped elements according to given limits<a class="anchor" aria-label="anchor" href="#clamp"></a>
</h2>
<p>The <code>clamp()</code> function clamps each element in a vector, matrix or cube to a given range. Any value less than the lower limit is set to the lower limit, and any value greater than the upper limit is set to the upper limit.</p>
<p>For objects with complex elements, the real and imaginary components are clamped separately.</p>
<p>If the input is a sparse matrix, only the non-zero elements are clamped.</p>
<div class="section level3">
<h3 id="example">Example<a class="anchor" aria-label="anchor" href="#example"></a>
</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">clamp1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  mat B = clamp(A, <span class="fl">0.2</span>, <span class="fl">0.8</span>);</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  mat C = clamp(A, A.min(), <span class="fl">0.8</span>);</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  mat D = clamp(A, <span class="fl">0.2</span>, A.max());</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>  mat res = B + C + D;</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cond">Condition number of matrix<a class="anchor" aria-label="anchor" href="#cond"></a>
</h2>
<p>The <code>cond()</code> function computes the condition number of a matrix. The condition number is the ratio of the largest singular value to the smallest singular value. It is a measure of how well the matrix can be inverted, a matrix with a value close to 1 is well-conditioned, and a matrix with a large value is ill-conditioned. The computation is based on the singular value decomposition.</p>
<div class="section level3">
<h3 id="examples-8">Examples<a class="anchor" aria-label="anchor" href="#examples-8"></a>
</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] <span class="dt">double</span> <span class="va">cond1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  mat A(n, n);</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  A.eye(); <span class="co">// the identity matrix has a condition number of 1</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  <span class="dt">double</span> cond_num = cond(A);</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  <span class="cf">return</span> cond_num;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat">Caveat<a class="anchor" aria-label="anchor" href="#caveat"></a>
</h3>
<p>Calculating the approximate reciprocal condition number via <code><a href="https://rdrr.io/r/base/kappa.html" class="external-link">rcond()</a></code> is considerably more efficient.</p>
</div>
</div>
<div class="section level2">
<h2 id="conj">Obtain complex conjugate of each element<a class="anchor" aria-label="anchor" href="#conj"></a>
</h2>
<p>The <code>conj()</code> function computes the complex conjugate of each element in a complex matrix or cube.</p>
<div class="section level3">
<h3 id="examples-9">Examples<a class="anchor" aria-label="anchor" href="#examples-9"></a>
</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">conj1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>  cx_mat X(n, n, fill::randu);</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  cx_mat Y = conj(X);</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="cf">return</span> as_complex_matrix(Y);</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="conv_to">Convert/cast between matrix types<a class="anchor" aria-label="anchor" href="#conv_to"></a>
</h2>
<p>The <code>conv_to()</code> function converts a matrix or cube to a different type. It can convert <code>mat</code> to <code>imat</code>, <code>cube</code> to <code>icube</code>, <code>mat</code> into <code>colvec</code> or any other casting that preserves data (e.g., a matrix that cannot be interpreted as a vector is not a valid casting). It can also be used to convert a matrix/vector into a <code>std::vector</code> object.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>conv_to&lt;type&gt;::from(X) </span></code></pre></div>
<div class="section level3">
<h3 id="examples-10">Examples<a class="anchor" aria-label="anchor" href="#examples-10"></a>
</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">conv_to1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>  fmat B = conv_to&lt;fmat&gt;::from(A);</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; x(B.n_elem);</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>  <span class="dt">int</span> i, N = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(B.n_elem);</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>  <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; N; ++i) { x[i] = B(i); }</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>  colvec y = conv_to&lt;colvec&gt;::from(x);</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; z = conv_to&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&gt;::from(y);</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(z);</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-1">Caveat<a class="anchor" aria-label="anchor" href="#caveat-1"></a>
</h3>
<p>To convert an expression that results in a 1x1 matrix to a pure scalar value, use <code>as_scalar()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="cross">Cross product<a class="anchor" aria-label="anchor" href="#cross"></a>
</h2>
<p>The <code>cross()</code> function computes the cross product of two vectors under the assumption that the vectors are three-dimensional.</p>
<div class="section level3">
<h3 id="examples-11">Examples<a class="anchor" aria-label="anchor" href="#examples-11"></a>
</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">cross1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  vec A(n, fill::randu);</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  vec B(n, fill::randu);</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  vec C = cross(A, B);</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(C);</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cumsum">Cumulative sum<a class="anchor" aria-label="anchor" href="#cumsum"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cumsum()</a></code> function computes the cumulative sum of elements in a vector or matrix. For a vector, it returns a vector of the same orientation. For a matrix, it returns a matrix with the cumulative sum along the specified dimension (the default is along columns with <code>dimension = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>cumsum(vector);</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>cumsum(matrix, dimension); <span class="co">// dimension = 0 -&gt; cumulative sum along columns</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>                           <span class="co">// dimension = 1 -&gt; cumulative sum along rows</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-12">Examples<a class="anchor" aria-label="anchor" href="#examples-12"></a>
</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">cumsum1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  mat B = cumsum(A);</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  mat C = cumsum(A, <span class="dv">1</span>);</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  vec x(n, fill::randu);</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>  vec y = cumsum(x);</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>  writable::doubles res(<span class="dv">3</span>);</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = accu(B);</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>  res[<span class="dv">1</span>] = accu(C);</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>  res[<span class="dv">2</span>] = accu(y);</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>  </span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cumprod">Cumulative product<a class="anchor" aria-label="anchor" href="#cumprod"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cumprod()</a></code> function computes the cumulative product of elements in a vector or matrix. For a vector, it returns a vector of the same orientation. For a matrix, it returns a matrix with the cumulative product along the specified dimension (the default is along columns with <code>dimension = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>cumprod(vector);</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>cumprod(matrix, dimension); <span class="co">// dimension = 0 -&gt; cumulative prod along columns</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>                            <span class="co">// dimension = 1 -&gt; cumulative prod along rows</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-13">Examples<a class="anchor" aria-label="anchor" href="#examples-13"></a>
</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">cumprod1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>  mat B = cumprod(A);</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>  mat C = cumprod(A, <span class="dv">1</span>);</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>  vec x(n, fill::randu);</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>  vec y = cumprod(x);</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>  writable::doubles res(<span class="dv">3</span>);</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = accu(B);</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a>  res[<span class="dv">1</span>] = accu(C);</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a>  res[<span class="dv">2</span>] = accu(y);</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a>  </span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="det">Determinant<a class="anchor" aria-label="anchor" href="#det"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/det.html" class="external-link">det()</a></code> function computes the determinant of a square matrix. It is based on the LU decomposition. If the input is a not a square matrix, the function throws a <code>std::runtime_error</code> exception.</p>
<p>Usage:</p>
<pre><code>val = det(X); // store a scalar
det(val, A); // store the determinant in val and return true if successful</code></pre>
<p>If the calculation fails:</p>
<ul>
<li>
<code>val = det(A)</code> throws a <code>std::runtime_error</code> exception</li>
<li>
<code>det(val,A)</code> returns a bool set to false (exception is not thrown)</li>
</ul>
<div class="section level3">
<h3 id="examples-14">Examples<a class="anchor" aria-label="anchor" href="#examples-14"></a>
</h3>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">det1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>  <span class="dt">double</span> val1 = det(A);</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>  <span class="dt">double</span> val2;</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>  mat B(n, n, fill::randu);</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>  <span class="dt">bool</span> success2 = det(val2, B);</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>  <span class="cf">return</span> writable::doubles({val1, val2, <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(success2)});</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diagmat">Generate diagonal matrix from given matrix or vector<a class="anchor" aria-label="anchor" href="#diagmat"></a>
</h2>
<p>The <code>diagmat()</code> function generates a diagonal matrix from a given vector or matrix. If the input is a vector, the output is a square matrix with the vector as the diagonal. If the input is a matrix, the output is a square matrix with the diagonal elements from the input matrix. Any element outside the diagonal is set to zero. The default is the main diagonal (<code>k = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>diagmat(vector);</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>diagmat(matrix);</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>diagmat(matrix, k); <span class="co">// k = 0 -&gt; main diagonal</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>                    <span class="co">// k &gt; 0 -&gt; above main diagonal</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>                    <span class="co">// k &lt; 0 -&gt; below main diagonal</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-15">Examples<a class="anchor" aria-label="anchor" href="#examples-15"></a>
</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">diagmat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>  mat B = diagmat(A);</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>  mat C = diagmat(A, <span class="dv">1</span>);</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>  vec v(n, fill::randu);</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  mat D = diagmat(v); <span class="co">// NxN diagonal matrix</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>  mat E = diagmat(v, <span class="dv">1</span>); <span class="co">// (N+1)x(N+1) diagonal matrix</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>  mat res = B + C + D;  </span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a>  res += E.submat(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>); <span class="co">// the result is an upper triangular matrix</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diagvec">Extract specified diagonal<a class="anchor" aria-label="anchor" href="#diagvec"></a>
</h2>
<p>The <code>diagvec()</code> function extracts the specified diagonal from a matrix. The default is the main diagonal (<code>k = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>diagvec(matrix);</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>diagvec(matrix, k); <span class="co">// k = 0 -&gt; main diagonal</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>                    <span class="co">// k &gt; 0 -&gt; above main diagonal</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>                    <span class="co">// k &lt; 0 -&gt; below main diagonal</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-16">Examples<a class="anchor" aria-label="anchor" href="#examples-16"></a>
</h3>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">diagvec1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>  vec B = diagvec(A);</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  vec C = diagvec(A, <span class="dv">1</span>);</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>  vec res = B.subvec(<span class="dv">0</span>, <span class="dv">1</span>) + C;</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(res);</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diags">Generate a dense matrix with diagonals specified by column vectors<a class="anchor" aria-label="anchor" href="#diags"></a>
</h2>
<p>The <code>diags()</code> function generates a dense matrix with diagonals specified by column vectors from an input matrix and a vector to indicate the diagonals.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>diags(matrix, vector, number_of_rows, number_of_columns);</span></code></pre></div>
<p>Each element in the input vector specifies diagonal <code>k</code>, where:</p>
<ul>
<li>
<code>k = 0</code> is the main diagonal</li>
<li>
<code>k &gt; 0</code> is above the main diagonal</li>
<li>
<code>k &lt; 0</code> is below the main diagonal</li>
</ul>
<div class="section level3">
<h3 id="examples-17">Examples<a class="anchor" aria-label="anchor" href="#examples-17"></a>
</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">diags1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>  mat V(n, n, fill::randu);</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>  ivec D = {<span class="dv">0</span>, -<span class="dv">1</span>};</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>  mat X = diags(V, D, n, n); <span class="co">// lower triangular matrix</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diff">Differences between adjacent elements<a class="anchor" aria-label="anchor" href="#diff"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff()</a></code> function computes the differences between adjacent elements in a vector or matrix. For a vector, the output is a vector of length <code>n-k</code> (the default is <code>k = 1</code>). For a matrix, the output is a matrix with <code>n-k</code> rows when <code>dim = 0</code> (the default) and <code>m-k</code> columns when <code>dim = 1</code>. If <code>k</code> is greater than the length of the vector or the number or rows/columns, the output is an empty vector/matrix.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>diff(vector);</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>diff(vector, k);</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>diff(matrix);</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>diff(matrix, k);</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>diff(matrix, k, dim); <span class="co">// dim = 0 -&gt; differences along columns</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>                      <span class="co">// dim = 1 -&gt; differences along rows</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-18">Examples<a class="anchor" aria-label="anchor" href="#examples-18"></a>
</h3>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">diff1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  vec a = randu&lt;vec&gt;(n);</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>  vec b = diff(a);</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>  mat res(n, <span class="dv">2</span>, fill::zeros);</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>  </span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a>  res.col(<span class="dv">0</span>) = a;</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; ++i) {</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true"></a>    res(i, <span class="dv">1</span>) = b(i - <span class="dv">1</span>);</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true"></a>  }</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="dot">Dot product<a class="anchor" aria-label="anchor" href="#dot"></a>
</h2>
<p>The <code>dot()</code>, <code>cdot()</code>, and <code>norm_dot()</code> functions compute the dot product of two vectors. The <code>cdot()</code> function computes the complex conjugate dot product, and the <code>norm_dot()</code> function computes the dot product and normalises the result by the product of the Euclidean norms of the input vectors.</p>
<div class="section level3">
<h3 id="examples-19">Examples<a class="anchor" aria-label="anchor" href="#examples-19"></a>
</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">dot1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  vec A(n, fill::randu);</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>  vec B(n, fill::randu);</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>  <span class="cf">return</span> writable::doubles({dot(A, B), cdot(A, B), norm_dot(A, B)});</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-2">Caveat<a class="anchor" aria-label="anchor" href="#caveat-2"></a>
</h3>
<p><code><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm()</a></code> is more robust for calculating the norm, as it handles underflows and overflows.</p>
</div>
</div>
<div class="section level2">
<h2 id="eps">Obtain distance of each element to next largest floating point representation<a class="anchor" aria-label="anchor" href="#eps"></a>
</h2>
<p>The <code>eps()</code> function computes the distance of each element in a scalar, vector or matrix to the next largest floating point representation. For vector input, the output is a vector of the same orientation and length. For matrix input, the output is a matrix of the same dimensions.</p>
<div class="section level3">
<h3 id="examples-20">Examples<a class="anchor" aria-label="anchor" href="#examples-20"></a>
</h3>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">eps1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>  mat B = eps(A);</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="expmat">Matrix exponential<a class="anchor" aria-label="anchor" href="#expmat"></a>
</h2>
<p>The <code>expmat()</code> function computes the matrix exponential of a square matrix. If the matrix exponential cannot be computed, the function throws a <code>std::runtime_error</code>, same if the input is not a square matrix.</p>
<div class="section level3">
<h3 id="examples-21">Examples<a class="anchor" aria-label="anchor" href="#examples-21"></a>
</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">expmat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>  mat B = expmat(A);</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats">Caveats<a class="anchor" aria-label="anchor" href="#caveats"></a>
</h3>
<ul>
<li>The matrix exponential operation is generally not the same as applying the <code><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp()</a></code> function to each element.</li>
<li>If the input matrix is symmetric, <code>expmat_sym()</code> is faster.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="expmat_sym">Matrix exponential of symmetric matrix<a class="anchor" aria-label="anchor" href="#expmat_sym"></a>
</h2>
<p>The <code>expmat_sym()</code> function computes the matrix exponential of a symmetric or Hermitian matrix. If the matrix exponential cannot be computed, the function throws a <code>std::runtime_error</code>, same if the input is not a square matrix.</p>
<div class="section level3">
<h3 id="examples-22">Examples<a class="anchor" aria-label="anchor" href="#examples-22"></a>
</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">expmat_sym1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>  A = A + A.t(); <span class="co">// make A symmetric</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>  mat B = expmat_sym(A);</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="find">Find indices of non-zero elements, or elements satisfying a relational condition<a class="anchor" aria-label="anchor" href="#find"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function returns the indices of non-zero elements in a vector, or that satisfy a relational condition in a vector or matrix. The output is a vector of indices (<code>uvec</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>find(vector);</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>find(vector, k);</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>find(vector, k, s);</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>find(matrix);</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a>find(matrix, k);</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>find(matrix, k, s);</span></code></pre></div>
<p>The parameter <code>k</code> (<code>k=0</code> by default) returns the indices of all non-zero elements or elements that meet the condition. The optional parameter <code>s = "first"</code> returns the first <code>m</code> non-zero indices or indices that meet the condition, and <code>s = "last"</code> returns the last <code>m</code> non-zero indices or indices that meet the condition.</p>
<div class="section level3">
<h3 id="examples-23">Examples<a class="anchor" aria-label="anchor" href="#examples-23"></a>
</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">find1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>  mat B(n, n, fill::randu);</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>  uvec q1 = find(A &gt; B);</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>  uvec q2 = find(A &gt; <span class="fl">0.5</span>);</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>  uvec q3 = find(A &gt; <span class="fl">0.5</span>, <span class="dv">3</span>, <span class="st">"last"</span>);</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true"></a>  <span class="co">// change elements of A greater than 0.5 to 1</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true"></a>  A.elem(find(A &gt; <span class="fl">0.5</span>)).ones();</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true"></a>  <span class="cf">return</span> writable::list(as_integers(q1), as_integers(q2), as_integers(q3));</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-1">Caveats<a class="anchor" aria-label="anchor" href="#caveats-1"></a>
</h3>
<ul>
<li>To clamp values to an interval, <code>clamp()</code> is more efficient.</li>
<li>To replace a specific value, <code>.replace()</code> is more efficient.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="find_finite">Find indices of finite elements<a class="anchor" aria-label="anchor" href="#find_finite"></a>
</h2>
<p>The <code>find_finite()</code> function returns the indices of finite elements in a vector or matrix. The output is a vector of indices (<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-24">Examples<a class="anchor" aria-label="anchor" href="#examples-24"></a>
</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">find_finite1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>  uvec q = find_finite(A);</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(q);</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="find_nonfinite">Find indices of non-finite elements<a class="anchor" aria-label="anchor" href="#find_nonfinite"></a>
</h2>
<p>The <code>find_nonfinite()</code> function returns the indices of non-finite elements in a vector or matrix. The output is a vector of indices (<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-25">Examples<a class="anchor" aria-label="anchor" href="#examples-25"></a>
</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">find_nonfinite1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>  A(<span class="dv">0</span>, <span class="dv">0</span>) = datum::inf;</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>  uvec q = find_nonfinite(A);</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(q);</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-3">Caveat<a class="anchor" aria-label="anchor" href="#caveat-3"></a>
</h3>
<p>To replace instances of a specific non-finite value (eg. <code>NaN</code> or <code>Inf</code>), it is more efficient to use <code>.replace()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="find_nan">Find indices of NaN elements<a class="anchor" aria-label="anchor" href="#find_nan"></a>
</h2>
<p>The <code>find_nan()</code> function returns the indices of NaN elements in a vector or matrix. The output is a vector of indices (<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-26">Examples<a class="anchor" aria-label="anchor" href="#examples-26"></a>
</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">find_nan1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>  A(<span class="dv">0</span>, <span class="dv">0</span>) = datum::nan;</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>  uvec q = find_nan(A);</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(q);</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-4">Caveat<a class="anchor" aria-label="anchor" href="#caveat-4"></a>
</h3>
<p>To replace instances of <code>NaN</code> values, it is more efficient to use <code>.replace()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="find_unique">Find indices of unique elements<a class="anchor" aria-label="anchor" href="#find_unique"></a>
</h2>
<p>The <code>find_unique()</code> function returns the indices of unique elements in a vector or matrix. The output is a vector of indices (<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-27">Examples<a class="anchor" aria-label="anchor" href="#examples-27"></a>
</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">find_unique1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a>  A(<span class="dv">0</span>, <span class="dv">0</span>) = A(<span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>  uvec q = find_unique(A);</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(q);</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="fliplr">Flip matrix left to right or upside down<a class="anchor" aria-label="anchor" href="#fliplr"></a>
</h2>
<p>The <code>fliplr()</code> function generates a copy of the input matrix with the order of the columns reversed, and the <code>flipud()</code> function generates a copy of the input matrix with the order of the rows reversed.</p>
<div class="section level3">
<h3 id="examples-28">Examples<a class="anchor" aria-label="anchor" href="#examples-28"></a>
</h3>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">flip1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>  mat B = fliplr(A);</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>  mat C = flipud(A);</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true"></a>  writable::list res(<span class="dv">3</span>);</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="imag">Extract imaginary/real part<a class="anchor" aria-label="anchor" href="#imag"></a>
</h2>
<p>The <code>imag()</code> and <code>real()</code> functions extract the imaginary and real parts of each element in a complex matrix, respectively.</p>
<div class="section level3">
<h3 id="examples-29">Examples<a class="anchor" aria-label="anchor" href="#examples-29"></a>
</h3>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">imag1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>  cx_mat X(n, n, fill::randu);</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>  mat Y = imag(X);</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a>  mat Z = real(X);</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(Y);</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(Z);</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true"></a></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-5">Caveat<a class="anchor" aria-label="anchor" href="#caveat-5"></a>
</h3>
<p>To convert a complex matrix to a list of real matrices, it is more efficient to use <code>as_complex_matrix()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="ind2sub">Convert linear index to subscripts<a class="anchor" aria-label="anchor" href="#ind2sub"></a>
</h2>
<p>The <code>ind2sub()</code> function converts a linear index or vector of indexes to subscripts. The output is a vector of indices (<code>uvec</code>) if the input index is a scalar, and a matrix of indices (<code>umat</code>) if the input index is a vector.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>uvec sub = ind2sub(size(X), index)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>uvec sub = ind2sub(size(n_rows, n_cols), index)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>uvec sub = ind2sub(size(n_rows, n_cols, n_slices), index)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a>umat sub = ind2sub(size(X), vector_of_indices)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true"></a>umat sub = ind2sub(size(n_rows, n_cols), vector_of_indices)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true"></a>umat sub = ind2sub(size(n_rows, n_cols, n_slices), vector_of_indices)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-30">Examples<a class="anchor" aria-label="anchor" href="#examples-30"></a>
</h3>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">ind2sub1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>  mat M(n, n, fill::randu);</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a>  uvec s = ind2sub(size(M), n);</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a>  uvec indices = find(M &gt; <span class="fl">0.5</span>);</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true"></a>  umat t       = ind2sub(size(M), indices);</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true"></a>  cube Q(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>);</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true"></a>  uvec u = ind2sub(size(Q), <span class="dv">8</span>);</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true"></a></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true"></a>  writable::list res(<span class="dv">3</span>);</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_integers(s);</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_integers_matrix(t);</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_integers(u);</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true"></a></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="index_min">Indices of extremum values<a class="anchor" aria-label="anchor" href="#index_min"></a>
</h2>
<p>The <code>index_min()</code> and <code>index_max()</code> functions return the indices of the minimum and maximum values in a vector, matrix or cube. For an input vector, the output is a scalar index (<code>uword</code>). For an input matrix, the output is a vector of indices (<code>uvec</code>) with row orientation for the argument <code>dim = 0</code> (default) with the min/max for each column, and column orientation for <code>dim = 1</code> with the min/max for each row. For an input cube, the output is a cube of indices (<code>ucube</code>) with the min/max for each slice’s columns when <code>dim = 0</code>, the min/max for each slice’s rows when <code>dim = 1</code>, and the min/max for each slice when <code>dim = 2</code>. For complex objects, the absolute value is used to compare the elements.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="co">// index_max is analogous</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>index_min(vector)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>index_min(matrix)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>index_min(matrix, dim)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>index_min(cube)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>index_min(cube, dim)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-31">Examples<a class="anchor" aria-label="anchor" href="#examples-31"></a>
</h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">index_min1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>  vec v(n, fill::randu);</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>  uword i = index_max(v);</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>  <span class="dt">double</span> max_val_in_v = v(i);</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>  mat M(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true"></a>  urowvec ii = index_max(M);</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true"></a>  ucolvec jj = index_max(M, <span class="dv">1</span>);</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true"></a>  <span class="co">// max values in col 0 and row n</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true"></a>  <span class="cf">return</span> writable::doubles res({M(ii(<span class="dv">0</span>), <span class="dv">0</span>), M(n, jj(n))});</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="inplace_trans">In-place dense transpose<a class="anchor" aria-label="anchor" href="#inplace_trans"></a>
</h2>
<p>The <code>inplace_trans()</code> and <code>inplace_strans()</code> function return the in-place transpose of a dense matrix. For both functions the optional <code>method = "lowmem"</code> argument uses a low memory (and slower) algorithm for the transpose (the default is <code>method = "std"</code>).</p>
<p>For real matrices:</p>
<ul>
<li>
<code>inplace_trans()</code> returns the common transpose of the input matrix.</li>
<li>
<code>inplace_strans()</code> does not apply.</li>
</ul>
<p>For complex matrices:</p>
<ul>
<li>
<code>inplace_trans()</code> returns the Hermitian transpose (conjugate transpose) of the input matrix.</li>
<li>
<code>inplace_strans()</code> returns the transposed copy without taking the conjugate of the elements of the input matrix.</li>
</ul>
<div class="section level3">
<h3 id="examples-32">Examples<a class="anchor" aria-label="anchor" href="#examples-32"></a>
</h3>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">inplace_trans1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>  inplace_trans(X);</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>}</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">inplace_strans1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>  cx_mat X(n, n, fill::randu);</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>  inplace_strans(X);</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a>  <span class="cf">return</span> as_complex_matrix(X);</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="intersect">Find common elements in two vectors/matrices<a class="anchor" aria-label="anchor" href="#intersect"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/sets.html" class="external-link">intersect()</a></code> function returns the common elements for two vectors or matrices. The output is an ascending sorted vector of unique common elements.</p>
<div class="section level3">
<h3 id="examples-33">Examples<a class="anchor" aria-label="anchor" href="#examples-33"></a>
</h3>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">intersect1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>  ivec A = regspace&lt;ivec&gt;(n, <span class="dv">1</span>);      <span class="co">// n, ..., 1</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>  ivec B = regspace&lt;ivec&gt;(<span class="dv">2</span>, n + <span class="dv">1</span>);  <span class="co">// 2, ..., n + 1</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>  ivec C = intersect(A, B);  <span class="co">// 2, ..., n</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(C);</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="join_rows">Concatenation of matrices<a class="anchor" aria-label="anchor" href="#join_rows"></a>
</h2>
<p>The <code>join_rows()</code> and <code>join_cols()</code> functions concatenate matrices horizontally and vertically, respectively. The input matrices must have the same number of rows for <code>join_rows()</code> and the same number of columns for <code>join_cols()</code>. Both functions accept from two to four matrices as input.</p>
<p>Alternatively, <code>join_horiz()</code> and <code>join_vert()</code> can be used as aliases for <code>join_rows()</code> and <code>join_cols()</code>, respectively.</p>
<div class="section level3">
<h3 id="examples-34">Examples<a class="anchor" aria-label="anchor" href="#examples-34"></a>
</h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">join_rows1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>  mat A(n, <span class="dv">1</span>, fill::randu);</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a>  mat B(n, <span class="dv">1</span>, fill::randu);</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>  mat C(n, <span class="dv">1</span>, fill::randu);</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a>  mat D = join_rows(A, B, C);</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true"></a>  mat E = join_cols(A, B, C);</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true"></a>  <span class="cf">return</span> writable::list({A, B, C, D, E});</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="join_slices">Concatenation of cubes<a class="anchor" aria-label="anchor" href="#join_slices"></a>
</h2>
<p>The <code>join_slices()</code> function concatenates cubes along the third dimension. For two matrices, the input matrices must have the same number of rows and columns. For two cubes, the input cubes must have the same number of rows and columns. For matrix and cube, the number of rows and columns of the matrix must match the number of rows and columns of the cube.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>join_slices(matrix, matrix)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>join_slices(cube, cube);</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>join_slices(matrix, cube);</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a>join_slices(cube, matrix);</span></code></pre></div>
<div class="section level3">
<h3 id="examples-35">Examples<a class="anchor" aria-label="anchor" href="#examples-35"></a>
</h3>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">join_cubes1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a>  cube C(n, n + <span class="dv">1</span>, <span class="dv">3</span>, fill::randu);</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a>  cube D(n, n + <span class="dv">1</span>, <span class="dv">4</span>, fill::randu);</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true"></a>  cube E = join_slices(C, D);</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true"></a>  <span class="dt">size_t</span> m = C.n_slices + D.n_slices;</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true"></a>  writable::list res(m);</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; m; ++i) {</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true"></a>    res[i] = as_doubles_matrix(E.slice(i));</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true"></a>  }</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true"></a></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="kron">Kronecker tensor product<a class="anchor" aria-label="anchor" href="#kron"></a>
</h2>
<p>The <code>kron()</code> function computes the Kronecker tensor product of two matrices.</p>
<div class="section level3">
<h3 id="examples-36">Examples<a class="anchor" aria-label="anchor" href="#examples-36"></a>
</h3>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">kron1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a>  mat B(n + <span class="dv">1</span>, n, fill::randu);</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>  mat K = kron(A, B);</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(K);</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="log_det">Log determinant<a class="anchor" aria-label="anchor" href="#log_det"></a>
</h2>
<p>The <code>log_det()</code> function computes the natural logarithm of the determinant of a square matrix based on LU decomposition. If the matrix is not square or the computation fails, the function throws a <code>std::runtime_error</code> exception.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a>complex val = log_det(X);</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>log_det(val, sign, X);</span></code></pre></div>
<p>Form 1: <code>log_det(X)</code> returns the complex logarithm of the determinant of <code>X</code>. If the input matrix is real, the imaginary part of the result is zero.</p>
<p>Form 2: <code>log_det(val, sign, X)</code> returns a bool indicating if the calculation was successful and stores the logarithm of the determinant in the <code>val</code> and <code>sign</code> variables such that <code>det(X) = sign * exp(val)</code>. If the computation fails, the values of <code>val</code> and <code>sign</code> are undefined and it returns <code>false</code> without throwing an exception.</p>
<div class="section level3">
<h3 id="examples-37">Examples<a class="anchor" aria-label="anchor" href="#examples-37"></a>
</h3>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">log_det1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true"></a>  cx_double res1 = log_det(A);  <span class="co">// form 1</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true"></a>  cpp11::writable::list res2;</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true"></a>  res2.push_back(writable::doubles({<span class="bu">std::</span>real(res1)}));</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true"></a>  res2.push_back(writable::doubles({<span class="bu">std::</span>imag(res1)}));</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true"></a>  <span class="dt">double</span> val;</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true"></a>  <span class="dt">double</span> sign;</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true"></a>  <span class="dt">bool</span> ok = log_det(val, sign, A);  <span class="co">// form 2</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true"></a>  writable::list res3(<span class="dv">3</span>);</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true"></a>  res3[<span class="dv">0</span>] = doubles({val});</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true"></a>  res3[<span class="dv">1</span>] = doubles({sign});</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true"></a>  res3[<span class="dv">2</span>] = logicals({ok});</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true"></a></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true"></a>  res[<span class="dv">0</span>] = res2;</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true"></a>  res[<span class="dv">1</span>] = res3;</span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true"></a></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="log_det_sympd">Log determinant of symmetric positive definite matrix<a class="anchor" aria-label="anchor" href="#log_det_sympd"></a>
</h2>
<p>The <code>log_det_sympd()</code> function computes the natural logarithm of the determinant of a symmetric positive definite matrix. If the matrix is not square or the computation fails, a <code>std::runtime_error</code> exception is thrown.</p>
<p>Form 1: <code>log_det_sympd(X)</code> returns the logarithm of the determinant of <code>X</code>.</p>
<p>Form 2: <code>log_det_sympd(val, X)</code> returns a bool indicating if the calculation was successful and stores the logarithm of the determinant in the <code>val</code> variable. If the computation fails, the value of <code>val</code> is undefined and it returns <code>false</code> without throwing an exception.</p>
<div class="section level3">
<h3 id="examples-38">Examples<a class="anchor" aria-label="anchor" href="#examples-38"></a>
</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">log_det_sympd1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>  A = A * A.t();  <span class="co">// make A symmetric positive definite</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a>  <span class="dt">double</span> val = log_det_sympd(A);  <span class="co">// form 1</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a>  <span class="dt">double</span> val2;</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>  <span class="dt">bool</span> ok = log_det_sympd(val2, A);  <span class="co">// form 2</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a>  res[<span class="dv">0</span>] = doubles({val});</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true"></a>  writable::list res2(<span class="dv">2</span>);</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true"></a>  res2[<span class="dv">0</span>] = doubles({val2});</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true"></a>  res2[<span class="dv">1</span>] = logicals({ok});</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true"></a>  res[<span class="dv">1</span>] = res2;</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true"></a></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="logmat">Matrix logarithm<a class="anchor" aria-label="anchor" href="#logmat"></a>
</h2>
<p>The <code>logmat()</code> function computes the matrix logarithm of a square matrix. If the input matrix is not square or the computation fails, a <code>std::runtime_error</code> exception is thrown.</p>
<p>Form 1: <code>logmat(X)</code> returns the matrix logarithm of <code>X</code>.</p>
<p>Form 2: <code>logmat(val, X)</code> returns a bool indicating if the calculation was successful and stores the matrix logarithm in the <code>val</code> variable. If the computation fails, the value of <code>val</code> is undefined and it returns <code>false</code> without throwing an exception.</p>
<div class="section level3">
<h3 id="examples-39">Examples<a class="anchor" aria-label="anchor" href="#examples-39"></a>
</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">logmat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a>  cx_mat B = logmat(A);</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a>  <span class="cf">return</span> as_complex_matrix(B);</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-2">Caveats<a class="anchor" aria-label="anchor" href="#caveats-2"></a>
</h3>
<ul>
<li>The matrix logarithm operation is generally not the same as applying the <code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log()</a></code> function to each element.</li>
<li>If the input matrix is symmetric positive definite, <code>logmat_sympd()</code> is faster.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="logmat_sympd">Matrix logarithm of symmetric matrix<a class="anchor" aria-label="anchor" href="#logmat_sympd"></a>
</h2>
<p>The <code>logmat_sympd()</code> function computes the matrix logarithm of a symmetric positive definite matrix. If the input matrix is not square or the computation fails, a <code>std::runtime_error</code> exception is thrown.</p>
<p>Form 1: <code>logmat_sympd(X)</code> returns the matrix logarithm of <code>X</code>.</p>
<p>Form 2: <code>logmat_sympd(Y, X)</code> returns a bool indicating if the calculation was successful and stores the matrix logarithm in the <code>Y</code> variable. If the computation fails, the value of <code>Y</code> is undefined and it returns <code>false</code> without throwing an exception.</p>
<div class="section level3">
<h3 id="examples-40">Examples<a class="anchor" aria-label="anchor" href="#examples-40"></a>
</h3>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">logmat_sympd1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a>  mat B = A * A.t();  <span class="co">// make symmetric matrix</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a>  mat C = logmat_sympd(B);</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(C);</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="min">Return extremum values<a class="anchor" aria-label="anchor" href="#min"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min()</a></code> and <code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max()</a></code> functions return the minimum and maximum values in a vector, matrix or cube. For a vector, the output is a scalar. For a matrix, the output is a vector with the minimum or maximum value for each column when <code>dim = 0</code> (default) and each row when <code>dim = 1</code>. For a cube, the output is a cube with the minimum or maximum value for each slice’s columns when <code>dim = 0</code>, the minimum or maximum value for each slice’s rows when <code>dim = 1</code>, and the minimum or maximum value for each slice when <code>dim = 2</code>. For complex objects, the absolute value is used to compare the elements.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a><span class="co">// max() is analogous</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true"></a>min(vector);</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true"></a>min(vector1, vector2);</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true"></a>min(matrix);</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true"></a>min(matrix, dim);</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true"></a>min(matrix1, matrix2);</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true"></a></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true"></a>min(cube);</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true"></a>min(cube, dim);</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true"></a>min(cube1, cube2);</span></code></pre></div>
<div class="section level3">
<h3 id="examples-41">Examples<a class="anchor" aria-label="anchor" href="#examples-41"></a>
</h3>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">max1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true"></a>  mat M(n, n, fill::randu);</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true"></a>  rowvec a = max(M);</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true"></a>  rowvec b = max(M, <span class="dv">0</span>);</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true"></a>  colvec c = max(M, <span class="dv">1</span>);</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true"></a></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true"></a>  <span class="co">// element-wise maximum</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true"></a>  mat Y(n, n, fill::randu);</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true"></a>  mat Z = arma::max(X, Y);  <span class="co">// use arma:: prefix to distinguish from std::max()</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true"></a>  writable::list res(<span class="dv">4</span>);</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles(a.t());</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles(b.t());</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles(c);</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true"></a>  res[<span class="dv">3</span>] = as_doubles_matrix(Z);</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true"></a></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="nonzeros">Return non-zero values<a class="anchor" aria-label="anchor" href="#nonzeros"></a>
</h2>
<p>The <code>nonzeros()</code> function returns the non-zero values in a vector, matrix or cube. The output is a column vector of non-zero values (<code>vec</code>). The input matrix can be dense or sparse.</p>
<div class="section level3">
<h3 id="examples-42">Examples<a class="anchor" aria-label="anchor" href="#examples-42"></a>
</h3>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">nonzeros1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true"></a>  A.elem(find(A &lt; <span class="fl">0.5</span>)).zeros();  <span class="co">// set elements less than 0.5 to zero</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true"></a>  vec B = nonzeros(A);</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(B);</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-3">Caveats<a class="anchor" aria-label="anchor" href="#caveats-3"></a>
</h3>
<p>Caveats:</p>
<ul>
<li>For dense matrices/vectors, to obtain the number of non-zero elements, the expression <code>accu(X != 0)</code> is more efficient.</li>
<li>For sparse matrices, to obtain the number of non-zero elements, <code>X.n_nonzero</code> is more efficient.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="norm">Various norms of vectors and matrices<a class="anchor" aria-label="anchor" href="#norm"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm()</a></code> function computes the p-norm of a vector or matrix. The optional argument <code>p</code> can be <code>p = {1,...,n}</code>, <code>p = "inf</code>", <code>p = "-inf"</code>, or <code>p = "fro"</code> for the 1,2,…,n-norms, maximum norm, minimum quasi-norm, and Frobenius norm, respectively. The default is the 2-norm for vectors and the Frobenius norm for matrices.</p>
<div class="section level3">
<h3 id="examples-43">Examples<a class="anchor" aria-label="anchor" href="#examples-43"></a>
</h3>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">norm1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true"></a>  vec A(n, fill::randu);</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true"></a>  mat B(n, n, fill::randu);</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true"></a>  <span class="dt">double</span> a1 = norm(A, <span class="dv">1</span>);</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true"></a>  <span class="dt">double</span> a2 = norm(A, <span class="dv">2</span>);</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true"></a>  <span class="dt">double</span> a3 = norm(A, <span class="st">"inf"</span>);</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true"></a>  <span class="dt">double</span> a4 = norm(A, <span class="st">"-inf"</span>);</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true"></a>  <span class="dt">double</span> a5 = norm(A, <span class="st">"fro"</span>);</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true"></a>  <span class="dt">double</span> b1 = norm(B, <span class="dv">1</span>);</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true"></a>  <span class="dt">double</span> b2 = norm(B, <span class="dv">2</span>);</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true"></a>  <span class="dt">double</span> b3 = norm(B, <span class="st">"inf"</span>);</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true"></a>  <span class="dt">double</span> b4 = norm(B, <span class="st">"-inf"</span>);</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true"></a>  <span class="dt">double</span> b5 = norm(B, <span class="st">"fro"</span>);</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true"></a></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true"></a>  writable::doubles res({a1, a2, a3, a4, a5, b1, b2, b3, b4, b5});</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true"></a>  attr(res, <span class="st">"names"</span>) = strings({<span class="st">"a1"</span>, <span class="st">"a2"</span>, <span class="st">"a3"</span>, <span class="st">"a4"</span>, <span class="st">"a5"</span>,</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true"></a>    <span class="st">"b1"</span>, <span class="st">"b2"</span>, <span class="st">"b3"</span>, <span class="st">"b4"</span>, <span class="st">"b5"</span>});</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-4">Caveats<a class="anchor" aria-label="anchor" href="#caveats-4"></a>
</h3>
<ul>
<li>The matrix 2-norm (spectral norm) is based on SVD, which is computationally intensive. A faster alternative is <code>norm2est()</code>.</li>
<li>To obtain the vector norm of each row or column of a matrix, use <code>vecnorm()</code>.</li>
<li>To obtain the zero/Hamming pseudo-norm (number of non-zero elements), use the expression <code>accu(X != 0)</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="norm2est">Fast estimate of the matrix 2-norm<a class="anchor" aria-label="anchor" href="#norm2est"></a>
</h2>
<p>The <code>norm2est()</code> function computes a fast estimate of the 2-norm of a matrix. The function iterates until <code>|est1 - est2| / max(est1, est2) &lt; tol</code> or the number of iterations is equal to <code>max_iter</code>. The default values are <code>tol = 1e-5</code> and <code>max_iter = 100</code>.</p>
<div class="section level3">
<h3 id="examples-44">Examples<a class="anchor" aria-label="anchor" href="#examples-44"></a>
</h3>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">norm2est1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true"></a>  <span class="cf">return</span> doubles({norm2est(A)});</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="normalise">Normalise vectors to unit p-norm<a class="anchor" aria-label="anchor" href="#normalise"></a>
</h2>
<p>The <code>normalise()</code> function normalises vectors or matrices to a p-norm. The default is the 2-norm for vectors and matrices (<code>p = 2</code>). For matrices, the optional <code>dim</code> argument specifies the dimension along which to normalise the matrix, with <code>dim = 0</code> normalising along columns and <code>dim = 1</code> normalising along rows.</p>
<div class="section level3">
<h3 id="examples-45">Examples<a class="anchor" aria-label="anchor" href="#examples-45"></a>
</h3>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">normalise1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true"></a>  mat B = normalise(A, <span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true"></a>  mat C = normalise(A, <span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(B);</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(C);</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"B_norm1_cols"</span>, <span class="st">"C_norm1_rows"</span>});</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true"></a></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="pow">Element-wise power<a class="anchor" aria-label="anchor" href="#pow"></a>
</h2>
<p>The <code>pow()</code> function computes the element-wise power of a matrix or vector. The power argument can be a scalar, vector, or matrix.</p>
<div class="section level3">
<h3 id="examples-46">Examples<a class="anchor" aria-label="anchor" href="#examples-46"></a>
</h3>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">pow1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a>  mat B(n, n, fill::randu);</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a>  mat C = pow(A, <span class="dv">2</span>);</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a>  mat D = pow(A, B);</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(C);</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(D);</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-5">Caveats<a class="anchor" aria-label="anchor" href="#caveats-5"></a>
</h3>
<ul>
<li>To raise all elements to the power 2, use <code>square()</code> instead.</li>
<li>For the matrix power operation, which takes into account matrix structure, use <code>powmat()</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="powmat">Matrix power<a class="anchor" aria-label="anchor" href="#powmat"></a>
</h2>
<p>The <code>powmat()</code> function computes the matrix power of a square matrix. The power argument must be a scalar (e.g., <code>double</code> or <code>int</code>). If the input matrix is not square, the function throws a <code>std::runtime_error</code> exception.</p>
<p>Usage:</p>
<pre><code>Y = powmat(X, 2); // store a matrix
powmat(Y, X, 2); // store the matrix in Y and return true if successful</code></pre>
<p>If the calculation fails:</p>
<ul>
<li>
<code>Y = powmat(X)</code> throws a <code>std::runtime_error</code> exception.</li>
<li>
<code>powmat(Y, X, 2)</code> returns a bool set to false (exception is not thrown).</li>
</ul>
<div class="section level3">
<h3 id="examples-47">Examples<a class="anchor" aria-label="anchor" href="#examples-47"></a>
</h3>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">powmat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true"></a>  mat B = powmat(A, <span class="dv">2</span>);  <span class="co">// form 1</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true"></a></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true"></a>  mat C;</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true"></a>  <span class="dt">bool</span> ok = powmat(C, A, <span class="dv">2</span>);  <span class="co">// form 2</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true"></a></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(B);</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true"></a></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true"></a>  writable::list res2(<span class="dv">2</span>);</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true"></a>  res2[<span class="dv">0</span>] = as_doubles_matrix(C);</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true"></a>  res2[<span class="dv">1</span>] = logicals({ok});</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true"></a></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true"></a>  res[<span class="dv">1</span>] = res2;</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true"></a></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"powmat_form1"</span>, <span class="st">"powmat_form2"</span>});</span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true"></a>  res2.attr(<span class="st">"names"</span>) = strings({<span class="st">"result"</span>, <span class="st">"status"</span>});</span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true"></a></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="prod">Product of elements<a class="anchor" aria-label="anchor" href="#prod"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/prod.html" class="external-link">prod()</a></code> function computes the product of the elements in a vector or matrix. The optional <code>dim</code> argument specifies the dimension along which to compute the matrix product, with <code>dim = 0</code> computing the product along columns and <code>dim = 1</code> computing the product along rows.</p>
<div class="section level3">
<h3 id="examples-48">Examples<a class="anchor" aria-label="anchor" href="#examples-48"></a>
</h3>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">prod1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true"></a>  rowvec b = prod(A, <span class="dv">0</span>);</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true"></a>  vec c = prod(A, <span class="dv">1</span>);</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true"></a></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles(b.t());</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles(c);</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true"></a></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="rank">Rank of matrix<a class="anchor" aria-label="anchor" href="#rank"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/rank.html" class="external-link">rank()</a></code> function computes the rank of a matrix based on singular values. The optional <code>tolerance</code> argument specifies the tolerance for the singular values. The default is <code>tolerance = max_rc * max_sv * epsilon</code>, where:</p>
<ul>
<li><code>max_rc = max(X.n_rows, X.n_cols)</code></li>
<li><code>max_sv = max(singular values of X)</code></li>
<li><code>epsilon = 1 - min(singular values of X &gt; 1)</code></li>
</ul>
<p>Usage:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a>val = rank(X, tolerance); <span class="co">// form 1</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>rank(val, X, tolerance);   <span class="co">// form 2</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-49">Examples<a class="anchor" aria-label="anchor" href="#examples-49"></a>
</h3>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">rank1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true"></a>  <span class="dt">int</span> r1 = rank(A);</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true"></a></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true"></a>  uword r2;</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true"></a>  <span class="dt">bool</span> ok = rank(r2, A);</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true"></a></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = integers({r1});</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true"></a></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true"></a>  writable::list res2(<span class="dv">2</span>);</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true"></a>  res2[<span class="dv">0</span>] = integers({<span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(r2)});</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true"></a>  res2[<span class="dv">1</span>] = logicals({ok});</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true"></a></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true"></a>  res[<span class="dv">1</span>] = res2;</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true"></a></span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"rank1"</span>, <span class="st">"rank2"</span>});</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true"></a>  res2.attr(<span class="st">"names"</span>) = strings({<span class="st">"result"</span>, <span class="st">"status"</span>});</span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true"></a></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="rcond">Reciprocal condition number<a class="anchor" aria-label="anchor" href="#rcond"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/kappa.html" class="external-link">rcond()</a></code> function computes the 1-norm estimate of the reciprocal condition number of a square matrix. Values close to one indicate a well-conditioned matrix, while values close to zero indicate a poorly conditioned matrix. If the input matrix is not square, the function throws a <code>std::runtime_error</code> exception.</p>
<div class="section level3">
<h3 id="examples-50">Examples<a class="anchor" aria-label="anchor" href="#examples-50"></a>
</h3>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">rcond1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true"></a>  <span class="cf">return</span> doubles({rcond(A)});</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-6">Caveat<a class="anchor" aria-label="anchor" href="#caveat-6"></a>
</h3>
<p>To efficiently calculate the reciprocal condition and the matrix inverse at the same time, use <code>inv()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="repelem">Replicate elements<a class="anchor" aria-label="anchor" href="#repelem"></a>
</h2>
<p>The <code>repelem()</code> function replicates the elements of a matrix.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a>repelem(A, num_copies_per_row, num_copies_per_col)</span></code></pre></div>
<p>The generated matrix has the following size:</p>
<ul>
<li><code>n_rows = num_copies_per_row * A.n_rows</code></li>
<li><code>n_cols   = num_copies_per_col * A.n_cols</code></li>
</ul>
<div class="section level3">
<h3 id="examples-51">Examples<a class="anchor" aria-label="anchor" href="#examples-51"></a>
</h3>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">repelem1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true"></a>  mat B = repelem(A, <span class="dv">2</span>, <span class="dv">3</span>);</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true"></a></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="repmat">Replicate matrix in block-like fashion<a class="anchor" aria-label="anchor" href="#repmat"></a>
</h2>
<p>The <code>repmat()</code> function replicates a matrix in a block-like fashion.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a>repmat(A, num_reps_row, num_reps_col)</span></code></pre></div>
<p>The generated matrix has the following size:</p>
<ul>
<li><code>n_rows = num_reps_row * A.n_rows</code></li>
<li><code>n_cols = num_reps_col * A.n_cols</code></li>
</ul>
<div class="section level3">
<h3 id="examples-52">Examples<a class="anchor" aria-label="anchor" href="#examples-52"></a>
</h3>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">repmat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true"></a>  mat B = repmat(A, <span class="dv">2</span>, <span class="dv">3</span>);</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true"></a></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-7">Caveat<a class="anchor" aria-label="anchor" href="#caveat-7"></a>
</h3>
<p>To apply a vector operation on each row or column of a matrix, it is generally more efficient to use <code>.each_row()</code> or <code>.each_col()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="reshape">Change size while keeping elements<a class="anchor" aria-label="anchor" href="#reshape"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/stats/reshape.html" class="external-link">reshape()</a></code> function changes the size of a vector, matrix or cube while keeping the elements in the same order.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>reshape(vector, n_rows, n_cols)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a>reshape(matrix, n_rows, n_cols)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a>reshape(vector, size(matrix))</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true"></a>reshape(matrix, size(matrix))</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true"></a></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true"></a>reshape(cube, n_rows, n_cols, n_slices)</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true"></a>reshape(cube, size(cube))</span></code></pre></div>
<div class="section level3">
<h3 id="examples-53">Examples<a class="anchor" aria-label="anchor" href="#examples-53"></a>
</h3>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">reshape1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true"></a>  </span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true"></a>  mat B = reshape(A, n + <span class="dv">1</span>, n);</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true"></a>  </span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true"></a>  mat C(n + <span class="dv">4</span>, n - <span class="dv">1</span>);</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true"></a>  C = reshape(A, size(C));</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true"></a></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(B);</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(C);</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true"></a></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="resize">Change size while keeping elements and preserving layout<a class="anchor" aria-label="anchor" href="#resize"></a>
</h2>
<p>The <code>resize()</code> function changes the size of a vector, matrix or cube while preserving the data. If the new size is larger, the new elements are set to zero.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a>resize(vector, n_rows, n_cols)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true"></a>resize(matrix, n_rows, n_cols)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true"></a>resize(vector, size(matrix))</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true"></a>resize(matrix, size(matrix))</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true"></a></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true"></a>resize(cube, n_rows, n_cols, n_slices)</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true"></a>resize(cube, size(cube))</span></code></pre></div>
<div class="section level3">
<h3 id="examples-54">Examples<a class="anchor" aria-label="anchor" href="#examples-54"></a>
</h3>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">resize2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true"></a>  mat B = resize(A, n + <span class="dv">1</span>, n);</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true"></a>  mat C(n + <span class="dv">4</span>, n - <span class="dv">1</span>);</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true"></a>  C = resize(A, size(C));</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true"></a></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true"></a>  writable::list res(<span class="dv">3</span>);</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true"></a></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="reverse">Reverse order of elements<a class="anchor" aria-label="anchor" href="#reverse"></a>
</h2>
<p>The <code>reverse()</code> function reverses the order of elements in a vector or matrix. The optional <code>dim</code> argument specifies the dimension along which to reverse the matrix, with <code>dim = 0</code> reversing along columns and <code>dim = 1</code> reversing along rows (<code>dim = 0</code> by default).</p>
<div class="section level3">
<h3 id="examples-55">Examples<a class="anchor" aria-label="anchor" href="#examples-55"></a>
</h3>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">reverse1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true"></a>  mat B = reverse(A, <span class="dv">0</span>);</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true"></a>  mat C = reverse(A, <span class="dv">1</span>);</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true"></a>  writable::list res(<span class="dv">3</span>);</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true"></a></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="roots">Roots of polynomial<a class="anchor" aria-label="anchor" href="#roots"></a>
</h2>
<p>The <code>roots()</code> function computes the roots of a polynomial with real or complex coefficients. The input is a vector of coefficients, with the first element corresponding to the highest degree term. If the computation fails, the function throws a <code>std::runtime_error</code> exception.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a>Y = roots(X) <span class="co">// store the roots in Y</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true"></a>roots(Y, X)  <span class="co">// store the roots in Y and return true if successful</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-56">Examples<a class="anchor" aria-label="anchor" href="#examples-56"></a>
</h3>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">roots1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true"></a>  <span class="co">// y = p_1*x^n + p_2*x^(n-1) + ... + p_(n-1)*x + p_n</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true"></a>  <span class="co">// p_1, ..., p_n are random numbers</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true"></a>  vec y(n, <span class="dv">1</span>, fill::randu);</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true"></a></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true"></a>  <span class="co">// note that mat and cx_mat operate directly</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true"></a>  <span class="co">// but vec and cx_vec require conv_to&lt;...&gt;::from()</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true"></a>  cx_vec z = roots(conv_to&lt;cx_vec&gt;::from(y));</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true"></a></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true"></a>  list res = as_complex_doubles(z);</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shift">Shift elements<a class="anchor" aria-label="anchor" href="#shift"></a>
</h2>
<p>The <code>shift()</code> function generates a copy of a vector <code>V</code> or a matrix <code>M</code> with the elements shifted by <code>N</code> positions in a circular manner. The <code>N</code> argument can be positive or negative. For a matrix, the optional <code>dim</code> argument specifies the dimension along which to shift the matrix, with <code>dim = 0</code> shifting along columns (default) and <code>dim = 1</code> shifting along rows.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true"></a>shift(V, N)</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true"></a>shift(M, N)</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true"></a>shift(M, N, dim)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-57">Examples<a class="anchor" aria-label="anchor" href="#examples-57"></a>
</h3>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">shift1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a>  mat B = shift(A, -<span class="dv">1</span>);</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a>  mat C = shift(A, +<span class="dv">1</span>);</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a>  writable::list res(<span class="dv">3</span>);</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shuffle">Randomly shuffle elements<a class="anchor" aria-label="anchor" href="#shuffle"></a>
</h2>
<p>The <code>shuffle()</code> function generates a copy of a vector <code>V</code> or matrix <code>M</code> with the elements shuffled. For a matrix, the optional <code>dim</code> argument specifies the dimension along which to shuffle the matrix, with <code>dim = 0</code> shuffling along columns (default) and <code>dim = 1</code> shuffling along rows.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true"></a>shuffle(V)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true"></a>shuffle(M)</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true"></a>shuffle(M, dim)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-58">Examples<a class="anchor" aria-label="anchor" href="#examples-58"></a>
</h3>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">shuffle1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a>  mat B = shuffle(A);</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true"></a></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="size">Obtain dimensions of given object<a class="anchor" aria-label="anchor" href="#size"></a>
</h2>
<p>The <code>size()</code> function obtains the dimensions of a matrix or cube <code>X</code>. It can also be used to explicitly specify the dimensions of a matrix or cube.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true"></a>size(X)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true"></a>size(n_rows, n_cols)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true"></a>size(n_rows, n_cols, n_slices)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-59">Examples<a class="anchor" aria-label="anchor" href="#examples-59"></a>
</h3>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">size1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true"></a>  mat B(size(A), fill::zeros);</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true"></a></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true"></a>  mat C;</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true"></a>  C.randu(size(A));</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true"></a>  mat D = ones&lt;mat&gt;(size(A));</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true"></a></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true"></a>  mat E(<span class="dv">2</span> * n, <span class="dv">2</span> * n, fill::ones);</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true"></a>  E(<span class="dv">1</span>, <span class="dv">2</span>, size(C)) = C;  <span class="co">// access submatrix of E</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true"></a></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true"></a>  mat F(size(A) + size(E), fill::randu);</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true"></a></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true"></a>  mat G(size(A) * <span class="dv">2</span>, fill::randu);</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true"></a></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true"></a>  writable::list res(<span class="dv">7</span>);</span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true"></a></span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb92-22"><a href="#cb92-22" aria-hidden="true"></a>  res[<span class="dv">3</span>] = as_doubles_matrix(D);</span>
<span id="cb92-23"><a href="#cb92-23" aria-hidden="true"></a>  res[<span class="dv">4</span>] = as_doubles_matrix(E);</span>
<span id="cb92-24"><a href="#cb92-24" aria-hidden="true"></a>  res[<span class="dv">5</span>] = as_doubles_matrix(F);</span>
<span id="cb92-25"><a href="#cb92-25" aria-hidden="true"></a>  res[<span class="dv">6</span>] = as_doubles_matrix(G);</span>
<span id="cb92-26"><a href="#cb92-26" aria-hidden="true"></a></span>
<span id="cb92-27"><a href="#cb92-27" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb92-28"><a href="#cb92-28" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sort">Sort elements<a class="anchor" aria-label="anchor" href="#sort"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort()</a></code> function returns a sorted version of a vector <code>V</code> or matrix <code>M</code>. For a matrix, the optional <code>dim</code> argument specifies the dimension along which to sort the matrix, with <code>dim = 0</code> sorting along columns (default) and <code>dim = 1</code> sorting along rows. The optional <code>sort_direction</code> argument specifies the sorting direction, with <code>sort_direction = "ascend"</code> (default) sorting in ascending order and <code>sort_direction = "descend"</code> sorting in descending order.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true"></a>sort(V)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true"></a>sort(V, sort_direction)</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true"></a>sort(M)</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true"></a>sort(M, sort_direction)</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true"></a>sort(M, sort_direction, dim)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-60">Examples<a class="anchor" aria-label="anchor" href="#examples-60"></a>
</h3>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">sort1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a>  mat B = sort(A);</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a>  mat C = sort(A, <span class="st">"descend"</span>);</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true"></a>  mat D = sort(A, <span class="st">"ascend"</span>, <span class="dv">1</span>);</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true"></a>  mat E = sort(A, <span class="st">"descend"</span>, <span class="dv">1</span>);</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true"></a></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true"></a>  writable::list res(<span class="dv">5</span>);</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true"></a>  res[<span class="dv">3</span>] = as_doubles_matrix(D);</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true"></a>  res[<span class="dv">4</span>] = as_doubles_matrix(E);</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true"></a></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sort_index">Vector describing sorted order of elements<a class="anchor" aria-label="anchor" href="#sort_index"></a>
</h2>
<p>The <code>sort_index()</code> function returns a vector describing the sorted order of the elements of a vector <code>V</code> or matrix <code>M</code>. The optional <code>sort_direction</code> argument specifies the sorting direction, with <code>sort_direction = "ascend"</code> (default) sorting in ascending order and <code>sort_direction = "descend"</code> sorting in descending order.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true"></a>sort_index(V)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true"></a>sort_index(V, sort_direction)</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true"></a></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true"></a>sort_index(M)</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true"></a>sort_index(M, sort_direction)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-61">Examples<a class="anchor" aria-label="anchor" href="#examples-61"></a>
</h3>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">sort_index1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a>  uvec B = sort_index(A);</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a>  uvec C = sort_index(A, <span class="st">"descend"</span>);</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true"></a></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true"></a>  writable::list res(<span class="dv">3</span>);</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_integers(B);</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_integers(C);</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true"></a></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="spdiags">Generate a sparse matrix with diagonals specified by column vectors<a class="anchor" aria-label="anchor" href="#spdiags"></a>
</h2>
<p>The <code>spdiags()</code> function generates a sparse matrix with diagonals specified by column vectors from an input matrix and a vector to indicate the diagonals.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a>spdiags(matrix, vector, number_of_rows, number_of_columns);</span></code></pre></div>
<p>Each element in the input vector specifies diagonal <code>k</code>, where:</p>
<ul>
<li>
<code>k = 0</code> is the main diagonal</li>
<li>
<code>k &gt; 0</code> is above the main diagonal</li>
<li>
<code>k &lt; 0</code> is below the main diagonal</li>
</ul>
<div class="section level3">
<h3 id="examples-62">Examples<a class="anchor" aria-label="anchor" href="#examples-62"></a>
</h3>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">spdiags1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a>  mat V(n, n, fill::randu);</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a>  ivec D = {<span class="dv">0</span>, -<span class="dv">1</span>};</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true"></a>  sp_mat X = spdiags(V, D, n, n); <span class="co">// lower triangular matrix</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sqrtmat">Square root of matrix<a class="anchor" aria-label="anchor" href="#sqrtmat"></a>
</h2>
<p>The <code>sqrtmat()</code> function computes the complex square root of a general square matrix. If the input matrix is not square, the function throws an error. If the matrix appears to be singular, an approximate square root is attempted.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true"></a>B = sqrtmat(A)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true"></a>sqrtmat(B, A)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-63">Examples<a class="anchor" aria-label="anchor" href="#examples-63"></a>
</h3>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">sqrtmat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true"></a>  </span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true"></a>  cx_mat B = sqrtmat(A);</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true"></a></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true"></a>  cx_mat C;</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true"></a>  <span class="dt">bool</span> ok = sqrtmat(C, A);</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true"></a></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true"></a>  writable::list res(<span class="dv">4</span>);</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true"></a></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_complex_matrix(B);</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_complex_matrix(C);</span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true"></a>  res[<span class="dv">3</span>] = logicals({ok});</span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true"></a></span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sqrtmat_sympd">Square root of symmetric matrix<a class="anchor" aria-label="anchor" href="#sqrtmat_sympd"></a>
</h2>
<p>The <code>sqrtmat_sympd()</code> function computes the square root of a symmetric positive definite matrix. If the input matrix is not square or the computation fails, the function throws an error.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true"></a>B = sqrtmat_sympd(A)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true"></a>sqrtmat_sympd(B, A)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-64">Examples<a class="anchor" aria-label="anchor" href="#examples-64"></a>
</h3>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">sqrtmat_sympd1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true"></a>  A = A * A.t();  <span class="co">// make A symmetric positive definite</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true"></a></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true"></a>  mat B = sqrtmat_sympd(A);</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true"></a></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sum">Sum of elements<a class="anchor" aria-label="anchor" href="#sum"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum()</a></code> function computes the sum of the elements in a vector, matrix or cube. For a matrix, the optional <code>dim</code> argument specifies the dimension along which to compute the sum, with <code>dim = 0</code> computing the sum along columns and <code>dim = 1</code> computing the sum along rows. For a cube, the optional <code>dim</code> argument specifies the dimension along which to compute the sum, with <code>dim = 0</code> computing the sum along columns, <code>dim = 1</code> computing the sum along rows, and <code>dim = 2</code> computing the sum along slices.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true"></a>sum(vector)</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true"></a>sum(matrix)</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true"></a>sum(matrix, dim)</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true"></a>sum(cube)</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true"></a>sum(cube, dim)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-65">Examples<a class="anchor" aria-label="anchor" href="#examples-65"></a>
</h3>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">sum2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true"></a>  vec a = sum(A, <span class="dv">1</span>);</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true"></a>  vec b = sum(A, <span class="dv">0</span>).t();</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true"></a>  <span class="dt">double</span> c = accu(A);  <span class="co">// overall sum</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true"></a></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true"></a>  writable::list res(<span class="dv">3</span>);</span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles(a);</span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles(b);</span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true"></a>  res[<span class="dv">2</span>] = doubles({c});</span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true"></a></span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sub2ind">Convert subscripts to linear index<a class="anchor" aria-label="anchor" href="#sub2ind"></a>
</h2>
<p>The <code>sub2ind()</code> function converts subscripts to a linear index. If a subscript is out of range, the function returns an error.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true"></a>sub2ind(size(matrix), row, col)</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true"></a>sub2ind(size(matrix), matrix_of_subscripts)</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true"></a></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true"></a>sub2ind(size(cube), row, col, slice)</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true"></a>sub2ind(size(cube), matrix_of_subscripts)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-66">Examples<a class="anchor" aria-label="anchor" href="#examples-66"></a>
</h3>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">sub2ind1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true"></a>  mat M(n, n, fill::randu);</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true"></a>  uword i = sub2ind(size(M), n - <span class="dv">1</span>, n - <span class="dv">1</span>);</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true"></a></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true"></a>  <span class="cf">return</span> integers({<span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(i)});</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="symmatu-symmatl">Generate symmetric matrix from given matrix<a class="anchor" aria-label="anchor" href="#symmatu-symmatl"></a>
</h2>
<p>The <code>symmatu()</code> function generates a symmetric matrix from a square matrix <code>A</code> by reflecting the upper triangle to the lower triangle. The <code>symmatl()</code> function generates a symmetric matrix from a square matrix <code>A</code> by reflecting the lower triangle to the upper triangle. If <code>A</code> is a complex matrix, the reflection uses the complex conjugate of the elements. To disable the complex conjugate, set <code>do_conj</code> to <code>false</code>. If <code>A</code> is non-square, an error is thrown.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true"></a>symmatu(A)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true"></a>symmatu(A, do_conj)</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true"></a></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true"></a>symmatl(A)</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true"></a>symmatl(A, do_conj)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-67">Examples<a class="anchor" aria-label="anchor" href="#examples-67"></a>
</h3>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">symmatu1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true"></a>  mat B = symmatu(A);</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trace">Sum of diagonal elements<a class="anchor" aria-label="anchor" href="#trace"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/trace.html" class="external-link">trace()</a></code> function computes the sum of the elements on the main diagonal of a matrix. If the input matrix is not square, an error is thrown.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true"></a>trace(X)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-68">Examples<a class="anchor" aria-label="anchor" href="#examples-68"></a>
</h3>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">trace1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true"></a>  <span class="cf">return</span> doubles({trace(A)});</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trans-strans">Transpose of matrix<a class="anchor" aria-label="anchor" href="#trans-strans"></a>
</h2>
<p>The <code>trans()</code> function transposes a matrix. For a real matrix, <code>trans()</code> provides a transposed copy of the matrix. For a complex matrix, <code>trans()</code> provides a Hermitian (conjugate) transposed copy, where the signs of the imaginary components are flipped. The <code>strans()</code> function provides a simple transposed copy, where the signs of the imaginary components are not flipped.</p>
<p>Usage:</p>
<pre><code><span><span class="fu">trans</span><span class="op">(</span><span class="va">A</span><span class="op">)</span></span>
<span><span class="fu">strans</span><span class="op">(</span><span class="va">A</span><span class="op">)</span></span></code></pre>
<div class="section level3">
<h3 id="examples-69">Examples<a class="anchor" aria-label="anchor" href="#examples-69"></a>
</h3>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">trans1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true"></a>  </span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true"></a>  mat B = trans(A);</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true"></a>  mat C = A.t();  <span class="co">// same as trans(A)</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true"></a></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true"></a></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(C);</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true"></a></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trapz">Trapezoidal numerical integration<a class="anchor" aria-label="anchor" href="#trapz"></a>
</h2>
<p>The <code>trapz()</code> function computes the trapezoidal integral of a vector <code>Y</code> with respect to spacing in a vector <code>X</code>. The optional <code>dim</code> argument specifies the dimension along which to compute the trapezoidal integral, with <code>dim = 0</code> computing the integral along columns and <code>dim = 1</code> computing the integral along rows.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true"></a>trapz(X, Y)</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true"></a>trapz(X, Y, dim)</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true"></a></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true"></a>trapz(Y)</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true"></a>trapz(Y, dim)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-70">Examples<a class="anchor" aria-label="anchor" href="#examples-70"></a>
</h3>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">trapz1_</span>(n) {</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true"></a>  vec X = linspace&lt;vec&gt;(<span class="dv">0</span>, datum::pi, n);</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true"></a>  vec Y = sin(X);</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true"></a>  </span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true"></a>  mat Z = trapz(X,Y);</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true"></a></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(Z);</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trimatu-trimatl">Copy upper/lower triangular part<a class="anchor" aria-label="anchor" href="#trimatu-trimatl"></a>
</h2>
<p>The <code>trimatu()</code> function creates a new matrix by copying the upper triangular part from a square matrix <code>A</code> and setting the remaining elements to zero. The <code>trimatl()</code> function creates a new matrix by copying the lower triangular part from a square matrix <code>A</code> and setting the remaining elements to zero. The optional <code>k</code> argument specifies the diagonal (<code>k = 0</code> by default, which sets the main diagonal). For <code>k &gt; 0</code>, the <code>k</code>-th upper-diagonal is used (above the main diagonal, towards the top-right corner). For <code>k &lt; 0</code>, the <code>k</code>-th lower-diagonal is used (below the main diagonal, towards the bottom-left corner).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true"></a>trimatu(A)</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true"></a>trimatu(A, k)</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true"></a>trimatl(A)</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true"></a>trimatl(A, k)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-71">Examples<a class="anchor" aria-label="anchor" href="#examples-71"></a>
</h3>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">trimatu1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true"></a>  mat B = trimatu(A);</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trimatu_ind-trimatl_ind">Obtain indices of upper/lower triangular part<a class="anchor" aria-label="anchor" href="#trimatu_ind-trimatl_ind"></a>
</h2>
<p>The <code>trimatu_ind()</code> function returns a column vector containing the indices of elements that form the upper triangular part of a matrix <code>A</code>. The <code>trimatl_ind()</code> function returns a column vector containing the indices of elements that form the lower triangular part of a matrix <code>A</code>. The optional <code>k</code> argument specifies the diagonal (<code>k = 0</code> by default, which sets the main diagonal). For <code>k &gt; 0</code>, the <code>k</code>-th upper-diagonal is used (above the main diagonal, towards the top-right corner). For <code>k &lt; 0</code>, the <code>k</code>-th lower-diagonal is used (below the main diagonal, towards the bottom-left corner).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true"></a>trimatu_ind(size(A))</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true"></a>trimatu_ind(size(A), k)</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true"></a></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true"></a>trimatl_ind(size(A))</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true"></a>trimatl_ind(size(A), k)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-72">Examples<a class="anchor" aria-label="anchor" href="#examples-72"></a>
</h3>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">trimatu_ind1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true"></a>  uvec B = trimatu_ind(size(A));</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(B);</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="unique">Return unique elements<a class="anchor" aria-label="anchor" href="#unique"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique()</a></code> function returns the unique elements of a vector or matrix <code>A</code>, sorted in ascending order. If <code>A</code> is a vector, the output is also a vector with the same orientation (row or column) as <code>A</code>. If <code>A</code> is a matrix, the output is always a column vector.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true"></a>unique(A)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-73">Examples<a class="anchor" aria-label="anchor" href="#examples-73"></a>
</h3>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">unique1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true"></a>  A(<span class="dv">0</span>, <span class="dv">0</span>) = A(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true"></a>  vec B = unique(A);</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(B);</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="vecnorm">Obtain vector norm of each row or column of a matrix<a class="anchor" aria-label="anchor" href="#vecnorm"></a>
</h2>
<p>The <code>vecnorm()</code> function computes the p-norm of each column vector (when <code>dim = 0</code>) or row vector (when <code>dim = 1</code>) of a matrix <code>X</code>. The optional <code>p</code> argument specifies the norm to compute, with <code>p = 2</code> (default) computing the 2-norm, <code>p = 1</code> computing the 1-norm, <code>p = "inf"</code> computing the maximum norm, and <code>p = "-inf"</code> computing the minimum quasi-norm.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true"></a>vecnorm(X)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true"></a>vecnorm(X, p)</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true"></a>vecnorm(X, p, dim)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-74">Examples<a class="anchor" aria-label="anchor" href="#examples-74"></a>
</h3>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">vecnorm1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true"></a>  colvec a = vecnorm(A, <span class="dv">2</span>).t();</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true"></a>  colvec b = vecnorm(A, <span class="st">"inf"</span>, <span class="dv">1</span>);</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true"></a>  writable::list res(<span class="dv">2</span>);</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles(a);</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles(b);</span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true"></a></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="vectorise">Flatten matrix into vector<a class="anchor" aria-label="anchor" href="#vectorise"></a>
</h2>
<p>The <code>vectorise()</code> function generates a flattened version of a matrix <code>M</code> or cube <code>Q</code>. The optional <code>dim</code> argument specifies the dimension along which to flatten the matrix, with <code>dim = 0</code> flattening column-wise (default) and <code>dim = 1</code> flattening row-wise.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true"></a>vectorise(M)</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true"></a>vectorise(M, dim)</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true"></a></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true"></a>vectorise(Q)</span></code></pre></div>
<div class="section level3">
<h3 id="examples-75">Examples<a class="anchor" aria-label="anchor" href="#examples-75"></a>
</h3>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">vectorise1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true"></a>  vec B = vectorise(A);</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(B);</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="misc-functions">Miscellaneous element-wise functions: exp, log, sqrt, round, sign, and others<a class="anchor" aria-label="anchor" href="#misc-functions"></a>
</h2>
<p>Miscellaneous element-wise functions include:</p>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp()</a></code></td>
<td>Base-e exponential: <code>e^x</code>
</td>
</tr>
<tr class="even">
<td><code>exp2()</code></td>
<td>Base-2 exponential: <code>2^x</code>
</td>
</tr>
<tr class="odd">
<td><code>exp10()</code></td>
<td>Base-10 exponential: <code>10^x</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">expm1()</a></code></td>
<td>Compute <code>exp(A)-1</code> accurately for values of <code>A</code> close to zero (only for float and double elements)</td>
</tr>
<tr class="odd">
<td><code>trunc_exp()</code></td>
<td>Base-e exponential, truncated to avoid infinity (only for float and double elements)</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log()</a></code></td>
<td>Natural log: <code>loge(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2()</a></code></td>
<td>Base-2 log: <code>log2(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log10()</a></code></td>
<td>Base-10 log: <code>log10(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log1p()</a></code></td>
<td>Compute <code>log(1+A)</code> accurately for values of <code>A</code> close to zero (only for float and double elements)</td>
</tr>
<tr class="even">
<td><code>trunc_log()</code></td>
<td>Natural log, truncated to avoid +/-infinity (only for float and double elements)</td>
</tr>
<tr class="odd">
<td><code>square()</code></td>
<td>Square: <code>x^2</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt()</a></code></td>
<td>Square root: <code>x^(1.2)</code>
</td>
</tr>
<tr class="odd">
<td><code>cbrt()</code></td>
<td>Cube root: <code>x^(1/3)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Round.html" class="external-link">floor()</a></code></td>
<td>Largest integral value that is not greater than the input value</td>
</tr>
<tr class="odd">
<td><code>ceil()</code></td>
<td>Smallest integral value that is not less than the input value</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Round.html" class="external-link">round()</a></code></td>
<td>Round to nearest integer, with halfway cases rounded away from zero</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Round.html" class="external-link">trunc()</a></code></td>
<td>Round to nearest integer, towards zero</td>
</tr>
<tr class="even">
<td><code>erf()</code></td>
<td>Error function (only for float and double elements)</td>
</tr>
<tr class="odd">
<td><code>erfc()</code></td>
<td>Complementary error function (only for float and double elements)</td>
</tr>
<tr class="even">
<td><code>tgamma()</code></td>
<td>Gamma function (only for float and double elements)</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Special.html" class="external-link">lgamma()</a></code></td>
<td>Natural log of the absolute value of gamma function (only for float and double elements)</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/sign.html" class="external-link">sign()</a></code></td>
<td>Signum function; for each element <code>a</code> in <code>A</code>, the corresponding element <code>b</code> in <code>B</code> is: <code>-1</code> if <code>a &lt; 0</code>, <code>0</code> if <code>a = 0</code>, <code>+1</code> if <code>a &gt; 0</code>. If <code>a</code> is complex and non-zero, then <code>b = a / abs(a)</code>
</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="caveats-6">Caveats<a class="anchor" aria-label="anchor" href="#caveats-6"></a>
</h3>
<p>All of the above functions are applied element-wise, where each element is treated independently. <code>expmat()</code>, <code>logmat()</code>, <code>sqrtmat()</code>, and <code>powmat()</code> take into account matrix structure.</p>
</div>
<div class="section level3">
<h3 id="examples-76">Examples<a class="anchor" aria-label="anchor" href="#examples-76"></a>
</h3>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">misc1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true"></a>  mat B = exp(A);</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true"></a>  mat C = log(A);</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true"></a>  mat D = sqrt(A);</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true"></a>  mat E = round(A);</span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true"></a>  mat F = sign(A);</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true"></a></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true"></a>  writable::list res(<span class="dv">6</span>);</span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true"></a>  res[<span class="dv">3</span>] = as_doubles_matrix(D);</span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true"></a>  res[<span class="dv">4</span>] = as_doubles_matrix(E);</span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true"></a>  res[<span class="dv">5</span>] = as_doubles_matrix(F);</span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true"></a></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trig-functions">Trigonometric element-wise functions: cos, sin, tan, and others<a class="anchor" aria-label="anchor" href="#trig-functions"></a>
</h2>
<p>Trigonometric element-wise functions include:</p>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">cos()</a></code></td>
<td>Cosine: <code>cos(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">acos()</a></code></td>
<td>Inverse cosine: <code>arccos(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">cosh()</a></code></td>
<td>Hyperbolic cosine: <code>cosh(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">acosh()</a></code></td>
<td>Inverse hyperbolic cosine: <code>arccosh(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin()</a></code></td>
<td>Sine: <code>sin(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">asin()</a></code></td>
<td>Inverse sine: <code>arcsin(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">sinh()</a></code></td>
<td>Hyperbolic sine: <code>sinh(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">asinh()</a></code></td>
<td>Inverse hyperbolic sine: <code>arcsinh(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">tan()</a></code></td>
<td>Tangent: <code>tan(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">atan()</a></code></td>
<td>Inverse tangent: <code>arctan(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">tanh()</a></code></td>
<td>Hyperbolic tangent: <code>tanh(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">atanh()</a></code></td>
<td>Inverse hyperbolic tangent: <code>arctanh(x)</code>
</td>
</tr>
<tr class="odd">
<td><code>sinc()</code></td>
<td>Sinc function: <code>sinc(x) = sin(datum::pi * x) / (datum::pi * x)</code> for <code>x != 0</code>, and <code>sinc(x) = 1</code> for <code>x = 0</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">atan2()</a></code></td>
<td>Two-argument arctangent: <code>atan2(y, x)</code>
</td>
</tr>
<tr class="odd">
<td><code>hypot()</code></td>
<td>Hypotenuse: <code>hypot(x, y)</code>
</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="caveats-7">Caveats<a class="anchor" aria-label="anchor" href="#caveats-7"></a>
</h3>
<p>All of the above functions are applied element-wise, where each element is treated independently.</p>
</div>
<div class="section level3">
<h3 id="examples-77">Examples<a class="anchor" aria-label="anchor" href="#examples-77"></a>
</h3>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">trig1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true"></a>  mat B = cos(A);</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true"></a>  mat C = sin(A);</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true"></a>  mat D = tan(A);</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true"></a>  mat E = atan2(C, B);</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true"></a>  mat F = hypot(B, C);</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true"></a></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true"></a>  writable::list res(<span class="dv">6</span>);</span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(A);</span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(B);</span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C);</span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true"></a>  res[<span class="dv">3</span>] = as_doubles_matrix(D);</span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true"></a>  res[<span class="dv">4</span>] = as_doubles_matrix(E);</span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true"></a>  res[<span class="dv">5</span>] = as_doubles_matrix(F);</span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true"></a></span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb126-18"><a href="#cb126-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Mauricio Vargas Sepulveda, Conrad Sanderson.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
