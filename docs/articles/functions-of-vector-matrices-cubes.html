<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="cpp11armadillo">
<title>Functions of vectors, matrices, and cubes â€¢ cpp11armadillo</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.1/jquery-3.6.1.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Functions of vectors, matrices, and cubes">
<meta property="og:description" content="cpp11armadillo">
<meta property="og:image" content="../cpp11armadillo/logo.svg">
<!-- mathjax --><script src="file:///usr/share/javascript/mathjax/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">cpp11armadillo</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5.4</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/basic-usage.html">Basic 'cpp11armadillo' usage</a>
    <a class="dropdown-item" href="../articles/configuration.html">Armadillo configuration</a>
    <a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-dense.html">Decompositions, factorisations, inverses and equation solvers (dense matrices)</a>
    <a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-sparse.html">Decompositions, factorisations, inverses and equation solvers (sparse matrices)</a>
    <a class="dropdown-item" href="../articles/functions-of-vector-matrices-cubes.html">Functions of vectors, matrices, and cubes</a>
    <a class="dropdown-item" href="../articles/generated-vectors-matrices-cubes.html">Generated vectors, matrices, and cubes</a>
    <a class="dropdown-item" href="../articles/linear-model.html">Fitting regressions with Armadillo</a>
    <a class="dropdown-item" href="../articles/matrix-vector-cube-and-field-classes.html">Matrix, vector, cube and field classes</a>
    <a class="dropdown-item" href="../articles/member-functions-and-variables.html">Member functions and variables</a>
    <a class="dropdown-item" href="../articles/miscellaneous.html">Miscellaneous</a>
    <a class="dropdown-item" href="../articles/save-load.html">Saving and loading Armadillo objects on C++ side</a>
    <a class="dropdown-item" href="../articles/signal-and-image-processing.html">Signal and image processing</a>
    <a class="dropdown-item" href="../articles/sparse-matrices.html">Sparse matrices</a>
    <a class="dropdown-item" href="../articles/statistics-and-clustering.html">Statistics and clustering</a>
    <a class="dropdown-item" href="../articles/syntax-comparison-for-matlab-users.html">Syntax comparison for MATLAB/Octave users</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="nav-link" href="https://github.com/pachadotdev/cpp11armadillo/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Functions of vectors, matrices, and cubes</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/pachadotdev/cpp11armadillo/blob/HEAD/vignettes/functions-of-vector-matrices-cubes.Rmd"><code>vignettes/functions-of-vector-matrices-cubes.Rmd</code></a></small>
      <div class="d-none name"><code>functions-of-vector-matrices-cubes.Rmd</code></div>
    </div>

    
    
<p><strong>This vignette is adapted from the official Armadillo <a href="https://arma.sourceforge.net/docs.html" class="external-link">documentation</a>.</strong></p>
<div class="section level2">
<h2 id="abs">Absolute value<a class="anchor" aria-label="anchor" href="#abs"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs()</a></code> function computes the absolute value of each
element in a vector, matrix, or cube.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>Y <span class="op">=</span> abs<span class="op">(</span>X<span class="op">);</span> <span class="co">// for non-complex X</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="dt">real_object_type</span> Y <span class="op">=</span> abs<span class="op">(</span>X<span class="op">);</span> <span class="co">// for complex X</span></span></code></pre></div>
<p>For the non-complex case, <code>X</code> and <code>Y</code> must have
the same type, such as mat or cube.</p>
<p>For the complex case, <code>Y</code> must be the real counterpart to
the type of <code>X</code>. If <code>X</code> has the type
<code>cx_mat</code>, then the type of <code>Y</code> must be
<code>mat</code>.</p>
<div class="section level3">
<h3 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">abs1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  mat B <span class="op">=</span> abs<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  cx_mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  mat Y <span class="op">=</span> abs<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>  mat res <span class="op">=</span> B <span class="op">+</span> Y<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="accu">Accumulate (sum) all elements<a class="anchor" aria-label="anchor" href="#accu"></a>
</h2>
<p>The <code>accu()</code> function computes the sum of all elements in
a vector, matrix, or cube.</p>
<div class="section level3">
<h3 id="examples-1">Examples<a class="anchor" aria-label="anchor" href="#examples-1"></a>
</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> <span class="dt">double</span> <span class="va">accu1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  mat B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>  <span class="dt">double</span> x <span class="op">=</span> accu<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  <span class="co">// accu(A % B) is a "multiply-and-accumulate" operation</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>  <span class="co">// as operator % performs element-wise multiplication</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>  <span class="dt">double</span> y <span class="op">=</span> accu<span class="op">(</span>A <span class="op">%</span> B<span class="op">);</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>x <span class="op">+</span> y<span class="op">);</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="affmul">Affine matrix multiplication<a class="anchor" aria-label="anchor" href="#affmul"></a>
</h2>
<p>The <code>affmul()</code> function computes matrix multiplication for
<code>A</code> and <code>B</code> with an extended form of
<code>B</code>. <code>A</code> is typically an affine transformation
matrix. <code>B</code> can be a vector or matrix, and is treated as
having an additional row of ones.</p>
<p>The number of columns in <code>A</code> must be equal to number of
rows in the extended form of <code>B</code> (e.g.,
<code>A.n_cols = B.n_rows + 1</code>).</p>
<p>If <code>A</code>has dimensions 3x3 and <code>B</code> 2x1, the
equivalent matrix multiplication is:</p>
<pre><code>âŽ¡ C0 âŽ¤   âŽ¡ A00 A01 A02 âŽ¤   âŽ¡ B0 âŽ¤
âŽ¢ C1 âŽ¥ = âŽ¢ A10 A11 A12 âŽ¥ x âŽ¢ B1 âŽ¥
âŽ£ C2 âŽ¦   âŽ£ A20 A21 A22 âŽ¦   âŽ£ 1  âŽ¦</code></pre>
<p>If <code>A</code> has dimensions 2x3 and <code>B</code> 2x1, the
equivalent matrix multiplication is:</p>
<pre><code>âŽ¡ C0 âŽ¤   âŽ¡ A00 A01 A02 âŽ¤   âŽ¡ B0 âŽ¤
âŽ¢ C1 âŽ¥ = âŽ¢ A10 A11 A12 âŽ¥ x âŽ¢ B1 âŽ¥
                           âŽ£ 1  âŽ¦</code></pre>
<div class="section level3">
<h3 id="examples-2">Examples<a class="anchor" aria-label="anchor" href="#examples-2"></a>
</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">affmul1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  vec B<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  vec C <span class="op">=</span> affmul<span class="op">(</span>A<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="all">Check whether all elements are non-zero, or satisfy a relational
condition<a class="anchor" aria-label="anchor" href="#all"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/all.html" class="external-link">all()</a></code> function checks whether all elements in a
vector, matrix or cube are non-zero, or satisfy a relational condition.
It returns true/false booleans for vectors and 0/1 vectors for matrices
to indicate if the condition is met for each row or column.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>all<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>all<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>all<span class="op">(</span>matrix<span class="op">,</span> dimension<span class="op">);</span> <span class="co">// dimension = 0 -&gt; returns a row vector urowvec/umat</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>                        <span class="co">// dimension = 1 -&gt; returns a column vector ucolvec/umat</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-3">Examples<a class="anchor" aria-label="anchor" href="#examples-3"></a>
</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">all1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  vec V<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>  <span class="co">// true if vector V has all non-zero elements</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  <span class="dt">bool</span> status1 <span class="op">=</span> all<span class="op">(</span>V<span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>  <span class="co">// true if vector V has all elements greater than 0.5</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>  <span class="dt">bool</span> status2 <span class="op">=</span> all<span class="op">(</span>V <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>  <span class="co">// true if matrix X has all elements greater than 0.6;</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>  <span class="co">// note the use of vectorise()</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>  <span class="dt">bool</span> status3 <span class="op">=</span> all<span class="op">(</span>vectorise<span class="op">(</span>X<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">0.6</span><span class="op">);</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>  <span class="co">// row vector indicating which columns of X have all elements greater than 0.7</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>  umat A <span class="op">=</span> all<span class="op">(</span>X <span class="op">&gt;</span> <span class="fl">0.7</span><span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> status1<span class="op">;</span></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> status2<span class="op">;</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> status3<span class="op">;</span></span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> all<span class="op">(</span>vectorise<span class="op">(</span>A<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// true if all elements of A are 1</span></span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="any">Check whether any element is non-zero, or satisfies a relational
condition<a class="anchor" aria-label="anchor" href="#any"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/any.html" class="external-link">any()</a></code> function checks whether any element in a
vector, matrix or cube is non-zero, or satisfies a relational condition.
It returns true/false booleans for vectors and 0/1 vectors for matrices
to indicate if the condition is met for any row or column.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>any<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>any<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>any<span class="op">(</span>matrix<span class="op">,</span> dimension<span class="op">);</span> <span class="co">// dimension = 0 -&gt; returns a row vector urowvec/umat</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>                        <span class="co">// dimension = 1 -&gt; returns a column vector ucolvec/umat</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-4">Examples<a class="anchor" aria-label="anchor" href="#examples-4"></a>
</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> logicals <span class="va">any1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  vec V<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  <span class="co">// true if vector V has any non-zero elements</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>  <span class="dt">bool</span> status1 <span class="op">=</span> any<span class="op">(</span>V<span class="op">);</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>  <span class="co">// true if vector V has any elements greater than 0.5</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>  <span class="dt">bool</span> status2 <span class="op">=</span> any<span class="op">(</span>V <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>  <span class="co">// true if matrix X has any elements greater than 0.6;</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>  <span class="co">// note the use of vectorise()</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>  <span class="dt">bool</span> status3 <span class="op">=</span> any<span class="op">(</span>vectorise<span class="op">(</span>X<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">0.6</span><span class="op">);</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>  <span class="co">// row vector indicating which columns of X have any elements greater than 0.7</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>  umat A <span class="op">=</span> any<span class="op">(</span>X <span class="op">&gt;</span> <span class="fl">0.7</span><span class="op">);</span></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>  writable<span class="op">::</span>logicals res<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> status1<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> status2<span class="op">;</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> status3<span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> any<span class="op">(</span>vectorise<span class="op">(</span>A<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// true if any element of A is 1</span></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="approx_equal">Approximate equality<a class="anchor" aria-label="anchor" href="#approx_equal"></a>
</h2>
<p>The <code>approx_equal()</code> function checks whether two vectors,
matrices or cubes are approximately equal. It returns true if all
corresponding elements have differences less than or equal to a given
tolerance.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>approx_equal<span class="op">(</span>A<span class="op">,</span> B<span class="op">,</span> method<span class="op">,</span> tol<span class="op">)</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>approx_equal<span class="op">(</span>A<span class="op">,</span> B<span class="op">,</span> method<span class="op">,</span> abs_tol<span class="op">,</span> rel_tol<span class="op">)</span></span></code></pre></div>
<p>The <code>method</code> parameter specifies the method used to
compare the elements:</p>
<ul>
<li>
<code>method = "absdiff"</code>: absolute difference (e.g.,
<code>|A - B| &lt;= tol</code>)</li>
<li>
<code>method = "reldiff"</code>: relative difference (e.g.,
<code>|A - B| / max(|A|, |B|) &lt;= tol</code>)</li>
<li>
<code>method = "both"</code>: absolute or relative difference (e.g.,
<code>|A - B| &lt;= tol || |A - B| / max(|A|, |B|) &lt;= tol</code>)</li>
</ul>
<div class="section level3">
<h3 id="examples-5">Examples<a class="anchor" aria-label="anchor" href="#examples-5"></a>
</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> <span class="dt">bool</span> <span class="va">approx_equal1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  mat B <span class="op">=</span> A <span class="op">+</span> <span class="fl">0.001</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>  <span class="dt">bool</span> same1 <span class="op">=</span> approx_equal<span class="op">(</span>A<span class="op">,</span> B<span class="op">,</span> <span class="st">"absdiff"</span><span class="op">,</span> <span class="fl">0.002</span><span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>  mat C <span class="op">=</span> <span class="dv">1000</span> <span class="op">*</span> randu<span class="op">&lt;</span>mat<span class="op">&gt;(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>  mat D <span class="op">=</span> C <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>  <span class="dt">bool</span> same2 <span class="op">=</span> approx_equal<span class="op">(</span>C<span class="op">,</span> D<span class="op">,</span> <span class="st">"reldiff"</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a>  <span class="dt">bool</span> same3 <span class="op">=</span> approx_equal<span class="op">(</span>C<span class="op">,</span> D<span class="op">,</span> <span class="st">"both"</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a>  <span class="dt">bool</span> all_same <span class="op">=</span> same1 <span class="op">&amp;&amp;</span> same2 <span class="op">&amp;&amp;</span> same3<span class="op">;</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a>  <span class="cf">return</span> all_same<span class="op">;</span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="arg">Phase angle of each element<a class="anchor" aria-label="anchor" href="#arg"></a>
</h2>
<p>The <code>arg()</code> function computes the phase angle of each
element in a vector, matrix or cube. For non-complex elements, the input
is treated as a complex element with zero imaginary component. For
complex elements, the input must be of the same and the output the real
counterpart type.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="dt">real_object_type</span> Y <span class="op">=</span> arg<span class="op">(</span>X<span class="op">);</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-6">Examples<a class="anchor" aria-label="anchor" href="#examples-6"></a>
</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">arg1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  cx_mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>  mat Y <span class="op">=</span> arg<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>Y<span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="as_scalar">Convert 1x1 matrix to pure scalar<a class="anchor" aria-label="anchor" href="#as_scalar"></a>
</h2>
<p>The <code>as_scalar()</code> function converts a 1x1 matrix to a
scalar (e.g., <code>double/int</code>). It is useful when you want to
extract a single element from a matrix or an operation (e.g., converting
the result of a dot/inner product to a scalar).</p>
<div class="section level3">
<h3 id="examples-7">Examples<a class="anchor" aria-label="anchor" href="#examples-7"></a>
</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> <span class="dt">double</span> <span class="va">as_scalar1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  rowvec r<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  colvec q<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  <span class="co">// examples of expressions which have optimised implementations</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  <span class="dt">double</span> a <span class="op">=</span> as_scalar<span class="op">(</span>r<span class="op">*</span>q<span class="op">);</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>  <span class="dt">double</span> b <span class="op">=</span> as_scalar<span class="op">(</span>r<span class="op">*</span>X<span class="op">*</span>q<span class="op">);</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>  <span class="dt">double</span> c <span class="op">=</span> as_scalar<span class="op">(</span>r<span class="op">*</span>diagmat<span class="op">(</span>X<span class="op">)*</span>q<span class="op">);</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>  <span class="dt">double</span> d <span class="op">=</span> as_scalar<span class="op">(</span>r<span class="op">*</span>inv<span class="op">(</span>diagmat<span class="op">(</span>X<span class="op">))*</span>q<span class="op">);</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>a <span class="op">+</span> b <span class="op">+</span> c <span class="op">+</span> d<span class="op">);</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="clamp">Obtain clamped elements according to given limits<a class="anchor" aria-label="anchor" href="#clamp"></a>
</h2>
<p>The <code>clamp()</code> function clamps each element in a vector,
matrix or cube to a given range. Any value less than the lower limit is
set to the lower limit, and any value greater than the upper limit is
set to the upper limit.</p>
<p>For objects with complex elements, the real and imaginary components
are clamped separately.</p>
<p>If the input is a sparse matrix, only the non-zero elements are
clamped.</p>
<div class="section level3">
<h3 id="example">Example<a class="anchor" aria-label="anchor" href="#example"></a>
</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">clamp1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  mat B <span class="op">=</span> clamp<span class="op">(</span>A<span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>  mat C <span class="op">=</span> clamp<span class="op">(</span>A<span class="op">,</span> A<span class="op">.</span>min<span class="op">(),</span> <span class="fl">0.8</span><span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>  mat D <span class="op">=</span> clamp<span class="op">(</span>A<span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> A<span class="op">.</span>max<span class="op">());</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>  mat res <span class="op">=</span> B <span class="op">+</span> C <span class="op">+</span> D<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cond">Condition number of matrix<a class="anchor" aria-label="anchor" href="#cond"></a>
</h2>
<p>The <code>cond()</code> function computes the condition number of a
matrix. The condition number is the ratio of the largest singular value
to the smallest singular value. It is a measure of how well the matrix
can be inverted, a matrix with a value close to 1 is well-conditioned,
and a matrix with a large value is ill-conditioned. The computation is
based on the singular value decomposition.</p>
<div class="section level3">
<h3 id="examples-8">Examples<a class="anchor" aria-label="anchor" href="#examples-8"></a>
</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> <span class="dt">double</span> <span class="va">cond1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>  A<span class="op">.</span>eye<span class="op">();</span> <span class="co">// the identity matrix has a condition number of 1</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>  <span class="dt">double</span> cond_num <span class="op">=</span> cond<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>  <span class="cf">return</span> cond_num<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat">Caveat<a class="anchor" aria-label="anchor" href="#caveat"></a>
</h3>
<p>Calculating the approximate reciprocal condition number via
<code><a href="https://rdrr.io/r/base/kappa.html" class="external-link">rcond()</a></code> is considerably more efficient.</p>
</div>
</div>
<div class="section level2">
<h2 id="conj">Obtain complex conjugate of each element<a class="anchor" aria-label="anchor" href="#conj"></a>
</h2>
<p>The <code>conj()</code> function computes the complex conjugate of
each element in a complex matrix or cube.</p>
<div class="section level3">
<h3 id="examples-9">Examples<a class="anchor" aria-label="anchor" href="#examples-9"></a>
</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">conj1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  cx_mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>  cx_mat Y <span class="op">=</span> conj<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>  <span class="cf">return</span> as_complex_matrix<span class="op">(</span>Y<span class="op">);</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="conv_to">Convert/cast between matrix types<a class="anchor" aria-label="anchor" href="#conv_to"></a>
</h2>
<p>The <code>conv_to()</code> function converts a matrix or cube to a
different type. It can convert <code>mat</code> to <code>imat</code>,
<code>cube</code> to <code>icube</code>, <code>mat</code> into
<code>colvec</code> or any other casting that preserves data (e.g., a
matrix that cannot be interpreted as a vector is not a valid casting).
It can also be used to convert a matrix/vector into a
<code>std::vector</code> object.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>conv_to<span class="op">&lt;</span>type<span class="op">&gt;::</span>from<span class="op">(</span>X<span class="op">)</span> </span></code></pre></div>
<div class="section level3">
<h3 id="examples-10">Examples<a class="anchor" aria-label="anchor" href="#examples-10"></a>
</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">conv_to1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>  fmat B <span class="op">=</span> conv_to<span class="op">&lt;</span>fmat<span class="op">&gt;::</span>from<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>B<span class="op">.</span>n_elem<span class="op">);</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>  <span class="dt">int</span> i<span class="op">,</span> N <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>B<span class="op">.</span>n_elem<span class="op">);</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> B<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>  colvec y <span class="op">=</span> conv_to<span class="op">&lt;</span>colvec<span class="op">&gt;::</span>from<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> z <span class="op">=</span> conv_to<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;::</span>from<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>z<span class="op">);</span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-1">Caveat<a class="anchor" aria-label="anchor" href="#caveat-1"></a>
</h3>
<p>To convert an expression that results in a 1x1 matrix to a pure
scalar value, use <code>as_scalar()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="cross">Cross product<a class="anchor" aria-label="anchor" href="#cross"></a>
</h2>
<p>The <code>cross()</code> function computes the cross product of two
vectors under the assumption that the vectors are three-dimensional.</p>
<div class="section level3">
<h3 id="examples-11">Examples<a class="anchor" aria-label="anchor" href="#examples-11"></a>
</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">cross1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>  vec A<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>  vec B<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>  vec C <span class="op">=</span> cross<span class="op">(</span>A<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cumsum">Cumulative sum<a class="anchor" aria-label="anchor" href="#cumsum"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cumsum()</a></code> function computes the cumulative sum of
elements in a vector or matrix. For a vector, it returns a vector of the
same orientation. For a matrix, it returns a matrix with the cumulative
sum along the specified dimension (the default is along columns with
<code>dimension = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>cumsum<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>cumsum<span class="op">(</span>matrix<span class="op">,</span> dimension<span class="op">);</span> <span class="co">// dimension = 0 -&gt; cumulative sum along columns</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>                           <span class="co">// dimension = 1 -&gt; cumulative sum along rows</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-12">Examples<a class="anchor" aria-label="anchor" href="#examples-12"></a>
</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">cumsum1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  mat B <span class="op">=</span> cumsum<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>  mat C <span class="op">=</span> cumsum<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>  vec x<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>  vec y <span class="op">=</span> cumsum<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>  writable<span class="op">::</span>doubles res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> accu<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> accu<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> accu<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>  </span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="cumprod">Cumulative product<a class="anchor" aria-label="anchor" href="#cumprod"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cumprod()</a></code> function computes the cumulative product
of elements in a vector or matrix. For a vector, it returns a vector of
the same orientation. For a matrix, it returns a matrix with the
cumulative product along the specified dimension (the default is along
columns with <code>dimension = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>cumprod<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>cumprod<span class="op">(</span>matrix<span class="op">,</span> dimension<span class="op">);</span> <span class="co">// dimension = 0 -&gt; cumulative prod along columns</span></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>                            <span class="co">// dimension = 1 -&gt; cumulative prod along rows</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-13">Examples<a class="anchor" aria-label="anchor" href="#examples-13"></a>
</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">cumprod1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>  mat B <span class="op">=</span> cumprod<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>  mat C <span class="op">=</span> cumprod<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>  vec x<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  vec y <span class="op">=</span> cumprod<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>  writable<span class="op">::</span>doubles res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> accu<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> accu<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> accu<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a>  </span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="det">Determinant<a class="anchor" aria-label="anchor" href="#det"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/det.html" class="external-link">det()</a></code> function computes the determinant of a square
matrix. It is based on the LU decomposition. If the input is a not a
square matrix, the function throws a <code>std::runtime_error</code>
exception.</p>
<p>Usage:</p>
<pre><code>val = det(X); // store a scalar
det(val, A); // store the determinant in val and return true if successful</code></pre>
<p>If the calculation fails:</p>
<ul>
<li>
<code>val = det(A)</code> throws a <code>std::runtime_error</code>
exception</li>
<li>
<code>det(val,A)</code> returns a bool set to false (exception is
not thrown)</li>
</ul>
<div class="section level3">
<h3 id="examples-14">Examples<a class="anchor" aria-label="anchor" href="#examples-14"></a>
</h3>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">det1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>  <span class="dt">double</span> val1 <span class="op">=</span> det<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>  <span class="dt">double</span> val2<span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>  mat B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>  <span class="dt">bool</span> success2 <span class="op">=</span> det<span class="op">(</span>val2<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>doubles<span class="op">({</span>val1<span class="op">,</span> val2<span class="op">,</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>success2<span class="op">)});</span></span>
<span id="cb27-10"><a href="#cb27-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diagmat">Generate diagonal matrix from given matrix or vector<a class="anchor" aria-label="anchor" href="#diagmat"></a>
</h2>
<p>The <code>diagmat()</code> function generates a diagonal matrix from
a given vector or matrix. If the input is a vector, the output is a
square matrix with the vector as the diagonal. If the input is a matrix,
the output is a square matrix with the diagonal elements from the input
matrix. Any element outside the diagonal is set to zero. The default is
the main diagonal (<code>k = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>diagmat<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>diagmat<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>diagmat<span class="op">(</span>matrix<span class="op">,</span> k<span class="op">);</span> <span class="co">// k = 0 -&gt; main diagonal</span></span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>                    <span class="co">// k &gt; 0 -&gt; above main diagonal</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>                    <span class="co">// k &lt; 0 -&gt; below main diagonal</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-15">Examples<a class="anchor" aria-label="anchor" href="#examples-15"></a>
</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">diagmat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>  mat B <span class="op">=</span> diagmat<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>  mat C <span class="op">=</span> diagmat<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>  vec v<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>  mat D <span class="op">=</span> diagmat<span class="op">(</span>v<span class="op">);</span> <span class="co">// NxN diagonal matrix</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>  mat E <span class="op">=</span> diagmat<span class="op">(</span>v<span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// (N+1)x(N+1) diagonal matrix</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>  mat res <span class="op">=</span> B <span class="op">+</span> C <span class="op">+</span> D<span class="op">;</span>  </span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a>  res <span class="op">+=</span> E<span class="op">.</span>submat<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// the result is an upper triangular matrix</span></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diagvec">Extract specified diagonal<a class="anchor" aria-label="anchor" href="#diagvec"></a>
</h2>
<p>The <code>diagvec()</code> function extracts the specified diagonal
from a matrix. The default is the main diagonal
(<code>k = 0</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>diagvec<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>diagvec<span class="op">(</span>matrix<span class="op">,</span> k<span class="op">);</span> <span class="co">// k = 0 -&gt; main diagonal</span></span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>                    <span class="co">// k &gt; 0 -&gt; above main diagonal</span></span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>                    <span class="co">// k &lt; 0 -&gt; below main diagonal</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-16">Examples<a class="anchor" aria-label="anchor" href="#examples-16"></a>
</h3>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">diagvec1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>  vec B <span class="op">=</span> diagvec<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>  vec C <span class="op">=</span> diagvec<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>  vec res <span class="op">=</span> B<span class="op">.</span>subvec<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> C<span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>res<span class="op">);</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diags">Generate a dense matrix with diagonals specified by column
vectors<a class="anchor" aria-label="anchor" href="#diags"></a>
</h2>
<p>The <code>diags()</code> function generates a dense matrix with
diagonals specified by column vectors from an input matrix and a vector
to indicate the diagonals.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>diags<span class="op">(</span>matrix<span class="op">,</span> vector<span class="op">,</span> number_of_rows<span class="op">,</span> number_of_columns<span class="op">);</span></span></code></pre></div>
<p>Each element in the input vector specifies diagonal <code>k</code>,
where:</p>
<ul>
<li>
<code>k = 0</code> is the main diagonal</li>
<li>
<code>k &gt; 0</code> is above the main diagonal</li>
<li>
<code>k &lt; 0</code> is below the main diagonal</li>
</ul>
<div class="section level3">
<h3 id="examples-17">Examples<a class="anchor" aria-label="anchor" href="#examples-17"></a>
</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">diags1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>  mat V<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>  ivec D <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>  mat X <span class="op">=</span> diags<span class="op">(</span>V<span class="op">,</span> D<span class="op">,</span> n<span class="op">,</span> n<span class="op">);</span> <span class="co">// lower triangular matrix</span></span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="diff">Differences between adjacent elements<a class="anchor" aria-label="anchor" href="#diff"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff()</a></code> function computes the differences between
adjacent elements in a vector or matrix. For a vector, the output is a
vector of length <code>n-k</code> (the default is <code>k = 1</code>).
For a matrix, the output is a matrix with <code>n-k</code> rows when
<code>dim = 0</code> (the default) and <code>m-k</code> columns when
<code>dim = 1</code>. If <code>k</code> is greater than the length of
the vector or the number or rows/columns, the output is an empty
vector/matrix.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>diff<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>diff<span class="op">(</span>vector<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>diff<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a>diff<span class="op">(</span>matrix<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>diff<span class="op">(</span>matrix<span class="op">,</span> k<span class="op">,</span> dim<span class="op">);</span> <span class="co">// dim = 0 -&gt; differences along columns</span></span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a>                      <span class="co">// dim = 1 -&gt; differences along rows</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-18">Examples<a class="anchor" aria-label="anchor" href="#examples-18"></a>
</h3>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">diff1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>  vec a <span class="op">=</span> randu<span class="op">&lt;</span>vec<span class="op">&gt;(</span>n<span class="op">);</span></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>  vec b <span class="op">=</span> diff<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>  mat res<span class="op">(</span>n<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>  </span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a>  res<span class="op">.</span>col<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-10"><a href="#cb35-10" tabindex="-1"></a>    res<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">=</span> b<span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb35-11"><a href="#cb35-11" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb35-12"><a href="#cb35-12" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>res<span class="op">);</span></span>
<span id="cb35-14"><a href="#cb35-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="dot">Dot product<a class="anchor" aria-label="anchor" href="#dot"></a>
</h2>
<p>The <code>dot()</code>, <code>cdot()</code>, and
<code>norm_dot()</code> functions compute the dot product of two
vectors. The <code>cdot()</code> function computes the complex conjugate
dot product, and the <code>norm_dot()</code> function computes the dot
product and normalises the result by the product of the Euclidean norms
of the input vectors.</p>
<div class="section level3">
<h3 id="examples-19">Examples<a class="anchor" aria-label="anchor" href="#examples-19"></a>
</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">dot1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>  vec A<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>  vec B<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>doubles<span class="op">({</span>dot<span class="op">(</span>A<span class="op">,</span> B<span class="op">),</span> cdot<span class="op">(</span>A<span class="op">,</span> B<span class="op">),</span> norm_dot<span class="op">(</span>A<span class="op">,</span> B<span class="op">)});</span></span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-2">Caveat<a class="anchor" aria-label="anchor" href="#caveat-2"></a>
</h3>
<p><code><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm()</a></code> is more robust for calculating the norm, as it
handles underflows and overflows.</p>
</div>
</div>
<div class="section level2">
<h2 id="eps">Obtain distance of each element to next largest floating point
representation<a class="anchor" aria-label="anchor" href="#eps"></a>
</h2>
<p>The <code>eps()</code> function computes the distance of each element
in a scalar, vector or matrix to the next largest floating point
representation. For vector input, the output is a vector of the same
orientation and length. For matrix input, the output is a matrix of the
same dimensions.</p>
<div class="section level3">
<h3 id="examples-20">Examples<a class="anchor" aria-label="anchor" href="#examples-20"></a>
</h3>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">eps1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>  mat B <span class="op">=</span> eps<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="expmat">Matrix exponential<a class="anchor" aria-label="anchor" href="#expmat"></a>
</h2>
<p>The <code>expmat()</code> function computes the matrix exponential of
a square matrix. If the matrix exponential cannot be computed, the
function throws a <code>std::runtime_error</code>, same if the input is
not a square matrix.</p>
<div class="section level3">
<h3 id="examples-21">Examples<a class="anchor" aria-label="anchor" href="#examples-21"></a>
</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">expmat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>  mat B <span class="op">=</span> expmat<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats">Caveats<a class="anchor" aria-label="anchor" href="#caveats"></a>
</h3>
<ul>
<li>The matrix exponential operation is generally not the same as
applying the <code><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp()</a></code> function to each element.</li>
<li>If the input matrix is symmetric, <code>expmat_sym()</code> is
faster.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="expmat_sym">Matrix exponential of symmetric matrix<a class="anchor" aria-label="anchor" href="#expmat_sym"></a>
</h2>
<p>The <code>expmat_sym()</code> function computes the matrix
exponential of a symmetric or Hermitian matrix. If the matrix
exponential cannot be computed, the function throws a
<code>std::runtime_error</code>, same if the input is not a square
matrix.</p>
<div class="section level3">
<h3 id="examples-22">Examples<a class="anchor" aria-label="anchor" href="#examples-22"></a>
</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">expmat_sym1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>  A <span class="op">=</span> A <span class="op">+</span> A<span class="op">.</span>t<span class="op">();</span> <span class="co">// make A symmetric</span></span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>  mat B <span class="op">=</span> expmat_sym<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="find">Find indices of non-zero elements, or elements satisfying a
relational condition<a class="anchor" aria-label="anchor" href="#find"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function returns the indices of non-zero
elements in a vector, or that satisfy a relational condition in a vector
or matrix. The output is a vector of indices (<code>uvec</code>).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>find<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>find<span class="op">(</span>vector<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>find<span class="op">(</span>vector<span class="op">,</span> k<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a>find<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a>find<span class="op">(</span>matrix<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a>find<span class="op">(</span>matrix<span class="op">,</span> k<span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<p>The parameter <code>k</code> (<code>k=0</code> by default) returns
the indices of all non-zero elements or elements that meet the
condition. The optional parameter <code>s = "first"</code> returns the
first <code>m</code> non-zero indices or indices that meet the
condition, and <code>s = "last"</code> returns the last <code>m</code>
non-zero indices or indices that meet the condition.</p>
<div class="section level3">
<h3 id="examples-23">Examples<a class="anchor" aria-label="anchor" href="#examples-23"></a>
</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">find1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a>  mat B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb41-4"><a href="#cb41-4" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" tabindex="-1"></a>  uvec q1 <span class="op">=</span> find<span class="op">(</span>A <span class="op">&gt;</span> B<span class="op">);</span></span>
<span id="cb41-6"><a href="#cb41-6" tabindex="-1"></a>  uvec q2 <span class="op">=</span> find<span class="op">(</span>A <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb41-7"><a href="#cb41-7" tabindex="-1"></a>  uvec q3 <span class="op">=</span> find<span class="op">(</span>A <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="st">"last"</span><span class="op">);</span></span>
<span id="cb41-8"><a href="#cb41-8" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" tabindex="-1"></a>  <span class="co">// change elements of A greater than 0.5 to 1</span></span>
<span id="cb41-10"><a href="#cb41-10" tabindex="-1"></a>  A<span class="op">.</span>elem<span class="op">(</span>find<span class="op">(</span>A <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">)).</span>ones<span class="op">();</span></span>
<span id="cb41-11"><a href="#cb41-11" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>list<span class="op">(</span>as_integers<span class="op">(</span>q1<span class="op">),</span> as_integers<span class="op">(</span>q2<span class="op">),</span> as_integers<span class="op">(</span>q3<span class="op">));</span></span>
<span id="cb41-13"><a href="#cb41-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-1">Caveats<a class="anchor" aria-label="anchor" href="#caveats-1"></a>
</h3>
<ul>
<li>To clamp values to an interval, <code>clamp()</code> is more
efficient.</li>
<li>To replace a specific value, <code>.replace()</code> is more
efficient.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="find_finite">Find indices of finite elements<a class="anchor" aria-label="anchor" href="#find_finite"></a>
</h2>
<p>The <code>find_finite()</code> function returns the indices of finite
elements in a vector or matrix. The output is a vector of indices
(<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-24">Examples<a class="anchor" aria-label="anchor" href="#examples-24"></a>
</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">find_finite1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a>  uvec q <span class="op">=</span> find_finite<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb42-4"><a href="#cb42-4" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>q<span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="find_nonfinite">Find indices of non-finite elements<a class="anchor" aria-label="anchor" href="#find_nonfinite"></a>
</h2>
<p>The <code>find_nonfinite()</code> function returns the indices of
non-finite elements in a vector or matrix. The output is a vector of
indices (<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-25">Examples<a class="anchor" aria-label="anchor" href="#examples-25"></a>
</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">find_nonfinite1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> datum<span class="op">::</span>inf<span class="op">;</span></span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a>  uvec q <span class="op">=</span> find_nonfinite<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>q<span class="op">);</span></span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-3">Caveat<a class="anchor" aria-label="anchor" href="#caveat-3"></a>
</h3>
<p>To replace instances of a specific non-finite value (eg.
<code>NaN</code> or <code>Inf</code>), it is more efficient to use
<code>.replace()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="find_nan">Find indices of NaN elements<a class="anchor" aria-label="anchor" href="#find_nan"></a>
</h2>
<p>The <code>find_nan()</code> function returns the indices of NaN
elements in a vector or matrix. The output is a vector of indices
(<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-26">Examples<a class="anchor" aria-label="anchor" href="#examples-26"></a>
</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">find_nan1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> datum<span class="op">::</span>nan<span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>  uvec q <span class="op">=</span> find_nan<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>q<span class="op">);</span></span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-4">Caveat<a class="anchor" aria-label="anchor" href="#caveat-4"></a>
</h3>
<p>To replace instances of <code>NaN</code> values, it is more efficient
to use <code>.replace()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="find_unique">Find indices of unique elements<a class="anchor" aria-label="anchor" href="#find_unique"></a>
</h2>
<p>The <code>find_unique()</code> function returns the indices of unique
elements in a vector or matrix. The output is a vector of indices
(<code>uvec</code>).</p>
<div class="section level3">
<h3 id="examples-27">Examples<a class="anchor" aria-label="anchor" href="#examples-27"></a>
</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">find_unique1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a>  uvec q <span class="op">=</span> find_unique<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb45-5"><a href="#cb45-5" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>q<span class="op">);</span></span>
<span id="cb45-6"><a href="#cb45-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="fliplr">Flip matrix left to right or upside down<a class="anchor" aria-label="anchor" href="#fliplr"></a>
</h2>
<p>The <code>fliplr()</code> function generates a copy of the input
matrix with the order of the columns reversed, and the
<code>flipud()</code> function generates a copy of the input matrix with
the order of the rows reversed.</p>
<div class="section level3">
<h3 id="examples-28">Examples<a class="anchor" aria-label="anchor" href="#examples-28"></a>
</h3>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">flip1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a>  mat B <span class="op">=</span> fliplr<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a>  mat C <span class="op">=</span> flipud<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb46-7"><a href="#cb46-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb46-8"><a href="#cb46-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb46-9"><a href="#cb46-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb46-10"><a href="#cb46-10" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="imag">Extract imaginary/real part<a class="anchor" aria-label="anchor" href="#imag"></a>
</h2>
<p>The <code>imag()</code> and <code>real()</code> functions extract the
imaginary and real parts of each element in a complex matrix,
respectively.</p>
<div class="section level3">
<h3 id="examples-29">Examples<a class="anchor" aria-label="anchor" href="#examples-29"></a>
</h3>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">imag1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a>  cx_mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a>  mat Y <span class="op">=</span> imag<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a>  mat Z <span class="op">=</span> real<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb47-5"><a href="#cb47-5" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb47-7"><a href="#cb47-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>Y<span class="op">);</span></span>
<span id="cb47-8"><a href="#cb47-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>Z<span class="op">);</span></span>
<span id="cb47-9"><a href="#cb47-9" tabindex="-1"></a></span>
<span id="cb47-10"><a href="#cb47-10" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb47-11"><a href="#cb47-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-5">Caveat<a class="anchor" aria-label="anchor" href="#caveat-5"></a>
</h3>
<p>To convert a complex matrix to a list of real matrices, it is more
efficient to use <code>as_complex_matrix()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="ind2sub">Convert linear index to subscripts<a class="anchor" aria-label="anchor" href="#ind2sub"></a>
</h2>
<p>The <code>ind2sub()</code> function converts a linear index or vector
of indexes to subscripts. The output is a vector of indices
(<code>uvec</code>) if the input index is a scalar, and a matrix of
indices (<code>umat</code>) if the input index is a vector.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>uvec sub <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>X<span class="op">),</span> index<span class="op">)</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>uvec sub <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>n_rows<span class="op">,</span> n_cols<span class="op">),</span> index<span class="op">)</span></span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a>uvec sub <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>n_rows<span class="op">,</span> n_cols<span class="op">,</span> n_slices<span class="op">),</span> index<span class="op">)</span></span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a>umat sub <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>X<span class="op">),</span> vector_of_indices<span class="op">)</span></span>
<span id="cb48-6"><a href="#cb48-6" tabindex="-1"></a>umat sub <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>n_rows<span class="op">,</span> n_cols<span class="op">),</span> vector_of_indices<span class="op">)</span></span>
<span id="cb48-7"><a href="#cb48-7" tabindex="-1"></a>umat sub <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>n_rows<span class="op">,</span> n_cols<span class="op">,</span> n_slices<span class="op">),</span> vector_of_indices<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-30">Examples<a class="anchor" aria-label="anchor" href="#examples-30"></a>
</h3>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">ind2sub1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a>  mat M<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" tabindex="-1"></a>  uvec s <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>M<span class="op">),</span> n<span class="op">);</span></span>
<span id="cb49-5"><a href="#cb49-5" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" tabindex="-1"></a>  uvec indices <span class="op">=</span> find<span class="op">(</span>M <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb49-7"><a href="#cb49-7" tabindex="-1"></a>  umat t       <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>M<span class="op">),</span> indices<span class="op">);</span></span>
<span id="cb49-8"><a href="#cb49-8" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" tabindex="-1"></a>  cube Q<span class="op">(</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb49-10"><a href="#cb49-10" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" tabindex="-1"></a>  uvec u <span class="op">=</span> ind2sub<span class="op">(</span>size<span class="op">(</span>Q<span class="op">),</span> <span class="dv">8</span><span class="op">);</span></span>
<span id="cb49-12"><a href="#cb49-12" tabindex="-1"></a></span>
<span id="cb49-13"><a href="#cb49-13" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb49-14"><a href="#cb49-14" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_integers<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb49-15"><a href="#cb49-15" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_integers_matrix<span class="op">(</span>t<span class="op">);</span></span>
<span id="cb49-16"><a href="#cb49-16" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_integers<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb49-17"><a href="#cb49-17" tabindex="-1"></a></span>
<span id="cb49-18"><a href="#cb49-18" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb49-19"><a href="#cb49-19" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="index_min">Indices of extremum values<a class="anchor" aria-label="anchor" href="#index_min"></a>
</h2>
<p>The <code>index_min()</code> and <code>index_max()</code> functions
return the indices of the minimum and maximum values in a vector, matrix
or cube. For an input vector, the output is a scalar index
(<code>uword</code>). For an input matrix, the output is a vector of
indices (<code>uvec</code>) with row orientation for the argument
<code>dim = 0</code> (default) with the min/max for each column, and
column orientation for <code>dim = 1</code> with the min/max for each
row. For an input cube, the output is a cube of indices
(<code>ucube</code>) with the min/max for each sliceâ€™s columns when
<code>dim = 0</code>, the min/max for each sliceâ€™s rows when
<code>dim = 1</code>, and the min/max for each slice when
<code>dim = 2</code>. For complex objects, the absolute value is used to
compare the elements.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="co">// index_max is analogous</span></span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a>index_min<span class="op">(</span>vector<span class="op">)</span></span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a>index_min<span class="op">(</span>matrix<span class="op">)</span></span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a>index_min<span class="op">(</span>matrix<span class="op">,</span> dim<span class="op">)</span></span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" tabindex="-1"></a>index_min<span class="op">(</span>cube<span class="op">)</span></span>
<span id="cb50-9"><a href="#cb50-9" tabindex="-1"></a>index_min<span class="op">(</span>cube<span class="op">,</span> dim<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-31">Examples<a class="anchor" aria-label="anchor" href="#examples-31"></a>
</h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">index_min1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a>  vec v<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb51-3"><a href="#cb51-3" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" tabindex="-1"></a>  uword i <span class="op">=</span> index_max<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb51-5"><a href="#cb51-5" tabindex="-1"></a>  <span class="dt">double</span> max_val_in_v <span class="op">=</span> v<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb51-6"><a href="#cb51-6" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" tabindex="-1"></a>  mat M<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb51-9"><a href="#cb51-9" tabindex="-1"></a></span>
<span id="cb51-10"><a href="#cb51-10" tabindex="-1"></a>  urowvec ii <span class="op">=</span> index_max<span class="op">(</span>M<span class="op">);</span></span>
<span id="cb51-11"><a href="#cb51-11" tabindex="-1"></a>  ucolvec jj <span class="op">=</span> index_max<span class="op">(</span>M<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" tabindex="-1"></a>  <span class="co">// max values in col 0 and row n</span></span>
<span id="cb51-14"><a href="#cb51-14" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>doubles res<span class="op">({</span>M<span class="op">(</span>ii<span class="op">(</span><span class="dv">0</span><span class="op">),</span> <span class="dv">0</span><span class="op">),</span> M<span class="op">(</span>n<span class="op">,</span> jj<span class="op">(</span>n<span class="op">))});</span></span>
<span id="cb51-15"><a href="#cb51-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="inplace_trans">In-place dense transpose<a class="anchor" aria-label="anchor" href="#inplace_trans"></a>
</h2>
<p>The <code>inplace_trans()</code> and <code>inplace_strans()</code>
function return the in-place transpose of a dense matrix. For both
functions the optional <code>method = "lowmem"</code> argument uses a
low memory (and slower) algorithm for the transpose (the default is
<code>method = "std"</code>).</p>
<p>For real matrices:</p>
<ul>
<li>
<code>inplace_trans()</code> returns the common transpose of the
input matrix.</li>
<li>
<code>inplace_strans()</code> does not apply.</li>
</ul>
<p>For complex matrices:</p>
<ul>
<li>
<code>inplace_trans()</code> returns the Hermitian transpose
(conjugate transpose) of the input matrix.</li>
<li>
<code>inplace_strans()</code> returns the transposed copy without
taking the conjugate of the elements of the input matrix.</li>
</ul>
<div class="section level3">
<h3 id="examples-32">Examples<a class="anchor" aria-label="anchor" href="#examples-32"></a>
</h3>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">inplace_trans1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb52-3"><a href="#cb52-3" tabindex="-1"></a>  inplace_trans<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb52-4"><a href="#cb52-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb52-5"><a href="#cb52-5" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-6"><a href="#cb52-6" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">inplace_strans1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-8"><a href="#cb52-8" tabindex="-1"></a>  cx_mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb52-9"><a href="#cb52-9" tabindex="-1"></a>  inplace_strans<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb52-10"><a href="#cb52-10" tabindex="-1"></a>  <span class="cf">return</span> as_complex_matrix<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb52-11"><a href="#cb52-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="intersect">Find common elements in two vectors/matrices<a class="anchor" aria-label="anchor" href="#intersect"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/sets.html" class="external-link">intersect()</a></code> function returns the common elements for
two vectors or matrices. The output is an ascending sorted vector of
unique common elements.</p>
<div class="section level3">
<h3 id="examples-33">Examples<a class="anchor" aria-label="anchor" href="#examples-33"></a>
</h3>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">intersect1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a>  ivec A <span class="op">=</span> regspace<span class="op">&lt;</span>ivec<span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span>      <span class="co">// n, ..., 1</span></span>
<span id="cb53-3"><a href="#cb53-3" tabindex="-1"></a>  ivec B <span class="op">=</span> regspace<span class="op">&lt;</span>ivec<span class="op">&gt;(</span><span class="dv">2</span><span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// 2, ..., n + 1</span></span>
<span id="cb53-4"><a href="#cb53-4" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" tabindex="-1"></a>  ivec C <span class="op">=</span> intersect<span class="op">(</span>A<span class="op">,</span> B<span class="op">);</span>  <span class="co">// 2, ..., n</span></span>
<span id="cb53-6"><a href="#cb53-6" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb53-8"><a href="#cb53-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="join_rows">Concatenation of matrices<a class="anchor" aria-label="anchor" href="#join_rows"></a>
</h2>
<p>The <code>join_rows()</code> and <code>join_cols()</code> functions
concatenate matrices horizontally and vertically, respectively. The
input matrices must have the same number of rows for
<code>join_rows()</code> and the same number of columns for
<code>join_cols()</code>. Both functions accept from two to four
matrices as input.</p>
<p>Alternatively, <code>join_horiz()</code> and <code>join_vert()</code>
can be used as aliases for <code>join_rows()</code> and
<code>join_cols()</code>, respectively.</p>
<div class="section level3">
<h3 id="examples-34">Examples<a class="anchor" aria-label="anchor" href="#examples-34"></a>
</h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">join_rows1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a>  mat B<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a>  mat C<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a>  mat D <span class="op">=</span> join_rows<span class="op">(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">);</span></span>
<span id="cb54-7"><a href="#cb54-7" tabindex="-1"></a>  mat E <span class="op">=</span> join_cols<span class="op">(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">);</span></span>
<span id="cb54-8"><a href="#cb54-8" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>list<span class="op">({</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">,</span> D<span class="op">,</span> E<span class="op">});</span></span>
<span id="cb54-10"><a href="#cb54-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="join_slices">Concatenation of cubes<a class="anchor" aria-label="anchor" href="#join_slices"></a>
</h2>
<p>The <code>join_slices()</code> function concatenates cubes along the
third dimension. For two matrices, the input matrices must have the same
number of rows and columns. For two cubes, the input cubes must have the
same number of rows and columns. For matrix and cube, the number of rows
and columns of the matrix must match the number of rows and columns of
the cube.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a>join_slices<span class="op">(</span>matrix<span class="op">,</span> matrix<span class="op">)</span></span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a>join_slices<span class="op">(</span>cube<span class="op">,</span> cube<span class="op">);</span></span>
<span id="cb55-3"><a href="#cb55-3" tabindex="-1"></a>join_slices<span class="op">(</span>matrix<span class="op">,</span> cube<span class="op">);</span></span>
<span id="cb55-4"><a href="#cb55-4" tabindex="-1"></a>join_slices<span class="op">(</span>cube<span class="op">,</span> matrix<span class="op">);</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-35">Examples<a class="anchor" aria-label="anchor" href="#examples-35"></a>
</h3>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">join_cubes1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>  cube C<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a>  cube D<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" tabindex="-1"></a>  cube E <span class="op">=</span> join_slices<span class="op">(</span>C<span class="op">,</span> D<span class="op">);</span></span>
<span id="cb56-6"><a href="#cb56-6" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" tabindex="-1"></a>  <span class="dt">size_t</span> m <span class="op">=</span> C<span class="op">.</span>n_slices <span class="op">+</span> D<span class="op">.</span>n_slices<span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb56-10"><a href="#cb56-10" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-12"><a href="#cb56-12" tabindex="-1"></a>    res<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>E<span class="op">.</span>slice<span class="op">(</span>i<span class="op">));</span></span>
<span id="cb56-13"><a href="#cb56-13" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb56-14"><a href="#cb56-14" tabindex="-1"></a></span>
<span id="cb56-15"><a href="#cb56-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb56-16"><a href="#cb56-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="kron">Kronecker tensor product<a class="anchor" aria-label="anchor" href="#kron"></a>
</h2>
<p>The <code>kron()</code> function computes the Kronecker tensor
product of two matrices.</p>
<div class="section level3">
<h3 id="examples-36">Examples<a class="anchor" aria-label="anchor" href="#examples-36"></a>
</h3>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">kron1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a>  mat B<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" tabindex="-1"></a>  mat K <span class="op">=</span> kron<span class="op">(</span>A<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb57-6"><a href="#cb57-6" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>K<span class="op">);</span></span>
<span id="cb57-8"><a href="#cb57-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="log_det">Log determinant<a class="anchor" aria-label="anchor" href="#log_det"></a>
</h2>
<p>The <code>log_det()</code> function computes the natural logarithm of
the determinant of a square matrix based on LU decomposition. If the
matrix is not square or the computation fails, the function throws a
<code>std::runtime_error</code> exception.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a>complex val <span class="op">=</span> log_det<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>log_det<span class="op">(</span>val<span class="op">,</span> sign<span class="op">,</span> X<span class="op">);</span></span></code></pre></div>
<p>Form 1: <code>log_det(X)</code> returns the complex logarithm of the
determinant of <code>X</code>. If the input matrix is real, the
imaginary part of the result is zero.</p>
<p>Form 2: <code>log_det(val, sign, X)</code> returns a bool indicating
if the calculation was successful and stores the logarithm of the
determinant in the <code>val</code> and <code>sign</code> variables such
that <code>det(X) = sign * exp(val)</code>. If the computation fails,
the values of <code>val</code> and <code>sign</code> are undefined and
it returns <code>false</code> without throwing an exception.</p>
<div class="section level3">
<h3 id="examples-37">Examples<a class="anchor" aria-label="anchor" href="#examples-37"></a>
</h3>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">log_det1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>  cx_double res1 <span class="op">=</span> log_det<span class="op">(</span>A<span class="op">);</span>  <span class="co">// form 1</span></span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>  cpp11<span class="op">::</span>writable<span class="op">::</span>list res2<span class="op">;</span></span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>  res2<span class="op">.</span>push_back<span class="op">(</span>writable<span class="op">::</span>doubles<span class="op">({</span><span class="bu">std::</span>real<span class="op">(</span>res1<span class="op">)}));</span></span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a>  res2<span class="op">.</span>push_back<span class="op">(</span>writable<span class="op">::</span>doubles<span class="op">({</span><span class="bu">std::</span>imag<span class="op">(</span>res1<span class="op">)}));</span></span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" tabindex="-1"></a>  <span class="dt">double</span> val<span class="op">;</span></span>
<span id="cb59-11"><a href="#cb59-11" tabindex="-1"></a>  <span class="dt">double</span> sign<span class="op">;</span></span>
<span id="cb59-12"><a href="#cb59-12" tabindex="-1"></a>  <span class="dt">bool</span> ok <span class="op">=</span> log_det<span class="op">(</span>val<span class="op">,</span> sign<span class="op">,</span> A<span class="op">);</span>  <span class="co">// form 2</span></span>
<span id="cb59-13"><a href="#cb59-13" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" tabindex="-1"></a>  writable<span class="op">::</span>list res3<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb59-15"><a href="#cb59-15" tabindex="-1"></a>  res3<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> doubles<span class="op">({</span>val<span class="op">});</span></span>
<span id="cb59-16"><a href="#cb59-16" tabindex="-1"></a>  res3<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> doubles<span class="op">({</span>sign<span class="op">});</span></span>
<span id="cb59-17"><a href="#cb59-17" tabindex="-1"></a>  res3<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> logicals<span class="op">({</span>ok<span class="op">});</span></span>
<span id="cb59-18"><a href="#cb59-18" tabindex="-1"></a></span>
<span id="cb59-19"><a href="#cb59-19" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb59-20"><a href="#cb59-20" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> res2<span class="op">;</span></span>
<span id="cb59-21"><a href="#cb59-21" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> res3<span class="op">;</span></span>
<span id="cb59-22"><a href="#cb59-22" tabindex="-1"></a></span>
<span id="cb59-23"><a href="#cb59-23" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb59-24"><a href="#cb59-24" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="log_det_sympd">Log determinant of symmetric positive definite matrix<a class="anchor" aria-label="anchor" href="#log_det_sympd"></a>
</h2>
<p>The <code>log_det_sympd()</code> function computes the natural
logarithm of the determinant of a symmetric positive definite matrix. If
the matrix is not square or the computation fails, a
<code>std::runtime_error</code> exception is thrown.</p>
<p>Form 1: <code>log_det_sympd(X)</code> returns the logarithm of the
determinant of <code>X</code>.</p>
<p>Form 2: <code>log_det_sympd(val, X)</code> returns a bool indicating
if the calculation was successful and stores the logarithm of the
determinant in the <code>val</code> variable. If the computation fails,
the value of <code>val</code> is undefined and it returns
<code>false</code> without throwing an exception.</p>
<div class="section level3">
<h3 id="examples-38">Examples<a class="anchor" aria-label="anchor" href="#examples-38"></a>
</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">log_det_sympd1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>  A <span class="op">=</span> A <span class="op">*</span> A<span class="op">.</span>t<span class="op">();</span>  <span class="co">// make A symmetric positive definite</span></span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" tabindex="-1"></a>  <span class="dt">double</span> val <span class="op">=</span> log_det_sympd<span class="op">(</span>A<span class="op">);</span>  <span class="co">// form 1</span></span>
<span id="cb60-6"><a href="#cb60-6" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" tabindex="-1"></a>  <span class="dt">double</span> val2<span class="op">;</span></span>
<span id="cb60-8"><a href="#cb60-8" tabindex="-1"></a>  <span class="dt">bool</span> ok <span class="op">=</span> log_det_sympd<span class="op">(</span>val2<span class="op">,</span> A<span class="op">);</span>  <span class="co">// form 2</span></span>
<span id="cb60-9"><a href="#cb60-9" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb60-11"><a href="#cb60-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> doubles<span class="op">({</span>val<span class="op">});</span></span>
<span id="cb60-12"><a href="#cb60-12" tabindex="-1"></a></span>
<span id="cb60-13"><a href="#cb60-13" tabindex="-1"></a>  writable<span class="op">::</span>list res2<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb60-14"><a href="#cb60-14" tabindex="-1"></a>  res2<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> doubles<span class="op">({</span>val2<span class="op">});</span></span>
<span id="cb60-15"><a href="#cb60-15" tabindex="-1"></a>  res2<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> logicals<span class="op">({</span>ok<span class="op">});</span></span>
<span id="cb60-16"><a href="#cb60-16" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> res2<span class="op">;</span></span>
<span id="cb60-17"><a href="#cb60-17" tabindex="-1"></a></span>
<span id="cb60-18"><a href="#cb60-18" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb60-19"><a href="#cb60-19" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="logmat">Matrix logarithm<a class="anchor" aria-label="anchor" href="#logmat"></a>
</h2>
<p>The <code>logmat()</code> function computes the matrix logarithm of a
square matrix. If the input matrix is not square or the computation
fails, a <code>std::runtime_error</code> exception is thrown.</p>
<p>Form 1: <code>logmat(X)</code> returns the matrix logarithm of
<code>X</code>.</p>
<p>Form 2: <code>logmat(val, X)</code> returns a bool indicating if the
calculation was successful and stores the matrix logarithm in the
<code>val</code> variable. If the computation fails, the value of
<code>val</code> is undefined and it returns <code>false</code> without
throwing an exception.</p>
<div class="section level3">
<h3 id="examples-39">Examples<a class="anchor" aria-label="anchor" href="#examples-39"></a>
</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">logmat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb61-3"><a href="#cb61-3" tabindex="-1"></a>  cx_mat B <span class="op">=</span> logmat<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb61-4"><a href="#cb61-4" tabindex="-1"></a>  <span class="cf">return</span> as_complex_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb61-5"><a href="#cb61-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-2">Caveats<a class="anchor" aria-label="anchor" href="#caveats-2"></a>
</h3>
<ul>
<li>The matrix logarithm operation is generally not the same as applying
the <code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log()</a></code> function to each element.</li>
<li>If the input matrix is symmetric positive definite,
<code>logmat_sympd()</code> is faster.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="logmat_sympd">Matrix logarithm of symmetric matrix<a class="anchor" aria-label="anchor" href="#logmat_sympd"></a>
</h2>
<p>The <code>logmat_sympd()</code> function computes the matrix
logarithm of a symmetric positive definite matrix. If the input matrix
is not square or the computation fails, a
<code>std::runtime_error</code> exception is thrown.</p>
<p>Form 1: <code>logmat_sympd(X)</code> returns the matrix logarithm of
<code>X</code>.</p>
<p>Form 2: <code>logmat_sympd(Y, X)</code> returns a bool indicating if
the calculation was successful and stores the matrix logarithm in the
<code>Y</code> variable. If the computation fails, the value of
<code>Y</code> is undefined and it returns <code>false</code> without
throwing an exception.</p>
<div class="section level3">
<h3 id="examples-40">Examples<a class="anchor" aria-label="anchor" href="#examples-40"></a>
</h3>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">logmat_sympd1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a>  mat B <span class="op">=</span> A <span class="op">*</span> A<span class="op">.</span>t<span class="op">();</span>  <span class="co">// make symmetric matrix</span></span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a>  mat C <span class="op">=</span> logmat_sympd<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb62-5"><a href="#cb62-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb62-6"><a href="#cb62-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="min">Return extremum values<a class="anchor" aria-label="anchor" href="#min"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min()</a></code> and <code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max()</a></code> functions return the
minimum and maximum values in a vector, matrix or cube. For a vector,
the output is a scalar. For a matrix, the output is a vector with the
minimum or maximum value for each column when <code>dim = 0</code>
(default) and each row when <code>dim = 1</code>. For a cube, the output
is a cube with the minimum or maximum value for each sliceâ€™s columns
when <code>dim = 0</code>, the minimum or maximum value for each sliceâ€™s
rows when <code>dim = 1</code>, and the minimum or maximum value for
each slice when <code>dim = 2</code>. For complex objects, the absolute
value is used to compare the elements.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="co">// max() is analogous</span></span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" tabindex="-1"></a>min<span class="op">(</span>vector<span class="op">);</span></span>
<span id="cb63-4"><a href="#cb63-4" tabindex="-1"></a>min<span class="op">(</span>vector1<span class="op">,</span> vector2<span class="op">);</span></span>
<span id="cb63-5"><a href="#cb63-5" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" tabindex="-1"></a>min<span class="op">(</span>matrix<span class="op">);</span></span>
<span id="cb63-7"><a href="#cb63-7" tabindex="-1"></a>min<span class="op">(</span>matrix<span class="op">,</span> dim<span class="op">);</span></span>
<span id="cb63-8"><a href="#cb63-8" tabindex="-1"></a>min<span class="op">(</span>matrix1<span class="op">,</span> matrix2<span class="op">);</span></span>
<span id="cb63-9"><a href="#cb63-9" tabindex="-1"></a></span>
<span id="cb63-10"><a href="#cb63-10" tabindex="-1"></a>min<span class="op">(</span>cube<span class="op">);</span></span>
<span id="cb63-11"><a href="#cb63-11" tabindex="-1"></a>min<span class="op">(</span>cube<span class="op">,</span> dim<span class="op">);</span></span>
<span id="cb63-12"><a href="#cb63-12" tabindex="-1"></a>min<span class="op">(</span>cube1<span class="op">,</span> cube2<span class="op">);</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-41">Examples<a class="anchor" aria-label="anchor" href="#examples-41"></a>
</h3>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">max1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a>  mat M<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>  rowvec a <span class="op">=</span> max<span class="op">(</span>M<span class="op">);</span></span>
<span id="cb64-5"><a href="#cb64-5" tabindex="-1"></a>  rowvec b <span class="op">=</span> max<span class="op">(</span>M<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb64-6"><a href="#cb64-6" tabindex="-1"></a>  colvec c <span class="op">=</span> max<span class="op">(</span>M<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb64-7"><a href="#cb64-7" tabindex="-1"></a></span>
<span id="cb64-8"><a href="#cb64-8" tabindex="-1"></a>  <span class="co">// element-wise maximum</span></span>
<span id="cb64-9"><a href="#cb64-9" tabindex="-1"></a>  mat X<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb64-10"><a href="#cb64-10" tabindex="-1"></a>  mat Y<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb64-11"><a href="#cb64-11" tabindex="-1"></a>  mat Z <span class="op">=</span> arma<span class="op">::</span>max<span class="op">(</span>X<span class="op">,</span> Y<span class="op">);</span>  <span class="co">// use arma:: prefix to distinguish from std::max()</span></span>
<span id="cb64-12"><a href="#cb64-12" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb64-14"><a href="#cb64-14" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>a<span class="op">.</span>t<span class="op">());</span></span>
<span id="cb64-15"><a href="#cb64-15" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>b<span class="op">.</span>t<span class="op">());</span></span>
<span id="cb64-16"><a href="#cb64-16" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb64-17"><a href="#cb64-17" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>Z<span class="op">);</span></span>
<span id="cb64-18"><a href="#cb64-18" tabindex="-1"></a></span>
<span id="cb64-19"><a href="#cb64-19" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb64-20"><a href="#cb64-20" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="nonzeros">Return non-zero values<a class="anchor" aria-label="anchor" href="#nonzeros"></a>
</h2>
<p>The <code>nonzeros()</code> function returns the non-zero values in a
vector, matrix or cube. The output is a column vector of non-zero values
(<code>vec</code>). The input matrix can be dense or sparse.</p>
<div class="section level3">
<h3 id="examples-42">Examples<a class="anchor" aria-label="anchor" href="#examples-42"></a>
</h3>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">nonzeros1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a>  A<span class="op">.</span>elem<span class="op">(</span>find<span class="op">(</span>A <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)).</span>zeros<span class="op">();</span>  <span class="co">// set elements less than 0.5 to zero</span></span>
<span id="cb65-4"><a href="#cb65-4" tabindex="-1"></a>  vec B <span class="op">=</span> nonzeros<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb65-5"><a href="#cb65-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb65-6"><a href="#cb65-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-3">Caveats<a class="anchor" aria-label="anchor" href="#caveats-3"></a>
</h3>
<p>Caveats:</p>
<ul>
<li>For dense matrices/vectors, to obtain the number of non-zero
elements, the expression <code>accu(X != 0)</code> is more
efficient.</li>
<li>For sparse matrices, to obtain the number of non-zero elements,
<code>X.n_nonzero</code> is more efficient.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="norm">Various norms of vectors and matrices<a class="anchor" aria-label="anchor" href="#norm"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/norm.html" class="external-link">norm()</a></code> function computes the p-norm of a vector or
matrix. The optional argument <code>p</code> can be
<code>p = {1,...,n}</code>, <code>p = "inf</code>â€œ,
<code>p = "-inf"</code>, or <code>p = "fro"</code> for the
1,2,â€¦,n-norms, maximum norm, minimum quasi-norm, and Frobenius norm,
respectively. The default is the 2-norm for vectors and the Frobenius
norm for matrices.</p>
<div class="section level3">
<h3 id="examples-43">Examples<a class="anchor" aria-label="anchor" href="#examples-43"></a>
</h3>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">norm1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>  vec A<span class="op">(</span>n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>  mat B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a>  <span class="dt">double</span> a1 <span class="op">=</span> norm<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-6"><a href="#cb66-6" tabindex="-1"></a>  <span class="dt">double</span> a2 <span class="op">=</span> norm<span class="op">(</span>A<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb66-7"><a href="#cb66-7" tabindex="-1"></a>  <span class="dt">double</span> a3 <span class="op">=</span> norm<span class="op">(</span>A<span class="op">,</span> <span class="st">"inf"</span><span class="op">);</span></span>
<span id="cb66-8"><a href="#cb66-8" tabindex="-1"></a>  <span class="dt">double</span> a4 <span class="op">=</span> norm<span class="op">(</span>A<span class="op">,</span> <span class="st">"-inf"</span><span class="op">);</span></span>
<span id="cb66-9"><a href="#cb66-9" tabindex="-1"></a>  <span class="dt">double</span> a5 <span class="op">=</span> norm<span class="op">(</span>A<span class="op">,</span> <span class="st">"fro"</span><span class="op">);</span></span>
<span id="cb66-10"><a href="#cb66-10" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" tabindex="-1"></a>  <span class="dt">double</span> b1 <span class="op">=</span> norm<span class="op">(</span>B<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-12"><a href="#cb66-12" tabindex="-1"></a>  <span class="dt">double</span> b2 <span class="op">=</span> norm<span class="op">(</span>B<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb66-13"><a href="#cb66-13" tabindex="-1"></a>  <span class="dt">double</span> b3 <span class="op">=</span> norm<span class="op">(</span>B<span class="op">,</span> <span class="st">"inf"</span><span class="op">);</span></span>
<span id="cb66-14"><a href="#cb66-14" tabindex="-1"></a>  <span class="dt">double</span> b4 <span class="op">=</span> norm<span class="op">(</span>B<span class="op">,</span> <span class="st">"-inf"</span><span class="op">);</span></span>
<span id="cb66-15"><a href="#cb66-15" tabindex="-1"></a>  <span class="dt">double</span> b5 <span class="op">=</span> norm<span class="op">(</span>B<span class="op">,</span> <span class="st">"fro"</span><span class="op">);</span></span>
<span id="cb66-16"><a href="#cb66-16" tabindex="-1"></a></span>
<span id="cb66-17"><a href="#cb66-17" tabindex="-1"></a>  writable<span class="op">::</span>doubles res<span class="op">({</span>a1<span class="op">,</span> a2<span class="op">,</span> a3<span class="op">,</span> a4<span class="op">,</span> a5<span class="op">,</span> b1<span class="op">,</span> b2<span class="op">,</span> b3<span class="op">,</span> b4<span class="op">,</span> b5<span class="op">});</span></span>
<span id="cb66-18"><a href="#cb66-18" tabindex="-1"></a>  attr<span class="op">(</span>res<span class="op">,</span> <span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"a1"</span><span class="op">,</span> <span class="st">"a2"</span><span class="op">,</span> <span class="st">"a3"</span><span class="op">,</span> <span class="st">"a4"</span><span class="op">,</span> <span class="st">"a5"</span><span class="op">,</span></span>
<span id="cb66-19"><a href="#cb66-19" tabindex="-1"></a>    <span class="st">"b1"</span><span class="op">,</span> <span class="st">"b2"</span><span class="op">,</span> <span class="st">"b3"</span><span class="op">,</span> <span class="st">"b4"</span><span class="op">,</span> <span class="st">"b5"</span><span class="op">});</span></span>
<span id="cb66-20"><a href="#cb66-20" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-4">Caveats<a class="anchor" aria-label="anchor" href="#caveats-4"></a>
</h3>
<ul>
<li>The matrix 2-norm (spectral norm) is based on SVD, which is
computationally intensive. A faster alternative is
<code>norm2est()</code>.</li>
<li>To obtain the vector norm of each row or column of a matrix, use
<code>vecnorm()</code>.</li>
<li>To obtain the zero/Hamming pseudo-norm (number of non-zero
elements), use the expression <code>accu(X != 0)</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="norm2est">Fast estimate of the matrix 2-norm<a class="anchor" aria-label="anchor" href="#norm2est"></a>
</h2>
<p>The <code>norm2est()</code> function computes a fast estimate of the
2-norm of a matrix. The function iterates until
<code>|est1 - est2| / max(est1, est2) &lt; tol</code> or the number of
iterations is equal to <code>max_iter</code>. The default values are
<code>tol = 1e-5</code> and <code>max_iter = 100</code>.</p>
<div class="section level3">
<h3 id="examples-44">Examples<a class="anchor" aria-label="anchor" href="#examples-44"></a>
</h3>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">norm2est1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a>  <span class="cf">return</span> doubles<span class="op">({</span>norm2est<span class="op">(</span>A<span class="op">)});</span></span>
<span id="cb67-4"><a href="#cb67-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="normalise">Normalise vectors to unit p-norm<a class="anchor" aria-label="anchor" href="#normalise"></a>
</h2>
<p>The <code>normalise()</code> function normalises vectors or matrices
to a p-norm. The default is the 2-norm for vectors and matrices
(<code>p = 2</code>). For matrices, the optional <code>dim</code>
argument specifies the dimension along which to normalise the matrix,
with <code>dim = 0</code> normalising along columns and
<code>dim = 1</code> normalising along rows.</p>
<div class="section level3">
<h3 id="examples-45">Examples<a class="anchor" aria-label="anchor" href="#examples-45"></a>
</h3>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">normalise1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a>  mat B <span class="op">=</span> normalise<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a>  mat C <span class="op">=</span> normalise<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb68-6"><a href="#cb68-6" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb68-8"><a href="#cb68-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb68-9"><a href="#cb68-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb68-10"><a href="#cb68-10" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"B_norm1_cols"</span><span class="op">,</span> <span class="st">"C_norm1_rows"</span><span class="op">});</span></span>
<span id="cb68-12"><a href="#cb68-12" tabindex="-1"></a></span>
<span id="cb68-13"><a href="#cb68-13" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb68-14"><a href="#cb68-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="pow">Element-wise power<a class="anchor" aria-label="anchor" href="#pow"></a>
</h2>
<p>The <code>pow()</code> function computes the element-wise power of a
matrix or vector. The power argument can be a scalar, vector, or
matrix.</p>
<div class="section level3">
<h3 id="examples-46">Examples<a class="anchor" aria-label="anchor" href="#examples-46"></a>
</h3>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">pow1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>  mat B<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a></span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a>  mat C <span class="op">=</span> pow<span class="op">(</span>A<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb69-6"><a href="#cb69-6" tabindex="-1"></a>  mat D <span class="op">=</span> pow<span class="op">(</span>A<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb69-7"><a href="#cb69-7" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb69-9"><a href="#cb69-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb69-10"><a href="#cb69-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span></span>
<span id="cb69-11"><a href="#cb69-11" tabindex="-1"></a></span>
<span id="cb69-12"><a href="#cb69-12" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb69-13"><a href="#cb69-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-5">Caveats<a class="anchor" aria-label="anchor" href="#caveats-5"></a>
</h3>
<ul>
<li>To raise all elements to the power 2, use <code>square()</code>
instead.</li>
<li>For the matrix power operation, which takes into account matrix
structure, use <code>powmat()</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="powmat">Matrix power<a class="anchor" aria-label="anchor" href="#powmat"></a>
</h2>
<p>The <code>powmat()</code> function computes the matrix power of a
square matrix. The power argument must be a scalar (e.g.,
<code>double</code> or <code>int</code>). If the input matrix is not
square, the function throws a <code>std::runtime_error</code>
exception.</p>
<p>Usage:</p>
<pre><code>Y = powmat(X, 2); // store a matrix
powmat(Y, X, 2); // store the matrix in Y and return true if successful</code></pre>
<p>If the calculation fails:</p>
<ul>
<li>
<code>Y = powmat(X)</code> throws a <code>std::runtime_error</code>
exception.</li>
<li>
<code>powmat(Y, X, 2)</code> returns a bool set to false (exception
is not thrown).</li>
</ul>
<div class="section level3">
<h3 id="examples-47">Examples<a class="anchor" aria-label="anchor" href="#examples-47"></a>
</h3>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">powmat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb71-3"><a href="#cb71-3" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" tabindex="-1"></a>  mat B <span class="op">=</span> powmat<span class="op">(</span>A<span class="op">,</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// form 1</span></span>
<span id="cb71-5"><a href="#cb71-5" tabindex="-1"></a></span>
<span id="cb71-6"><a href="#cb71-6" tabindex="-1"></a>  mat C<span class="op">;</span></span>
<span id="cb71-7"><a href="#cb71-7" tabindex="-1"></a>  <span class="dt">bool</span> ok <span class="op">=</span> powmat<span class="op">(</span>C<span class="op">,</span> A<span class="op">,</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// form 2</span></span>
<span id="cb71-8"><a href="#cb71-8" tabindex="-1"></a></span>
<span id="cb71-9"><a href="#cb71-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb71-10"><a href="#cb71-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb71-11"><a href="#cb71-11" tabindex="-1"></a></span>
<span id="cb71-12"><a href="#cb71-12" tabindex="-1"></a>  writable<span class="op">::</span>list res2<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb71-13"><a href="#cb71-13" tabindex="-1"></a>  res2<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb71-14"><a href="#cb71-14" tabindex="-1"></a>  res2<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> logicals<span class="op">({</span>ok<span class="op">});</span></span>
<span id="cb71-15"><a href="#cb71-15" tabindex="-1"></a></span>
<span id="cb71-16"><a href="#cb71-16" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> res2<span class="op">;</span></span>
<span id="cb71-17"><a href="#cb71-17" tabindex="-1"></a></span>
<span id="cb71-18"><a href="#cb71-18" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"powmat_form1"</span><span class="op">,</span> <span class="st">"powmat_form2"</span><span class="op">});</span></span>
<span id="cb71-19"><a href="#cb71-19" tabindex="-1"></a>  res2<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"result"</span><span class="op">,</span> <span class="st">"status"</span><span class="op">});</span></span>
<span id="cb71-20"><a href="#cb71-20" tabindex="-1"></a></span>
<span id="cb71-21"><a href="#cb71-21" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb71-22"><a href="#cb71-22" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="prod">Product of elements<a class="anchor" aria-label="anchor" href="#prod"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/prod.html" class="external-link">prod()</a></code> function computes the product of the elements
in a vector or matrix. The optional <code>dim</code> argument specifies
the dimension along which to compute the matrix product, with
<code>dim = 0</code> computing the product along columns and
<code>dim = 1</code> computing the product along rows.</p>
<div class="section level3">
<h3 id="examples-48">Examples<a class="anchor" aria-label="anchor" href="#examples-48"></a>
</h3>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">prod1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb72-3"><a href="#cb72-3" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" tabindex="-1"></a>  rowvec b <span class="op">=</span> prod<span class="op">(</span>A<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb72-5"><a href="#cb72-5" tabindex="-1"></a>  vec c <span class="op">=</span> prod<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb72-6"><a href="#cb72-6" tabindex="-1"></a></span>
<span id="cb72-7"><a href="#cb72-7" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb72-8"><a href="#cb72-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>b<span class="op">.</span>t<span class="op">());</span></span>
<span id="cb72-9"><a href="#cb72-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb72-10"><a href="#cb72-10" tabindex="-1"></a></span>
<span id="cb72-11"><a href="#cb72-11" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb72-12"><a href="#cb72-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="rank">Rank of matrix<a class="anchor" aria-label="anchor" href="#rank"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/rank.html" class="external-link">rank()</a></code> function computes the rank of a matrix based
on singular values. The optional <code>tolerance</code> argument
specifies the tolerance for the singular values. The default is
<code>tolerance = max_rc * max_sv * epsilon</code>, where:</p>
<ul>
<li><code>max_rc = max(X.n_rows,â€‰X.n_cols)</code></li>
<li><code>max_sv = max(singular values of X)</code></li>
<li><code>epsilon = 1 - min(singular values of X &gt; 1)</code></li>
</ul>
<p>Usage:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a>val <span class="op">=</span> rank<span class="op">(</span>X<span class="op">,</span> tolerance<span class="op">);</span> <span class="co">// form 1</span></span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a>rank<span class="op">(</span>val<span class="op">,</span> X<span class="op">,</span> tolerance<span class="op">);</span>   <span class="co">// form 2</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-49">Examples<a class="anchor" aria-label="anchor" href="#examples-49"></a>
</h3>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">rank1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb74-3"><a href="#cb74-3" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" tabindex="-1"></a>  <span class="dt">int</span> r1 <span class="op">=</span> rank<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb74-5"><a href="#cb74-5" tabindex="-1"></a></span>
<span id="cb74-6"><a href="#cb74-6" tabindex="-1"></a>  uword r2<span class="op">;</span></span>
<span id="cb74-7"><a href="#cb74-7" tabindex="-1"></a>  <span class="dt">bool</span> ok <span class="op">=</span> rank<span class="op">(</span>r2<span class="op">,</span> A<span class="op">);</span></span>
<span id="cb74-8"><a href="#cb74-8" tabindex="-1"></a></span>
<span id="cb74-9"><a href="#cb74-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb74-10"><a href="#cb74-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> integers<span class="op">({</span>r1<span class="op">});</span></span>
<span id="cb74-11"><a href="#cb74-11" tabindex="-1"></a></span>
<span id="cb74-12"><a href="#cb74-12" tabindex="-1"></a>  writable<span class="op">::</span>list res2<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb74-13"><a href="#cb74-13" tabindex="-1"></a>  res2<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> integers<span class="op">({</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>r2<span class="op">)});</span></span>
<span id="cb74-14"><a href="#cb74-14" tabindex="-1"></a>  res2<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> logicals<span class="op">({</span>ok<span class="op">});</span></span>
<span id="cb74-15"><a href="#cb74-15" tabindex="-1"></a></span>
<span id="cb74-16"><a href="#cb74-16" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> res2<span class="op">;</span></span>
<span id="cb74-17"><a href="#cb74-17" tabindex="-1"></a></span>
<span id="cb74-18"><a href="#cb74-18" tabindex="-1"></a>  res<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"rank1"</span><span class="op">,</span> <span class="st">"rank2"</span><span class="op">});</span></span>
<span id="cb74-19"><a href="#cb74-19" tabindex="-1"></a>  res2<span class="op">.</span>attr<span class="op">(</span><span class="st">"names"</span><span class="op">)</span> <span class="op">=</span> strings<span class="op">({</span><span class="st">"result"</span><span class="op">,</span> <span class="st">"status"</span><span class="op">});</span></span>
<span id="cb74-20"><a href="#cb74-20" tabindex="-1"></a></span>
<span id="cb74-21"><a href="#cb74-21" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb74-22"><a href="#cb74-22" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="rcond">Reciprocal condition number<a class="anchor" aria-label="anchor" href="#rcond"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/kappa.html" class="external-link">rcond()</a></code> function computes the 1-norm estimate of the
reciprocal condition number of a square matrix. Values close to one
indicate a well-conditioned matrix, while values close to zero indicate
a poorly conditioned matrix. If the input matrix is not square, the
function throws a <code>std::runtime_error</code> exception.</p>
<div class="section level3">
<h3 id="examples-50">Examples<a class="anchor" aria-label="anchor" href="#examples-50"></a>
</h3>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">rcond1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb75-3"><a href="#cb75-3" tabindex="-1"></a>  <span class="cf">return</span> doubles<span class="op">({</span>rcond<span class="op">(</span>A<span class="op">)});</span></span>
<span id="cb75-4"><a href="#cb75-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-6">Caveat<a class="anchor" aria-label="anchor" href="#caveat-6"></a>
</h3>
<p>To efficiently calculate the reciprocal condition and the matrix
inverse at the same time, use <code>inv()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="repelem">Replicate elements<a class="anchor" aria-label="anchor" href="#repelem"></a>
</h2>
<p>The <code>repelem()</code> function replicates the elements of a
matrix.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a>repelem<span class="op">(</span>A<span class="op">,</span> num_copies_per_row<span class="op">,</span> num_copies_per_col<span class="op">)</span></span></code></pre></div>
<p>The generated matrix has the following size:</p>
<ul>
<li><code>n_rows = num_copies_per_row * A.n_rows</code></li>
<li><code>n_cols   = num_copies_per_col * A.n_cols</code></li>
</ul>
<div class="section level3">
<h3 id="examples-51">Examples<a class="anchor" aria-label="anchor" href="#examples-51"></a>
</h3>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">repelem1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb77-3"><a href="#cb77-3" tabindex="-1"></a>  mat B <span class="op">=</span> repelem<span class="op">(</span>A<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb77-4"><a href="#cb77-4" tabindex="-1"></a></span>
<span id="cb77-5"><a href="#cb77-5" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb77-6"><a href="#cb77-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb77-7"><a href="#cb77-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb77-8"><a href="#cb77-8" tabindex="-1"></a></span>
<span id="cb77-9"><a href="#cb77-9" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb77-10"><a href="#cb77-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="repmat">Replicate matrix in block-like fashion<a class="anchor" aria-label="anchor" href="#repmat"></a>
</h2>
<p>The <code>repmat()</code> function replicates a matrix in a
block-like fashion.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a>repmat<span class="op">(</span>A<span class="op">,</span> num_reps_row<span class="op">,</span> num_reps_col<span class="op">)</span></span></code></pre></div>
<p>The generated matrix has the following size:</p>
<ul>
<li><code>n_rows = num_reps_row * A.n_rows</code></li>
<li><code>n_cols = num_reps_col * A.n_cols</code></li>
</ul>
<div class="section level3">
<h3 id="examples-52">Examples<a class="anchor" aria-label="anchor" href="#examples-52"></a>
</h3>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">repmat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-2"><a href="#cb79-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb79-3"><a href="#cb79-3" tabindex="-1"></a>  mat B <span class="op">=</span> repmat<span class="op">(</span>A<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb79-4"><a href="#cb79-4" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb79-6"><a href="#cb79-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb79-7"><a href="#cb79-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb79-8"><a href="#cb79-8" tabindex="-1"></a></span>
<span id="cb79-9"><a href="#cb79-9" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb79-10"><a href="#cb79-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-7">Caveat<a class="anchor" aria-label="anchor" href="#caveat-7"></a>
</h3>
<p>To apply a vector operation on each row or column of a matrix, it is
generally more efficient to use <code>.each_row()</code> or
<code>.each_col()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="reshape">Change size while keeping elements<a class="anchor" aria-label="anchor" href="#reshape"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/stats/reshape.html" class="external-link">reshape()</a></code> function changes the size of a vector,
matrix or cube while keeping the elements in the same order.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a>reshape<span class="op">(</span>vector<span class="op">,</span> n_rows<span class="op">,</span> n_cols<span class="op">)</span></span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>reshape<span class="op">(</span>matrix<span class="op">,</span> n_rows<span class="op">,</span> n_cols<span class="op">)</span></span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a></span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a>reshape<span class="op">(</span>vector<span class="op">,</span> size<span class="op">(</span>matrix<span class="op">))</span></span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a>reshape<span class="op">(</span>matrix<span class="op">,</span> size<span class="op">(</span>matrix<span class="op">))</span></span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a></span>
<span id="cb80-7"><a href="#cb80-7" tabindex="-1"></a>reshape<span class="op">(</span>cube<span class="op">,</span> n_rows<span class="op">,</span> n_cols<span class="op">,</span> n_slices<span class="op">)</span></span>
<span id="cb80-8"><a href="#cb80-8" tabindex="-1"></a>reshape<span class="op">(</span>cube<span class="op">,</span> size<span class="op">(</span>cube<span class="op">))</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-53">Examples<a class="anchor" aria-label="anchor" href="#examples-53"></a>
</h3>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">reshape1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb81-2"><a href="#cb81-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb81-3"><a href="#cb81-3" tabindex="-1"></a>  </span>
<span id="cb81-4"><a href="#cb81-4" tabindex="-1"></a>  mat B <span class="op">=</span> reshape<span class="op">(</span>A<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb81-5"><a href="#cb81-5" tabindex="-1"></a>  </span>
<span id="cb81-6"><a href="#cb81-6" tabindex="-1"></a>  mat C<span class="op">(</span>n <span class="op">+</span> <span class="dv">4</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-7"><a href="#cb81-7" tabindex="-1"></a>  C <span class="op">=</span> reshape<span class="op">(</span>A<span class="op">,</span> size<span class="op">(</span>C<span class="op">));</span></span>
<span id="cb81-8"><a href="#cb81-8" tabindex="-1"></a></span>
<span id="cb81-9"><a href="#cb81-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb81-10"><a href="#cb81-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb81-11"><a href="#cb81-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb81-12"><a href="#cb81-12" tabindex="-1"></a></span>
<span id="cb81-13"><a href="#cb81-13" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb81-14"><a href="#cb81-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="resize">Change size while keeping elements and preserving layout<a class="anchor" aria-label="anchor" href="#resize"></a>
</h2>
<p>The <code>resize()</code> function changes the size of a vector,
matrix or cube while preserving the data. If the new size is larger, the
new elements are set to zero.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a>resize<span class="op">(</span>vector<span class="op">,</span> n_rows<span class="op">,</span> n_cols<span class="op">)</span></span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>resize<span class="op">(</span>matrix<span class="op">,</span> n_rows<span class="op">,</span> n_cols<span class="op">)</span></span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a>resize<span class="op">(</span>vector<span class="op">,</span> size<span class="op">(</span>matrix<span class="op">))</span></span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a>resize<span class="op">(</span>matrix<span class="op">,</span> size<span class="op">(</span>matrix<span class="op">))</span></span>
<span id="cb82-6"><a href="#cb82-6" tabindex="-1"></a></span>
<span id="cb82-7"><a href="#cb82-7" tabindex="-1"></a>resize<span class="op">(</span>cube<span class="op">,</span> n_rows<span class="op">,</span> n_cols<span class="op">,</span> n_slices<span class="op">)</span></span>
<span id="cb82-8"><a href="#cb82-8" tabindex="-1"></a>resize<span class="op">(</span>cube<span class="op">,</span> size<span class="op">(</span>cube<span class="op">))</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-54">Examples<a class="anchor" aria-label="anchor" href="#examples-54"></a>
</h3>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">resize2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" tabindex="-1"></a>  mat B <span class="op">=</span> resize<span class="op">(</span>A<span class="op">,</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb83-5"><a href="#cb83-5" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" tabindex="-1"></a>  mat C<span class="op">(</span>n <span class="op">+</span> <span class="dv">4</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb83-7"><a href="#cb83-7" tabindex="-1"></a>  C <span class="op">=</span> resize<span class="op">(</span>A<span class="op">,</span> size<span class="op">(</span>C<span class="op">));</span></span>
<span id="cb83-8"><a href="#cb83-8" tabindex="-1"></a></span>
<span id="cb83-9"><a href="#cb83-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb83-10"><a href="#cb83-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb83-11"><a href="#cb83-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb83-12"><a href="#cb83-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb83-13"><a href="#cb83-13" tabindex="-1"></a></span>
<span id="cb83-14"><a href="#cb83-14" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb83-15"><a href="#cb83-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="reverse">Reverse order of elements<a class="anchor" aria-label="anchor" href="#reverse"></a>
</h2>
<p>The <code>reverse()</code> function reverses the order of elements in
a vector or matrix. The optional <code>dim</code> argument specifies the
dimension along which to reverse the matrix, with <code>dim = 0</code>
reversing along columns and <code>dim = 1</code> reversing along rows
(<code>dim = 0</code> by default).</p>
<div class="section level3">
<h3 id="examples-55">Examples<a class="anchor" aria-label="anchor" href="#examples-55"></a>
</h3>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">reverse1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb84-2"><a href="#cb84-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb84-3"><a href="#cb84-3" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" tabindex="-1"></a>  mat B <span class="op">=</span> reverse<span class="op">(</span>A<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb84-5"><a href="#cb84-5" tabindex="-1"></a>  mat C <span class="op">=</span> reverse<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb84-6"><a href="#cb84-6" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb84-8"><a href="#cb84-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb84-9"><a href="#cb84-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb84-10"><a href="#cb84-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb84-11"><a href="#cb84-11" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb84-13"><a href="#cb84-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="roots">Roots of polynomial<a class="anchor" aria-label="anchor" href="#roots"></a>
</h2>
<p>The <code>roots()</code> function computes the roots of a polynomial
with real or complex coefficients. The input is a vector of
coefficients, with the first element corresponding to the highest degree
term. If the computation fails, the function throws a
<code>std::runtime_error</code> exception.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a>Y <span class="op">=</span> roots<span class="op">(</span>X<span class="op">)</span> <span class="co">// store the roots in Y</span></span>
<span id="cb85-2"><a href="#cb85-2" tabindex="-1"></a>roots<span class="op">(</span>Y<span class="op">,</span> X<span class="op">)</span>  <span class="co">// store the roots in Y and return true if successful</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-56">Examples<a class="anchor" aria-label="anchor" href="#examples-56"></a>
</h3>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">roots1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb86-2"><a href="#cb86-2" tabindex="-1"></a>  <span class="co">// y = p_1*x^n + p_2*x^(n-1) + ... + p_(n-1)*x + p_n</span></span>
<span id="cb86-3"><a href="#cb86-3" tabindex="-1"></a>  <span class="co">// p_1, ..., p_n are random numbers</span></span>
<span id="cb86-4"><a href="#cb86-4" tabindex="-1"></a>  vec y<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb86-5"><a href="#cb86-5" tabindex="-1"></a></span>
<span id="cb86-6"><a href="#cb86-6" tabindex="-1"></a>  <span class="co">// note that mat and cx_mat operate directly</span></span>
<span id="cb86-7"><a href="#cb86-7" tabindex="-1"></a>  <span class="co">// but vec and cx_vec require conv_to&lt;...&gt;::from()</span></span>
<span id="cb86-8"><a href="#cb86-8" tabindex="-1"></a>  cx_vec z <span class="op">=</span> roots<span class="op">(</span>conv_to<span class="op">&lt;</span>cx_vec<span class="op">&gt;::</span>from<span class="op">(</span>y<span class="op">));</span></span>
<span id="cb86-9"><a href="#cb86-9" tabindex="-1"></a></span>
<span id="cb86-10"><a href="#cb86-10" tabindex="-1"></a>  list res <span class="op">=</span> as_complex_doubles<span class="op">(</span>z<span class="op">);</span></span>
<span id="cb86-11"><a href="#cb86-11" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb86-12"><a href="#cb86-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shift">Shift elements<a class="anchor" aria-label="anchor" href="#shift"></a>
</h2>
<p>The <code>shift()</code> function generates a copy of a vector
<code>V</code> or a matrix <code>M</code> with the elements shifted by
<code>N</code> positions in a circular manner. The <code>N</code>
argument can be positive or negative. For a matrix, the optional
<code>dim</code> argument specifies the dimension along which to shift
the matrix, with <code>dim = 0</code> shifting along columns (default)
and <code>dim = 1</code> shifting along rows.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" tabindex="-1"></a>shift<span class="op">(</span>V<span class="op">,</span> N<span class="op">)</span></span>
<span id="cb87-2"><a href="#cb87-2" tabindex="-1"></a>shift<span class="op">(</span>M<span class="op">,</span> N<span class="op">)</span></span>
<span id="cb87-3"><a href="#cb87-3" tabindex="-1"></a>shift<span class="op">(</span>M<span class="op">,</span> N<span class="op">,</span> dim<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-57">Examples<a class="anchor" aria-label="anchor" href="#examples-57"></a>
</h3>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">shift1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb88-3"><a href="#cb88-3" tabindex="-1"></a>  mat B <span class="op">=</span> shift<span class="op">(</span>A<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb88-4"><a href="#cb88-4" tabindex="-1"></a>  mat C <span class="op">=</span> shift<span class="op">(</span>A<span class="op">,</span> <span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb88-5"><a href="#cb88-5" tabindex="-1"></a></span>
<span id="cb88-6"><a href="#cb88-6" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb88-7"><a href="#cb88-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb88-8"><a href="#cb88-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb88-9"><a href="#cb88-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb88-10"><a href="#cb88-10" tabindex="-1"></a></span>
<span id="cb88-11"><a href="#cb88-11" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb88-12"><a href="#cb88-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shuffle">Randomly shuffle elements<a class="anchor" aria-label="anchor" href="#shuffle"></a>
</h2>
<p>The <code>shuffle()</code> function generates a copy of a vector
<code>V</code> or matrix <code>M</code> with the elements shuffled. For
a matrix, the optional <code>dim</code> argument specifies the dimension
along which to shuffle the matrix, with <code>dim = 0</code> shuffling
along columns (default) and <code>dim = 1</code> shuffling along
rows.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" tabindex="-1"></a>shuffle<span class="op">(</span>V<span class="op">)</span></span>
<span id="cb89-2"><a href="#cb89-2" tabindex="-1"></a>shuffle<span class="op">(</span>M<span class="op">)</span></span>
<span id="cb89-3"><a href="#cb89-3" tabindex="-1"></a>shuffle<span class="op">(</span>M<span class="op">,</span> dim<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-58">Examples<a class="anchor" aria-label="anchor" href="#examples-58"></a>
</h3>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">shuffle1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb90-2"><a href="#cb90-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb90-3"><a href="#cb90-3" tabindex="-1"></a>  mat B <span class="op">=</span> shuffle<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb90-4"><a href="#cb90-4" tabindex="-1"></a></span>
<span id="cb90-5"><a href="#cb90-5" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb90-6"><a href="#cb90-6" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb90-7"><a href="#cb90-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb90-8"><a href="#cb90-8" tabindex="-1"></a></span>
<span id="cb90-9"><a href="#cb90-9" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb90-10"><a href="#cb90-10" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="size">Obtain dimensions of given object<a class="anchor" aria-label="anchor" href="#size"></a>
</h2>
<p>The <code>size()</code> function obtains the dimensions of a matrix
or cube <code>X</code>. It can also be used to explicitly specify the
dimensions of a matrix or cube.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" tabindex="-1"></a>size<span class="op">(</span>X<span class="op">)</span></span>
<span id="cb91-2"><a href="#cb91-2" tabindex="-1"></a>size<span class="op">(</span>n_rows<span class="op">,</span> n_cols<span class="op">)</span></span>
<span id="cb91-3"><a href="#cb91-3" tabindex="-1"></a>size<span class="op">(</span>n_rows<span class="op">,</span> n_cols<span class="op">,</span> n_slices<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-59">Examples<a class="anchor" aria-label="anchor" href="#examples-59"></a>
</h3>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">size1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb92-2"><a href="#cb92-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb92-3"><a href="#cb92-3" tabindex="-1"></a></span>
<span id="cb92-4"><a href="#cb92-4" tabindex="-1"></a>  mat B<span class="op">(</span>size<span class="op">(</span>A<span class="op">),</span> fill<span class="op">::</span>zeros<span class="op">);</span></span>
<span id="cb92-5"><a href="#cb92-5" tabindex="-1"></a></span>
<span id="cb92-6"><a href="#cb92-6" tabindex="-1"></a>  mat C<span class="op">;</span></span>
<span id="cb92-7"><a href="#cb92-7" tabindex="-1"></a>  C<span class="op">.</span>randu<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span></span>
<span id="cb92-8"><a href="#cb92-8" tabindex="-1"></a>  mat D <span class="op">=</span> ones<span class="op">&lt;</span>mat<span class="op">&gt;(</span>size<span class="op">(</span>A<span class="op">));</span></span>
<span id="cb92-9"><a href="#cb92-9" tabindex="-1"></a></span>
<span id="cb92-10"><a href="#cb92-10" tabindex="-1"></a>  mat E<span class="op">(</span><span class="dv">2</span> <span class="op">*</span> n<span class="op">,</span> <span class="dv">2</span> <span class="op">*</span> n<span class="op">,</span> fill<span class="op">::</span>ones<span class="op">);</span></span>
<span id="cb92-11"><a href="#cb92-11" tabindex="-1"></a>  E<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> size<span class="op">(</span>C<span class="op">))</span> <span class="op">=</span> C<span class="op">;</span>  <span class="co">// access submatrix of E</span></span>
<span id="cb92-12"><a href="#cb92-12" tabindex="-1"></a></span>
<span id="cb92-13"><a href="#cb92-13" tabindex="-1"></a>  mat F<span class="op">(</span>size<span class="op">(</span>A<span class="op">)</span> <span class="op">+</span> size<span class="op">(</span>E<span class="op">),</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb92-14"><a href="#cb92-14" tabindex="-1"></a></span>
<span id="cb92-15"><a href="#cb92-15" tabindex="-1"></a>  mat G<span class="op">(</span>size<span class="op">(</span>A<span class="op">)</span> <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb92-16"><a href="#cb92-16" tabindex="-1"></a></span>
<span id="cb92-17"><a href="#cb92-17" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">7</span><span class="op">);</span></span>
<span id="cb92-18"><a href="#cb92-18" tabindex="-1"></a></span>
<span id="cb92-19"><a href="#cb92-19" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb92-20"><a href="#cb92-20" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb92-21"><a href="#cb92-21" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb92-22"><a href="#cb92-22" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span></span>
<span id="cb92-23"><a href="#cb92-23" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>E<span class="op">);</span></span>
<span id="cb92-24"><a href="#cb92-24" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>F<span class="op">);</span></span>
<span id="cb92-25"><a href="#cb92-25" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>G<span class="op">);</span></span>
<span id="cb92-26"><a href="#cb92-26" tabindex="-1"></a></span>
<span id="cb92-27"><a href="#cb92-27" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb92-28"><a href="#cb92-28" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sort">Sort elements<a class="anchor" aria-label="anchor" href="#sort"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort()</a></code> function returns a sorted version of a vector
<code>V</code> or matrix <code>M</code>. For a matrix, the optional
<code>dim</code> argument specifies the dimension along which to sort
the matrix, with <code>dim = 0</code> sorting along columns (default)
and <code>dim = 1</code> sorting along rows. The optional
<code>sort_direction</code> argument specifies the sorting direction,
with <code>sort_direction = "ascend"</code> (default) sorting in
ascending order and <code>sort_direction = "descend"</code> sorting in
descending order.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" tabindex="-1"></a>sort<span class="op">(</span>V<span class="op">)</span></span>
<span id="cb93-2"><a href="#cb93-2" tabindex="-1"></a>sort<span class="op">(</span>V<span class="op">,</span> sort_direction<span class="op">)</span></span>
<span id="cb93-3"><a href="#cb93-3" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" tabindex="-1"></a>sort<span class="op">(</span>M<span class="op">)</span></span>
<span id="cb93-5"><a href="#cb93-5" tabindex="-1"></a>sort<span class="op">(</span>M<span class="op">,</span> sort_direction<span class="op">)</span></span>
<span id="cb93-6"><a href="#cb93-6" tabindex="-1"></a>sort<span class="op">(</span>M<span class="op">,</span> sort_direction<span class="op">,</span> dim<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-60">Examples<a class="anchor" aria-label="anchor" href="#examples-60"></a>
</h3>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">sort1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb94-2"><a href="#cb94-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb94-3"><a href="#cb94-3" tabindex="-1"></a>  mat B <span class="op">=</span> sort<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb94-4"><a href="#cb94-4" tabindex="-1"></a>  mat C <span class="op">=</span> sort<span class="op">(</span>A<span class="op">,</span> <span class="st">"descend"</span><span class="op">);</span></span>
<span id="cb94-5"><a href="#cb94-5" tabindex="-1"></a>  mat D <span class="op">=</span> sort<span class="op">(</span>A<span class="op">,</span> <span class="st">"ascend"</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb94-6"><a href="#cb94-6" tabindex="-1"></a>  mat E <span class="op">=</span> sort<span class="op">(</span>A<span class="op">,</span> <span class="st">"descend"</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb94-7"><a href="#cb94-7" tabindex="-1"></a></span>
<span id="cb94-8"><a href="#cb94-8" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb94-9"><a href="#cb94-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb94-10"><a href="#cb94-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb94-11"><a href="#cb94-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb94-12"><a href="#cb94-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span></span>
<span id="cb94-13"><a href="#cb94-13" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>E<span class="op">);</span></span>
<span id="cb94-14"><a href="#cb94-14" tabindex="-1"></a></span>
<span id="cb94-15"><a href="#cb94-15" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb94-16"><a href="#cb94-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sort_index">Vector describing sorted order of elements<a class="anchor" aria-label="anchor" href="#sort_index"></a>
</h2>
<p>The <code>sort_index()</code> function returns a vector describing
the sorted order of the elements of a vector <code>V</code> or matrix
<code>M</code>. The optional <code>sort_direction</code> argument
specifies the sorting direction, with
<code>sort_direction = "ascend"</code> (default) sorting in ascending
order and <code>sort_direction = "descend"</code> sorting in descending
order.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" tabindex="-1"></a>sort_index<span class="op">(</span>V<span class="op">)</span></span>
<span id="cb95-2"><a href="#cb95-2" tabindex="-1"></a>sort_index<span class="op">(</span>V<span class="op">,</span> sort_direction<span class="op">)</span></span>
<span id="cb95-3"><a href="#cb95-3" tabindex="-1"></a></span>
<span id="cb95-4"><a href="#cb95-4" tabindex="-1"></a>sort_index<span class="op">(</span>M<span class="op">)</span></span>
<span id="cb95-5"><a href="#cb95-5" tabindex="-1"></a>sort_index<span class="op">(</span>M<span class="op">,</span> sort_direction<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-61">Examples<a class="anchor" aria-label="anchor" href="#examples-61"></a>
</h3>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">sort_index1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb96-2"><a href="#cb96-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb96-3"><a href="#cb96-3" tabindex="-1"></a>  uvec B <span class="op">=</span> sort_index<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb96-4"><a href="#cb96-4" tabindex="-1"></a>  uvec C <span class="op">=</span> sort_index<span class="op">(</span>A<span class="op">,</span> <span class="st">"descend"</span><span class="op">);</span></span>
<span id="cb96-5"><a href="#cb96-5" tabindex="-1"></a></span>
<span id="cb96-6"><a href="#cb96-6" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb96-7"><a href="#cb96-7" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb96-8"><a href="#cb96-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_integers<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb96-9"><a href="#cb96-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_integers<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb96-10"><a href="#cb96-10" tabindex="-1"></a></span>
<span id="cb96-11"><a href="#cb96-11" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb96-12"><a href="#cb96-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="spdiags">Generate a sparse matrix with diagonals specified by column
vectors<a class="anchor" aria-label="anchor" href="#spdiags"></a>
</h2>
<p>The <code>spdiags()</code> function generates a sparse matrix with
diagonals specified by column vectors from an input matrix and a vector
to indicate the diagonals.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" tabindex="-1"></a>spdiags<span class="op">(</span>matrix<span class="op">,</span> vector<span class="op">,</span> number_of_rows<span class="op">,</span> number_of_columns<span class="op">);</span></span></code></pre></div>
<p>Each element in the input vector specifies diagonal <code>k</code>,
where:</p>
<ul>
<li>
<code>k = 0</code> is the main diagonal</li>
<li>
<code>k &gt; 0</code> is above the main diagonal</li>
<li>
<code>k &lt; 0</code> is below the main diagonal</li>
</ul>
<div class="section level3">
<h3 id="examples-62">Examples<a class="anchor" aria-label="anchor" href="#examples-62"></a>
</h3>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">spdiags1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb98-2"><a href="#cb98-2" tabindex="-1"></a>  mat V<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb98-3"><a href="#cb98-3" tabindex="-1"></a>  ivec D <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb98-4"><a href="#cb98-4" tabindex="-1"></a>  sp_mat X <span class="op">=</span> spdiags<span class="op">(</span>V<span class="op">,</span> D<span class="op">,</span> n<span class="op">,</span> n<span class="op">);</span> <span class="co">// lower triangular matrix</span></span>
<span id="cb98-5"><a href="#cb98-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb98-6"><a href="#cb98-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sqrtmat">Square root of matrix<a class="anchor" aria-label="anchor" href="#sqrtmat"></a>
</h2>
<p>The <code>sqrtmat()</code> function computes the complex square root
of a general square matrix. If the input matrix is not square, the
function throws an error. If the matrix appears to be singular, an
approximate square root is attempted.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" tabindex="-1"></a>B <span class="op">=</span> sqrtmat<span class="op">(</span>A<span class="op">)</span></span>
<span id="cb99-2"><a href="#cb99-2" tabindex="-1"></a>sqrtmat<span class="op">(</span>B<span class="op">,</span> A<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-63">Examples<a class="anchor" aria-label="anchor" href="#examples-63"></a>
</h3>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">sqrtmat1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb100-2"><a href="#cb100-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb100-3"><a href="#cb100-3" tabindex="-1"></a>  </span>
<span id="cb100-4"><a href="#cb100-4" tabindex="-1"></a>  cx_mat B <span class="op">=</span> sqrtmat<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb100-5"><a href="#cb100-5" tabindex="-1"></a></span>
<span id="cb100-6"><a href="#cb100-6" tabindex="-1"></a>  cx_mat C<span class="op">;</span></span>
<span id="cb100-7"><a href="#cb100-7" tabindex="-1"></a>  <span class="dt">bool</span> ok <span class="op">=</span> sqrtmat<span class="op">(</span>C<span class="op">,</span> A<span class="op">);</span></span>
<span id="cb100-8"><a href="#cb100-8" tabindex="-1"></a></span>
<span id="cb100-9"><a href="#cb100-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb100-10"><a href="#cb100-10" tabindex="-1"></a></span>
<span id="cb100-11"><a href="#cb100-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb100-12"><a href="#cb100-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_complex_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb100-13"><a href="#cb100-13" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_complex_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb100-14"><a href="#cb100-14" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> logicals<span class="op">({</span>ok<span class="op">});</span></span>
<span id="cb100-15"><a href="#cb100-15" tabindex="-1"></a></span>
<span id="cb100-16"><a href="#cb100-16" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb100-17"><a href="#cb100-17" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sqrtmat_sympd">Square root of symmetric matrix<a class="anchor" aria-label="anchor" href="#sqrtmat_sympd"></a>
</h2>
<p>The <code>sqrtmat_sympd()</code> function computes the square root of
a symmetric positive definite matrix. If the input matrix is not square
or the computation fails, the function throws an error.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" tabindex="-1"></a>B <span class="op">=</span> sqrtmat_sympd<span class="op">(</span>A<span class="op">)</span></span>
<span id="cb101-2"><a href="#cb101-2" tabindex="-1"></a>sqrtmat_sympd<span class="op">(</span>B<span class="op">,</span> A<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-64">Examples<a class="anchor" aria-label="anchor" href="#examples-64"></a>
</h3>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">sqrtmat_sympd1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb102-2"><a href="#cb102-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb102-3"><a href="#cb102-3" tabindex="-1"></a>  A <span class="op">=</span> A <span class="op">*</span> A<span class="op">.</span>t<span class="op">();</span>  <span class="co">// make A symmetric positive definite</span></span>
<span id="cb102-4"><a href="#cb102-4" tabindex="-1"></a></span>
<span id="cb102-5"><a href="#cb102-5" tabindex="-1"></a>  mat B <span class="op">=</span> sqrtmat_sympd<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb102-6"><a href="#cb102-6" tabindex="-1"></a></span>
<span id="cb102-7"><a href="#cb102-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb102-8"><a href="#cb102-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sum">Sum of elements<a class="anchor" aria-label="anchor" href="#sum"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum()</a></code> function computes the sum of the elements in a
vector, matrix or cube. For a matrix, the optional <code>dim</code>
argument specifies the dimension along which to compute the sum, with
<code>dim = 0</code> computing the sum along columns and
<code>dim = 1</code> computing the sum along rows. For a cube, the
optional <code>dim</code> argument specifies the dimension along which
to compute the sum, with <code>dim = 0</code> computing the sum along
columns, <code>dim = 1</code> computing the sum along rows, and
<code>dim = 2</code> computing the sum along slices.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" tabindex="-1"></a>sum<span class="op">(</span>vector<span class="op">)</span></span>
<span id="cb103-2"><a href="#cb103-2" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" tabindex="-1"></a>sum<span class="op">(</span>matrix<span class="op">)</span></span>
<span id="cb103-4"><a href="#cb103-4" tabindex="-1"></a>sum<span class="op">(</span>matrix<span class="op">,</span> dim<span class="op">)</span></span>
<span id="cb103-5"><a href="#cb103-5" tabindex="-1"></a></span>
<span id="cb103-6"><a href="#cb103-6" tabindex="-1"></a>sum<span class="op">(</span>cube<span class="op">)</span></span>
<span id="cb103-7"><a href="#cb103-7" tabindex="-1"></a>sum<span class="op">(</span>cube<span class="op">,</span> dim<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-65">Examples<a class="anchor" aria-label="anchor" href="#examples-65"></a>
</h3>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">sum2_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb104-2"><a href="#cb104-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb104-3"><a href="#cb104-3" tabindex="-1"></a></span>
<span id="cb104-4"><a href="#cb104-4" tabindex="-1"></a>  vec a <span class="op">=</span> sum<span class="op">(</span>A<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb104-5"><a href="#cb104-5" tabindex="-1"></a>  vec b <span class="op">=</span> sum<span class="op">(</span>A<span class="op">,</span> <span class="dv">0</span><span class="op">).</span>t<span class="op">();</span></span>
<span id="cb104-6"><a href="#cb104-6" tabindex="-1"></a>  <span class="dt">double</span> c <span class="op">=</span> accu<span class="op">(</span>A<span class="op">);</span>  <span class="co">// overall sum</span></span>
<span id="cb104-7"><a href="#cb104-7" tabindex="-1"></a></span>
<span id="cb104-8"><a href="#cb104-8" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb104-9"><a href="#cb104-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb104-10"><a href="#cb104-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb104-11"><a href="#cb104-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> doubles<span class="op">({</span>c<span class="op">});</span></span>
<span id="cb104-12"><a href="#cb104-12" tabindex="-1"></a></span>
<span id="cb104-13"><a href="#cb104-13" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb104-14"><a href="#cb104-14" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sub2ind">Convert subscripts to linear index<a class="anchor" aria-label="anchor" href="#sub2ind"></a>
</h2>
<p>The <code>sub2ind()</code> function converts subscripts to a linear
index. If a subscript is out of range, the function returns an
error.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" tabindex="-1"></a>sub2ind<span class="op">(</span>size<span class="op">(</span>matrix<span class="op">),</span> row<span class="op">,</span> col<span class="op">)</span></span>
<span id="cb105-2"><a href="#cb105-2" tabindex="-1"></a>sub2ind<span class="op">(</span>size<span class="op">(</span>matrix<span class="op">),</span> matrix_of_subscripts<span class="op">)</span></span>
<span id="cb105-3"><a href="#cb105-3" tabindex="-1"></a></span>
<span id="cb105-4"><a href="#cb105-4" tabindex="-1"></a>sub2ind<span class="op">(</span>size<span class="op">(</span>cube<span class="op">),</span> row<span class="op">,</span> col<span class="op">,</span> slice<span class="op">)</span></span>
<span id="cb105-5"><a href="#cb105-5" tabindex="-1"></a>sub2ind<span class="op">(</span>size<span class="op">(</span>cube<span class="op">),</span> matrix_of_subscripts<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-66">Examples<a class="anchor" aria-label="anchor" href="#examples-66"></a>
</h3>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">sub2ind1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-2"><a href="#cb106-2" tabindex="-1"></a>  mat M<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb106-3"><a href="#cb106-3" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" tabindex="-1"></a>  uword i <span class="op">=</span> sub2ind<span class="op">(</span>size<span class="op">(</span>M<span class="op">),</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb106-5"><a href="#cb106-5" tabindex="-1"></a></span>
<span id="cb106-6"><a href="#cb106-6" tabindex="-1"></a>  <span class="cf">return</span> integers<span class="op">({</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>i<span class="op">)});</span></span>
<span id="cb106-7"><a href="#cb106-7" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="symmatu-symmatl">Generate symmetric matrix from given matrix<a class="anchor" aria-label="anchor" href="#symmatu-symmatl"></a>
</h2>
<p>The <code>symmatu()</code> function generates a symmetric matrix from
a square matrix <code>A</code> by reflecting the upper triangle to the
lower triangle. The <code>symmatl()</code> function generates a
symmetric matrix from a square matrix <code>A</code> by reflecting the
lower triangle to the upper triangle. If <code>A</code> is a complex
matrix, the reflection uses the complex conjugate of the elements. To
disable the complex conjugate, set <code>do_conj</code> to
<code>false</code>. If <code>A</code> is non-square, an error is
thrown.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" tabindex="-1"></a>symmatu<span class="op">(</span>A<span class="op">)</span></span>
<span id="cb107-2"><a href="#cb107-2" tabindex="-1"></a>symmatu<span class="op">(</span>A<span class="op">,</span> do_conj<span class="op">)</span></span>
<span id="cb107-3"><a href="#cb107-3" tabindex="-1"></a></span>
<span id="cb107-4"><a href="#cb107-4" tabindex="-1"></a>symmatl<span class="op">(</span>A<span class="op">)</span></span>
<span id="cb107-5"><a href="#cb107-5" tabindex="-1"></a>symmatl<span class="op">(</span>A<span class="op">,</span> do_conj<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-67">Examples<a class="anchor" aria-label="anchor" href="#examples-67"></a>
</h3>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">symmatu1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-2"><a href="#cb108-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb108-3"><a href="#cb108-3" tabindex="-1"></a>  mat B <span class="op">=</span> symmatu<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb108-4"><a href="#cb108-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb108-5"><a href="#cb108-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trace">Sum of diagonal elements<a class="anchor" aria-label="anchor" href="#trace"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/trace.html" class="external-link">trace()</a></code> function computes the sum of the elements on
the main diagonal of a matrix. If the input matrix is not square, an
error is thrown.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" tabindex="-1"></a>trace<span class="op">(</span>X<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-68">Examples<a class="anchor" aria-label="anchor" href="#examples-68"></a>
</h3>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">trace1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb110-2"><a href="#cb110-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb110-3"><a href="#cb110-3" tabindex="-1"></a>  <span class="cf">return</span> doubles<span class="op">({</span>trace<span class="op">(</span>A<span class="op">)});</span></span>
<span id="cb110-4"><a href="#cb110-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trans-strans">Transpose of matrix<a class="anchor" aria-label="anchor" href="#trans-strans"></a>
</h2>
<p>The <code>trans()</code> function transposes a matrix. For a real
matrix, <code>trans()</code> provides a transposed copy of the matrix.
For a complex matrix, <code>trans()</code> provides a Hermitian
(conjugate) transposed copy, where the signs of the imaginary components
are flipped. The <code>strans()</code> function provides a simple
transposed copy, where the signs of the imaginary components are not
flipped.</p>
<p>Usage:</p>
<pre><code><span><span class="fu">trans</span><span class="op">(</span><span class="va">A</span><span class="op">)</span></span>
<span><span class="fu">strans</span><span class="op">(</span><span class="va">A</span><span class="op">)</span></span></code></pre>
<div class="section level3">
<h3 id="examples-69">Examples<a class="anchor" aria-label="anchor" href="#examples-69"></a>
</h3>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">trans1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-2"><a href="#cb112-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb112-3"><a href="#cb112-3" tabindex="-1"></a>  </span>
<span id="cb112-4"><a href="#cb112-4" tabindex="-1"></a>  mat B <span class="op">=</span> trans<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb112-5"><a href="#cb112-5" tabindex="-1"></a>  mat C <span class="op">=</span> A<span class="op">.</span>t<span class="op">();</span>  <span class="co">// same as trans(A)</span></span>
<span id="cb112-6"><a href="#cb112-6" tabindex="-1"></a></span>
<span id="cb112-7"><a href="#cb112-7" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb112-8"><a href="#cb112-8" tabindex="-1"></a></span>
<span id="cb112-9"><a href="#cb112-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb112-10"><a href="#cb112-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb112-11"><a href="#cb112-11" tabindex="-1"></a></span>
<span id="cb112-12"><a href="#cb112-12" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb112-13"><a href="#cb112-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trapz">Trapezoidal numerical integration<a class="anchor" aria-label="anchor" href="#trapz"></a>
</h2>
<p>The <code>trapz()</code> function computes the trapezoidal integral
of a vector <code>Y</code> with respect to spacing in a vector
<code>X</code>. The optional <code>dim</code> argument specifies the
dimension along which to compute the trapezoidal integral, with
<code>dim = 0</code> computing the integral along columns and
<code>dim = 1</code> computing the integral along rows.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" tabindex="-1"></a>trapz<span class="op">(</span>X<span class="op">,</span> Y<span class="op">)</span></span>
<span id="cb113-2"><a href="#cb113-2" tabindex="-1"></a>trapz<span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> dim<span class="op">)</span></span>
<span id="cb113-3"><a href="#cb113-3" tabindex="-1"></a></span>
<span id="cb113-4"><a href="#cb113-4" tabindex="-1"></a>trapz<span class="op">(</span>Y<span class="op">)</span></span>
<span id="cb113-5"><a href="#cb113-5" tabindex="-1"></a>trapz<span class="op">(</span>Y<span class="op">,</span> dim<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-70">Examples<a class="anchor" aria-label="anchor" href="#examples-70"></a>
</h3>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">trapz1_</span><span class="op">(</span>n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-2"><a href="#cb114-2" tabindex="-1"></a>  vec X <span class="op">=</span> linspace<span class="op">&lt;</span>vec<span class="op">&gt;(</span><span class="dv">0</span><span class="op">,</span> datum<span class="op">::</span>pi<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb114-3"><a href="#cb114-3" tabindex="-1"></a>  vec Y <span class="op">=</span> sin<span class="op">(</span>X<span class="op">);</span></span>
<span id="cb114-4"><a href="#cb114-4" tabindex="-1"></a>  </span>
<span id="cb114-5"><a href="#cb114-5" tabindex="-1"></a>  mat Z <span class="op">=</span> trapz<span class="op">(</span>X<span class="op">,</span>Y<span class="op">);</span></span>
<span id="cb114-6"><a href="#cb114-6" tabindex="-1"></a></span>
<span id="cb114-7"><a href="#cb114-7" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>Z<span class="op">);</span></span>
<span id="cb114-8"><a href="#cb114-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trimatu-trimatl">Copy upper/lower triangular part<a class="anchor" aria-label="anchor" href="#trimatu-trimatl"></a>
</h2>
<p>The <code>trimatu()</code> function creates a new matrix by copying
the upper triangular part from a square matrix <code>A</code> and
setting the remaining elements to zero. The <code>trimatl()</code>
function creates a new matrix by copying the lower triangular part from
a square matrix <code>A</code> and setting the remaining elements to
zero. The optional <code>k</code> argument specifies the diagonal
(<code>k = 0</code> by default, which sets the main diagonal). For
<code>k &gt; 0</code>, the <code>k</code>-th upper-diagonal is used
(above the main diagonal, towards the top-right corner). For
<code>k &lt; 0</code>, the <code>k</code>-th lower-diagonal is used
(below the main diagonal, towards the bottom-left corner).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" tabindex="-1"></a>trimatu<span class="op">(</span>A<span class="op">)</span></span>
<span id="cb115-2"><a href="#cb115-2" tabindex="-1"></a>trimatu<span class="op">(</span>A<span class="op">,</span> k<span class="op">)</span></span>
<span id="cb115-3"><a href="#cb115-3" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" tabindex="-1"></a>trimatl<span class="op">(</span>A<span class="op">)</span></span>
<span id="cb115-5"><a href="#cb115-5" tabindex="-1"></a>trimatl<span class="op">(</span>A<span class="op">,</span> k<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-71">Examples<a class="anchor" aria-label="anchor" href="#examples-71"></a>
</h3>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles_matrix<span class="op">&lt;&gt;</span> <span class="va">trimatu1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb116-2"><a href="#cb116-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb116-3"><a href="#cb116-3" tabindex="-1"></a>  mat B <span class="op">=</span> trimatu<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb116-4"><a href="#cb116-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb116-5"><a href="#cb116-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trimatu_ind-trimatl_ind">Obtain indices of upper/lower triangular part<a class="anchor" aria-label="anchor" href="#trimatu_ind-trimatl_ind"></a>
</h2>
<p>The <code>trimatu_ind()</code> function returns a column vector
containing the indices of elements that form the upper triangular part
of a matrix <code>A</code>. The <code>trimatl_ind()</code> function
returns a column vector containing the indices of elements that form the
lower triangular part of a matrix <code>A</code>. The optional
<code>k</code> argument specifies the diagonal (<code>k = 0</code> by
default, which sets the main diagonal). For <code>k &gt; 0</code>, the
<code>k</code>-th upper-diagonal is used (above the main diagonal,
towards the top-right corner). For <code>k &lt; 0</code>, the
<code>k</code>-th lower-diagonal is used (below the main diagonal,
towards the bottom-left corner).</p>
<p>Usage:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" tabindex="-1"></a>trimatu_ind<span class="op">(</span>size<span class="op">(</span>A<span class="op">))</span></span>
<span id="cb117-2"><a href="#cb117-2" tabindex="-1"></a>trimatu_ind<span class="op">(</span>size<span class="op">(</span>A<span class="op">),</span> k<span class="op">)</span></span>
<span id="cb117-3"><a href="#cb117-3" tabindex="-1"></a></span>
<span id="cb117-4"><a href="#cb117-4" tabindex="-1"></a>trimatl_ind<span class="op">(</span>size<span class="op">(</span>A<span class="op">))</span></span>
<span id="cb117-5"><a href="#cb117-5" tabindex="-1"></a>trimatl_ind<span class="op">(</span>size<span class="op">(</span>A<span class="op">),</span> k<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-72">Examples<a class="anchor" aria-label="anchor" href="#examples-72"></a>
</h3>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers <span class="va">trimatu_ind1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb118-2"><a href="#cb118-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb118-3"><a href="#cb118-3" tabindex="-1"></a>  uvec B <span class="op">=</span> trimatu_ind<span class="op">(</span>size<span class="op">(</span>A<span class="op">));</span></span>
<span id="cb118-4"><a href="#cb118-4" tabindex="-1"></a>  <span class="cf">return</span> as_integers<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb118-5"><a href="#cb118-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="unique">Return unique elements<a class="anchor" aria-label="anchor" href="#unique"></a>
</h2>
<p>The <code><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique()</a></code> function returns the unique elements of a
vector or matrix <code>A</code>, sorted in ascending order. If
<code>A</code> is a vector, the output is also a vector with the same
orientation (row or column) as <code>A</code>. If <code>A</code> is a
matrix, the output is always a column vector.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" tabindex="-1"></a>unique<span class="op">(</span>A<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-73">Examples<a class="anchor" aria-label="anchor" href="#examples-73"></a>
</h3>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">unique1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb120-2"><a href="#cb120-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb120-3"><a href="#cb120-3" tabindex="-1"></a>  A<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> A<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb120-4"><a href="#cb120-4" tabindex="-1"></a>  vec B <span class="op">=</span> unique<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb120-5"><a href="#cb120-5" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb120-6"><a href="#cb120-6" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="vecnorm">Obtain vector norm of each row or column of a matrix<a class="anchor" aria-label="anchor" href="#vecnorm"></a>
</h2>
<p>The <code>vecnorm()</code> function computes the p-norm of each
column vector (when <code>dim = 0</code>) or row vector (when
<code>dim = 1</code>) of a matrix <code>X</code>. The optional
<code>p</code> argument specifies the norm to compute, with
<code>p = 2</code> (default) computing the 2-norm, <code>p = 1</code>
computing the 1-norm, <code>p = "inf"</code> computing the maximum norm,
and <code>p = "-inf"</code> computing the minimum quasi-norm.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" tabindex="-1"></a>vecnorm<span class="op">(</span>X<span class="op">)</span></span>
<span id="cb121-2"><a href="#cb121-2" tabindex="-1"></a>vecnorm<span class="op">(</span>X<span class="op">,</span> p<span class="op">)</span></span>
<span id="cb121-3"><a href="#cb121-3" tabindex="-1"></a>vecnorm<span class="op">(</span>X<span class="op">,</span> p<span class="op">,</span> dim<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-74">Examples<a class="anchor" aria-label="anchor" href="#examples-74"></a>
</h3>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">vecnorm1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb122-2"><a href="#cb122-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb122-3"><a href="#cb122-3" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" tabindex="-1"></a>  colvec a <span class="op">=</span> vecnorm<span class="op">(</span>A<span class="op">,</span> <span class="dv">2</span><span class="op">).</span>t<span class="op">();</span></span>
<span id="cb122-5"><a href="#cb122-5" tabindex="-1"></a>  colvec b <span class="op">=</span> vecnorm<span class="op">(</span>A<span class="op">,</span> <span class="st">"inf"</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb122-6"><a href="#cb122-6" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb122-8"><a href="#cb122-8" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb122-9"><a href="#cb122-9" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb122-10"><a href="#cb122-10" tabindex="-1"></a></span>
<span id="cb122-11"><a href="#cb122-11" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb122-12"><a href="#cb122-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="vectorise">Flatten matrix into vector<a class="anchor" aria-label="anchor" href="#vectorise"></a>
</h2>
<p>The <code>vectorise()</code> function generates a flattened version
of a matrix <code>M</code> or cube <code>Q</code>. The optional
<code>dim</code> argument specifies the dimension along which to flatten
the matrix, with <code>dim = 0</code> flattening column-wise (default)
and <code>dim = 1</code> flattening row-wise.</p>
<p>Usage:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" tabindex="-1"></a>vectorise<span class="op">(</span>M<span class="op">)</span></span>
<span id="cb123-2"><a href="#cb123-2" tabindex="-1"></a>vectorise<span class="op">(</span>M<span class="op">,</span> dim<span class="op">)</span></span>
<span id="cb123-3"><a href="#cb123-3" tabindex="-1"></a></span>
<span id="cb123-4"><a href="#cb123-4" tabindex="-1"></a>vectorise<span class="op">(</span>Q<span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="examples-75">Examples<a class="anchor" aria-label="anchor" href="#examples-75"></a>
</h3>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> doubles <span class="va">vectorise1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-2"><a href="#cb124-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb124-3"><a href="#cb124-3" tabindex="-1"></a>  vec B <span class="op">=</span> vectorise<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb124-4"><a href="#cb124-4" tabindex="-1"></a>  <span class="cf">return</span> as_doubles<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb124-5"><a href="#cb124-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="misc-functions">Miscellaneous element-wise functions: exp, log, sqrt, round, sign,
and others<a class="anchor" aria-label="anchor" href="#misc-functions"></a>
</h2>
<p>Miscellaneous element-wise functions include:</p>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp()</a></code></td>
<td>Base-e exponential: <code>e^x</code>
</td>
</tr>
<tr class="even">
<td><code>exp2()</code></td>
<td>Base-2 exponential: <code>2^x</code>
</td>
</tr>
<tr class="odd">
<td><code>exp10()</code></td>
<td>Base-10 exponential: <code>10^x</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">expm1()</a></code></td>
<td>Compute <code>exp(A)-1</code> accurately for values of
<code>A</code> close to zero (only for float and double elements)</td>
</tr>
<tr class="odd">
<td><code>trunc_exp()</code></td>
<td>Base-e exponential, truncated to avoid infinity (only for float and
double elements)</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log()</a></code></td>
<td>Natural log: <code>loge(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2()</a></code></td>
<td>Base-2 log: <code>log2(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log10()</a></code></td>
<td>Base-10 log: <code>log10(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Log.html" class="external-link">log1p()</a></code></td>
<td>Compute <code>log(1+A)</code> accurately for values of
<code>A</code> close to zero (only for float and double elements)</td>
</tr>
<tr class="even">
<td><code>trunc_log()</code></td>
<td>Natural log, truncated to avoid +/-infinity (only for float and
double elements)</td>
</tr>
<tr class="odd">
<td><code>square()</code></td>
<td>Square: <code>x^2</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt()</a></code></td>
<td>Square root: <code>x^(1.2)</code>
</td>
</tr>
<tr class="odd">
<td><code>cbrt()</code></td>
<td>Cube root: <code>x^(1/3)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Round.html" class="external-link">floor()</a></code></td>
<td>Largest integral value that is not greater than the input value</td>
</tr>
<tr class="odd">
<td><code>ceil()</code></td>
<td>Smallest integral value that is not less than the input value</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Round.html" class="external-link">round()</a></code></td>
<td>Round to nearest integer, with halfway cases rounded away from
zero</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Round.html" class="external-link">trunc()</a></code></td>
<td>Round to nearest integer, towards zero</td>
</tr>
<tr class="even">
<td><code>erf()</code></td>
<td>Error function (only for float and double elements)</td>
</tr>
<tr class="odd">
<td><code>erfc()</code></td>
<td>Complementary error function (only for float and double
elements)</td>
</tr>
<tr class="even">
<td><code>tgamma()</code></td>
<td>Gamma function (only for float and double elements)</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Special.html" class="external-link">lgamma()</a></code></td>
<td>Natural log of the absolute value of gamma function (only for float
and double elements)</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/sign.html" class="external-link">sign()</a></code></td>
<td>Signum function; for each element <code>a</code> in <code>A</code>,
the corresponding element <code>b</code> in <code>B</code> is:
<code>-1</code> if <code>a &lt; 0</code>, <code>0</code> if
<code>a = 0</code>, <code>+1</code> if <code>a &gt; 0</code>. If
<code>a</code> is complex and non-zero, then
<code>b = a / abs(a)</code>
</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="caveats-6">Caveats<a class="anchor" aria-label="anchor" href="#caveats-6"></a>
</h3>
<p>All of the above functions are applied element-wise, where each
element is treated independently. <code>expmat()</code>,
<code>logmat()</code>, <code>sqrtmat()</code>, and <code>powmat()</code>
take into account matrix structure.</p>
</div>
<div class="section level3">
<h3 id="examples-76">Examples<a class="anchor" aria-label="anchor" href="#examples-76"></a>
</h3>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">misc1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb125-2"><a href="#cb125-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb125-3"><a href="#cb125-3" tabindex="-1"></a>  mat B <span class="op">=</span> exp<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb125-4"><a href="#cb125-4" tabindex="-1"></a>  mat C <span class="op">=</span> log<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb125-5"><a href="#cb125-5" tabindex="-1"></a>  mat D <span class="op">=</span> sqrt<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb125-6"><a href="#cb125-6" tabindex="-1"></a>  mat E <span class="op">=</span> round<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb125-7"><a href="#cb125-7" tabindex="-1"></a>  mat F <span class="op">=</span> sign<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb125-8"><a href="#cb125-8" tabindex="-1"></a></span>
<span id="cb125-9"><a href="#cb125-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">6</span><span class="op">);</span></span>
<span id="cb125-10"><a href="#cb125-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb125-11"><a href="#cb125-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb125-12"><a href="#cb125-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb125-13"><a href="#cb125-13" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span></span>
<span id="cb125-14"><a href="#cb125-14" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>E<span class="op">);</span></span>
<span id="cb125-15"><a href="#cb125-15" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>F<span class="op">);</span></span>
<span id="cb125-16"><a href="#cb125-16" tabindex="-1"></a></span>
<span id="cb125-17"><a href="#cb125-17" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb125-18"><a href="#cb125-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="trig-functions">Trigonometric element-wise functions: cos, sin, tan, and others<a class="anchor" aria-label="anchor" href="#trig-functions"></a>
</h2>
<p>Trigonometric element-wise functions include:</p>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">cos()</a></code></td>
<td>Cosine: <code>cos(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">acos()</a></code></td>
<td>Inverse cosine: <code>arccos(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">cosh()</a></code></td>
<td>Hyperbolic cosine: <code>cosh(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">acosh()</a></code></td>
<td>Inverse hyperbolic cosine: <code>arccosh(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin()</a></code></td>
<td>Sine: <code>sin(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">asin()</a></code></td>
<td>Inverse sine: <code>arcsin(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">sinh()</a></code></td>
<td>Hyperbolic sine: <code>sinh(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">asinh()</a></code></td>
<td>Inverse hyperbolic sine: <code>arcsinh(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">tan()</a></code></td>
<td>Tangent: <code>tan(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">atan()</a></code></td>
<td>Inverse tangent: <code>arctan(x)</code>
</td>
</tr>
<tr class="odd">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">tanh()</a></code></td>
<td>Hyperbolic tangent: <code>tanh(x)</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Hyperbolic.html" class="external-link">atanh()</a></code></td>
<td>Inverse hyperbolic tangent: <code>arctanh(x)</code>
</td>
</tr>
<tr class="odd">
<td><code>sinc()</code></td>
<td>Sinc function:
<code>sinc(x) = sin(datum::pi * x) / (datum::pi * x)</code> for
<code>x != 0</code>, and <code>sinc(x) = 1</code> for
<code>x = 0</code>
</td>
</tr>
<tr class="even">
<td><code><a href="https://rdrr.io/r/base/Trig.html" class="external-link">atan2()</a></code></td>
<td>Two-argument arctangent: <code>atan2(y, x)</code>
</td>
</tr>
<tr class="odd">
<td><code>hypot()</code></td>
<td>Hypotenuse: <code>hypot(x, y)</code>
</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="caveats-7">Caveats<a class="anchor" aria-label="anchor" href="#caveats-7"></a>
</h3>
<p>All of the above functions are applied element-wise, where each
element is treated independently.</p>
</div>
<div class="section level3">
<h3 id="examples-77">Examples<a class="anchor" aria-label="anchor" href="#examples-77"></a>
</h3>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> list <span class="va">trig1_</span><span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb126-2"><a href="#cb126-2" tabindex="-1"></a>  mat A<span class="op">(</span>n<span class="op">,</span> n<span class="op">,</span> fill<span class="op">::</span>randu<span class="op">);</span></span>
<span id="cb126-3"><a href="#cb126-3" tabindex="-1"></a>  mat B <span class="op">=</span> cos<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb126-4"><a href="#cb126-4" tabindex="-1"></a>  mat C <span class="op">=</span> sin<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb126-5"><a href="#cb126-5" tabindex="-1"></a>  mat D <span class="op">=</span> tan<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb126-6"><a href="#cb126-6" tabindex="-1"></a>  mat E <span class="op">=</span> atan2<span class="op">(</span>C<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb126-7"><a href="#cb126-7" tabindex="-1"></a>  mat F <span class="op">=</span> hypot<span class="op">(</span>B<span class="op">,</span> C<span class="op">);</span></span>
<span id="cb126-8"><a href="#cb126-8" tabindex="-1"></a></span>
<span id="cb126-9"><a href="#cb126-9" tabindex="-1"></a>  writable<span class="op">::</span>list res<span class="op">(</span><span class="dv">6</span><span class="op">);</span></span>
<span id="cb126-10"><a href="#cb126-10" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>A<span class="op">);</span></span>
<span id="cb126-11"><a href="#cb126-11" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb126-12"><a href="#cb126-12" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb126-13"><a href="#cb126-13" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>D<span class="op">);</span></span>
<span id="cb126-14"><a href="#cb126-14" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>E<span class="op">);</span></span>
<span id="cb126-15"><a href="#cb126-15" tabindex="-1"></a>  res<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> as_doubles_matrix<span class="op">(</span>F<span class="op">);</span></span>
<span id="cb126-16"><a href="#cb126-16" tabindex="-1"></a></span>
<span id="cb126-17"><a href="#cb126-17" tabindex="-1"></a>  <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb126-18"><a href="#cb126-18" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Mauricio Vargas Sepulveda, Conrad Sanderson.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
