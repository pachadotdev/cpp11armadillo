<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="cpp11armadillo">
<title>Member functions and variables • cpp11armadillo</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Member functions and variables">
<meta property="og:description" content="cpp11armadillo">
<meta property="og:image" content="../cpp11armadillo/logo.svg">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">cpp11armadillo</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5.3</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/basic-usage.html">Basic 'cpp11armadillo' usage</a>
    <a class="dropdown-item" href="../articles/configuration.html">Armadillo configuration</a>
    <a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-dense.html">Decompositions, factorisations, inverses and equation solvers (dense matrices)</a>
    <a class="dropdown-item" href="../articles/decompositions-factorisations-inverses-and-equation-solvers-sparse.html">Decompositions, factorisations, inverses and equation solvers (sparse matrices)</a>
    <a class="dropdown-item" href="../articles/functions-of-vector-matrices-cubes.html">Functions of vectors, matrices, and cubes</a>
    <a class="dropdown-item" href="../articles/generated-vectors-matrices-cubes.html">Generated vectors, matrices, and cubes</a>
    <a class="dropdown-item" href="../articles/linear-model.html">Fitting regressions with Armadillo</a>
    <a class="dropdown-item" href="../articles/matrix-vector-cube-and-field-classes.html">Matrix, vector, cube and field classes</a>
    <a class="dropdown-item" href="../articles/member-functions-and-variables.html">Member functions and variables</a>
    <a class="dropdown-item" href="../articles/miscellaneous.html">Miscellaneous</a>
    <a class="dropdown-item" href="../articles/save-load.html">Saving and loading Armadillo objects on C++ side</a>
    <a class="dropdown-item" href="../articles/signal-and-image-processing.html">Signal and image processing</a>
    <a class="dropdown-item" href="../articles/sparse-matrices.html">Sparse matrices</a>
    <a class="dropdown-item" href="../articles/statistics-and-clustering.html">Statistics and clustering</a>
    <a class="dropdown-item" href="../articles/syntax-comparison-for-matlab-users.html">Syntax comparison for MATLAB/Octave users</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="nav-link" href="https://github.com/pachadotdev/cpp11armadillo/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">



<script src="member-functions-and-variables_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Member functions and variables</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/pachadotdev/cpp11armadillo/blob/HEAD/vignettes/member-functions-and-variables.Rmd"><code>vignettes/member-functions-and-variables.Rmd</code></a></small>
      <div class="d-none name"><code>member-functions-and-variables.Rmd</code></div>
    </div>

    
    
<p>This vignette is adapted from the official Armadillo <a href="https://arma.sourceforge.net/docs.html" class="external-link">documentation</a>.</p>
<div class="section level2">
<h2 id="attributes">Attributes<a class="anchor" aria-label="anchor" href="#attributes"></a>
</h2>
<p><code>n_*</code> provides information for different objects:</p>
<ul>
<li>
<code>.n_rows</code> number of rows for <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code>, and <code>SpMat</code>.</li>
<li>
<code>.n_cols</code> number of columns for <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code>, and <code>SpMat</code>.</li>
<li>
<code>.n_elem</code> total number of elements for <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code>, and <code>SpMat</code>.</li>
<li>
<code>.n_slices</code> number of slices for <code>Cube</code> and <code>field</code>.</li>
<li>
<code>.n_nonzero</code> number of non-zero elements for <code>SpMat</code>.</li>
</ul>
<p>For the <code>Col</code> and <code>Row</code> classes, <code>n_elem</code> also indicates vector length.</p>
<p>The variables are read-only and of type <code>uword</code>. To change the size, use <code>set_size</code>, <code>copy_size</code>, <code>zeros_member</code>, <code>ones_member</code>, or <code>reset</code>.</p>
<p>To avoid compiler warnings about implicit conversion when operating <code>uword</code> with <code>integers</code>/<code>doubles</code> to pass data to R, converte <code>uword</code> to <code>int</code> with <code>static_cast&lt;int&gt;</code> or declare these as <code>int</code>.</p>
<div class="section level3">
<h3 id="examples">Examples<a class="anchor" aria-label="anchor" href="#examples"></a>
</h3>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">attr1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="co">// uword or int can be used</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="dt">int</span> n_rows = A.n_rows;  <span class="co">// number of rows</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="dt">int</span> n_cols = A.n_cols;  <span class="co">// number of columns</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="dt">int</span> n_elem = A.n_elem;  <span class="co">// number of elements</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  writable::integers res({n_rows, n_cols, n_elem});</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"n_rows"</span>, <span class="st">"n_cols"</span>, <span class="st">"n_elem"</span>});</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="elementobject-access">Element/object access<a class="anchor" aria-label="anchor" href="#elementobject-access"></a>
</h2>
<p>Provide access to individual elements or objects stored in a container object (e.g., <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code>).</p>
<ul>
<li>
<code>(i)</code> For <code>vec</code> and <code>rowvec</code>, access the element stored at index <code>i</code>. For <code>Mat</code>, <code>Cube</code> and <code>field</code>, access the element/object stored at index <code>i</code> under the assumption of a flat layout, with column-major ordering of data (e.g., column by column). An exception is thrown if the requested element is out of bounds.</li>
<li>
<code>.at(i)</code> or <code>[i]</code> As for <code>(i)</code>, but without a bounds check. Not recommended.</li>
<li>
<code>(r,c)</code> For <code>Mat</code> and 2D field classes, access the element/object stored at row <code>r</code> and column <code>c</code>. An exception is thrown if the requested element is out of bounds.</li>
<li>
<code>.at(r,c)</code> As for <code>(r,c)</code>, but without a bounds check. Not recommended.</li>
<li>
<code>(r,c,s)</code> For <code>Cube</code> and 3D field classes, access the element/object stored at row <code>r</code>, column <code>c</code>, and slice <code>s</code>. An exception is thrown if the requested element is out of bounds.</li>
<li>
<code>.at(r,c,s)</code> As for <code>(r,c,s)</code>, but without a bounds check. Not recommended.</li>
</ul>
<div class="section level3">
<h3 id="examples-1">Examples<a class="anchor" aria-label="anchor" href="#examples-1"></a>
</h3>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">access1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  A(<span class="dv">1</span>,<span class="dv">1</span>) = <span class="fl">123.0</span>;     <span class="co">// set element at row 2, column 2</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  vec B(<span class="dv">2</span>, fill::randu);</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  <span class="dt">double</span> x = A(<span class="dv">0</span>,<span class="dv">1</span>);  <span class="co">// copy element at row 1, column 2 to a double</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  <span class="dt">double</span> y = B(<span class="dv">1</span>);    <span class="co">// copy element at coordinate 2 to a double</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  uword i, j; <span class="co">// int also works</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>  uword N = A.n_rows;</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  uword M = A.n_cols;</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  <span class="cf">for</span>(i = <span class="dv">0</span>; i &lt; N; ++i) {</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    <span class="cf">for</span>(j = <span class="dv">0</span>; j &lt; M; ++j) {</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>      A(i,j) = A(i,j) + x + y;</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    }</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  }</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// convert from C++ to R</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats">Caveats<a class="anchor" aria-label="anchor" href="#caveats"></a>
</h3>
<p>For <code>.at()</code> or <code>[i]</code>, <code>.at(r,c)</code> and <code>.at(r,c,s)</code>:</p>
<ul>
<li>Indexing in C++ starts at 0</li>
<li>Accessing elements without bounds checks is slightly faster, but is not recommended until your code has been thoroughly debugged first</li>
<li>Accessing elements via <code>[r,c]</code> and <code>[r,c,s]</code> does not work correctly in C++; instead use <code>(r,c)</code> and <code>(r,c,s)</code>
</li>
</ul>
<p>The indices of elements are specified via the <code>uword</code> type, which is a <code>typedef</code> for an unsigned integer type. When using loops to access elements, it more efficient to use <code>uword</code> instead of <code>int</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="element-initialisation">Element initialisation<a class="anchor" aria-label="anchor" href="#element-initialisation"></a>
</h2>
<p>Set elements in <code>Mat</code>, <code>Col</code> and <code>Row</code> via braced initialiser lists.</p>
<div class="section level3">
<h3 id="examples-2">Examples<a class="anchor" aria-label="anchor" href="#examples-2"></a>
</h3>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">initialization1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  mat B = {{<span class="dv">1</span>, <span class="dv">2</span>}, {<span class="dv">3</span>, <span class="dv">4</span>}}; <span class="co">// create new matrix</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>  vec C = {<span class="dv">1</span>, <span class="dv">2</span>}; <span class="co">// create new column vector</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>  <span class="co">// sum C to the diagonal of A</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  A(<span class="dv">0</span>,<span class="dv">0</span>) = A(<span class="dv">0</span>,<span class="dv">0</span>) + C(<span class="dv">0</span>);</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  A(<span class="dv">1</span>,<span class="dv">1</span>) = A(<span class="dv">1</span>,<span class="dv">1</span>) + C(<span class="dv">1</span>);</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  mat D = A + B;</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>  </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="zeros">Zeros<a class="anchor" aria-label="anchor" href="#zeros"></a>
</h2>
<p>Set the elements of an object to zero, optionally first changing the size to specified dimensions.</p>
<p><code>.zeros()</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>SpMat</code>, <code>Cube</code>) <code>.zeros(n_elem)</code> (member function of <code>Col</code> and <code>Row</code>) <code>.zeros(n_rows, n_cols)</code> (member function of <code>Mat</code> and <code>SpMat</code>) <code>.zeros(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>) <code>.zeros(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>)</p>
<div class="section level3">
<h3 id="examples-3">Examples<a class="anchor" aria-label="anchor" href="#examples-3"></a>
</h3>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">zeros1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  A.zeros();          <span class="co">// set all elements to zero</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  B.zeros(size(A)); <span class="co">// set size to be the same as A and set all elements to zero</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::zeros);</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="ones">Ones<a class="anchor" aria-label="anchor" href="#ones"></a>
</h2>
<p>Set all the elements of an object to one, optionally first changing the size to specified dimensions.</p>
<table class="table">
<thead><tr class="header">
<th>Function</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.ones()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.ones(n_elem)</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td><code>.ones(n_rows, n_cols)</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>.ones(n_rows, n_cols, n_slices)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.ones(size(X))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="examples-4">Examples<a class="anchor" aria-label="anchor" href="#examples-4"></a>
</h3>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">ones1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  A.ones();          <span class="co">// set all elements to zero</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  B.ones(size(A)); <span class="co">// set size to be the same as A and set all elements to zero</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::ones);</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="eye">Eye<a class="anchor" aria-label="anchor" href="#eye"></a>
</h2>
<p><code>.eye()</code> is member function of <code>Mat</code> and <code>SpMat</code>. <code>.eye(n_rows, n_cols)</code> sets the elements along the main diagonal to one and off-diagonal elements to zero, optionally first changing the size to specified dimensions. <code>.eye(size(X))</code> creates an identity matrix is generated when <code>n_rows = n_cols</code>.</p>
<div class="section level3">
<h3 id="examples-5">Examples<a class="anchor" aria-label="anchor" href="#examples-5"></a>
</h3>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">eye1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  A.eye();            <span class="co">// create an identity matrix</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>  B.eye(size(A)); <span class="co">// another identity matrix</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  uword N = A.n_rows;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>  uword M = A.n_cols;</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  mat C(N, M, fill::randu);</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>  C.eye(N, M); <span class="co">// yet another identity matrix</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="random-uniform">Random uniform<a class="anchor" aria-label="anchor" href="#random-uniform"></a>
</h2>
<p>Set all the elements to random values from a uniform distribution in the [0,1] interval, optionally first changing the size to specified dimensions.</p>
<p>For complex elements, the real and imaginary parts are treated separately.</p>
<table class="table">
<thead><tr class="header">
<th>Function/Method</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.randu()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.randu(n_elem)</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td><code>.randu(n_rows, n_cols)</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>.randu(n_rows, n_cols, n_slices)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.randu(size(X))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randu1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  mat B;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  B.randu(size(A)); <span class="co">// random uniform matrix with the same size as A</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::randu);</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>}</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randu2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>  GetRNGstate();  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>  mat y(n, n);</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>  ::arma_rng::randu&lt;<span class="dt">double</span>&gt;::fill(y.memptr(), y.n_elem);</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>  PutRNGstate();</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(y);</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="normal-distribution">Normal distribution<a class="anchor" aria-label="anchor" href="#normal-distribution"></a>
</h2>
<p>Set all the elements to random values from a normal distribution with zero mean and unit variance, optionally first changing the size to specified dimensions.</p>
<p>For complex elements, the real and imaginary parts are treated separately.</p>
<table class="table">
<thead><tr class="header">
<th>Function/Method</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.randn()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.randn(n_elem)</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td><code>.randn(n_rows, n_cols)</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>.randn(n_rows, n_cols, n_slices)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.randn(size(X))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="examples-6">Examples<a class="anchor" aria-label="anchor" href="#examples-6"></a>
</h3>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randn1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  mat B;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  B.randn(size(A)); <span class="co">// random normal matrix with the same size as A</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>  mat C(A.n_rows, A.n_cols, fill::randn);</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>  mat D = A + B + C;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(D);  <span class="co">// convert from C++ to R</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>}</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">randn2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>  GetRNGstate();  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>  mat y(n, n);</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>  ::arma_rng::randn&lt;<span class="dt">double</span>&gt;::fill(y.memptr(), y.n_elem);</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>  PutRNGstate();</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>  </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(y);</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="fill">Fill<a class="anchor" aria-label="anchor" href="#fill"></a>
</h2>
<p>Sets the elements to a specified value</p>
<p><code>.fill(value)</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>field</code>.</p>
<p>The type of value must match the type of elements used by the container object (e.g., for <code>Mat</code> the type is <code>double</code>)</p>
<div class="section level3">
<h3 id="examples-7">Examples<a class="anchor" aria-label="anchor" href="#examples-7"></a>
</h3>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">fill1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  uword N = A.n_rows;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>  uword M = A.n_cols;</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>  mat B(size(A), fill::value(<span class="fl">200.0</span>));  <span class="co">// create a matrix filled with 200.0</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>  mat C(N, M, fill::value(<span class="fl">100.0</span>));     <span class="co">// matrix filled with 100.0</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>  mat D(N, M, fill::zeros);            <span class="co">// matrix filled with zeros</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>  mat E(N, M, fill::ones);             <span class="co">// matrix filled with ones</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>  mat F = A + B + C + D + E;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(F);  <span class="co">// convert from C++ to R</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="imbue">Imbue<a class="anchor" aria-label="anchor" href="#imbue"></a>
</h2>
<p><code>.imbue(functor)</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code> and <code>Cube</code>, it fills the elements with values provided by a functor. The argument can be a functor or lambda function.</p>
<p>For matrices, filling is done column-by-column (e.g., column 0 is filled, then column 1, etc.)</p>
<p>For cubes, filling is done slice-by-slice, with each slice treated as a matrix</p>
<div class="section level3">
<h3 id="examples-8">Examples<a class="anchor" aria-label="anchor" href="#examples-8"></a>
</h3>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">imbue1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// convert from R to C++</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  <span class="bu">std::</span>mt19937 engine;  <span class="co">// Mersenne twister random number engine</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>  <span class="bu">std::</span>uniform_real_distribution&lt;<span class="dt">double</span>&gt; distr(<span class="fl">0.0</span>, <span class="fl">1.0</span>);</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>  mat B(size(A), fill::none);                <span class="co">// create an empty matrix</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>  B.imbue([&amp;]() { <span class="cf">return</span> distr(engine); });  <span class="co">// fill with random values</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>  mat C = A + B;</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(C);  <span class="co">// convert from C++ to R</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>}</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">imbue2_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a) {</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>  GetRNGstate();  <span class="co">// Ensure R's RNG state is synchronized</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>  mat A = as_Mat(a);  <span class="co">// Convert from R to C++</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>  mat B(size(A), fill::none);  <span class="co">// Create an empty matrix</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>  B.imbue([]() { <span class="cf">return</span> unif_rand(); });  <span class="co">// Fill with random values</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>  mat C = A + B;</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>  PutRNGstate();</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(C);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="clean">Clean<a class="anchor" aria-label="anchor" href="#clean"></a>
</h2>
<p><code>.clean(threshold)</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, and <code>SpMat</code>. It can be used to sparsify a matrix, in the sense of zeroing values with small magnitudes.</p>
<ul>
<li>For objects with non-complex elements: each element with an absolute value less or equal to the threshold is replaced by zero.</li>
<li>For objects with complex elements: for each element, each component (real and imaginary) with an absolute value less or equal to the threshold is replaced by zero.</li>
</ul>
<div class="section level3">
<h3 id="examples-9">Examples<a class="anchor" aria-label="anchor" href="#examples-9"></a>
</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">clean1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  mat A(n, n, fill::randu); <span class="co">// create a random matrix</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>  A(<span class="dv">0</span>, <span class="dv">0</span>) = datum::eps; <span class="co">// set the diagonal with small values (+/- epsilon)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  A(<span class="dv">1</span>, <span class="dv">1</span>) = -datum::eps;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  A.clean(datum::eps); <span class="co">// set elements with small values to zero</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat">Caveat<a class="anchor" aria-label="anchor" href="#caveat"></a>
</h3>
<p>To explicitly convert from dense storage to sparse storage, use the <code>SpMat</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="replace">Replace<a class="anchor" aria-label="anchor" href="#replace"></a>
</h2>
<p><code>.replace( old_value, new_value )</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, and <code>SpMat</code>.</p>
<p>For all elements equal to <code>old_value</code>, set them to <code>new_value</code>.</p>
<div class="section level3">
<h3 id="examples-10">Examples<a class="anchor" aria-label="anchor" href="#examples-10"></a>
</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">replace1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  mat A(n, n, fill::randu); <span class="co">// create a random matrix</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  A.diag().fill(datum::nan); <span class="co">// set the diagonal with NaN values</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  A.replace(datum::nan, <span class="dv">0</span>);  <span class="co">// replace each NaN with 0</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-1">Caveats<a class="anchor" aria-label="anchor" href="#caveats-1"></a>
</h3>
<ul>
<li>The type of <code>old_value</code> and <code>new_value</code> must match the type of elements used by the container object (e.g., for <code>Mat</code> the type is <code>double</code>).</li>
<li>Floating point numbers (<code>float</code> and <code>double</code>) are approximations due to their <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" class="external-link">limited precision</a>.</li>
<li>For sparse matrices (<code>SpMat</code>), replacement is not done when <code>old_value = 0</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="clamp">Clamp<a class="anchor" aria-label="anchor" href="#clamp"></a>
</h2>
<p><code>.clamp(min_value, max_value)</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code> and <code>SpMat</code> that transforms all values lower than <code>min_val</code> to <code>min_val</code>, and all values higher than <code>max_val</code> to <code>max_val</code>.</p>
<ul>
<li>For complex elements, the real and imaginary components are clamped separately.</li>
<li>For sparse matrices, clamping is applied only to the non-zero elements.</li>
</ul>
<div class="section level3">
<h3 id="examples-11">Examples<a class="anchor" aria-label="anchor" href="#examples-11"></a>
</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">clamp1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  mat A(n, n, fill::randu); <span class="co">// create a random matrix</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  A.diag().fill(<span class="fl">0.1</span>);       <span class="co">// set the diagonal with 0.1 values</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  A.clamp(<span class="fl">0.2</span>, <span class="fl">0.8</span>); <span class="co">// clamp values to the [0.2, 0.8] interval</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="transform">Transform<a class="anchor" aria-label="anchor" href="#transform"></a>
</h2>
<p><code>.transform(functor)</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, and <code>SpMat</code>. The argument can be a functor or lambda function.</p>
<ul>
<li>For dense matrices, transformation is done column-by-column for all elements.</li>
<li>For sparse matrices, transformation is done column-by-column for non-zero elements.</li>
<li>For cubes, transformation is done slice-by-slice, with each slice treated as a matrix.</li>
</ul>
<div class="section level3">
<h3 id="examples-12">Examples<a class="anchor" aria-label="anchor" href="#examples-12"></a>
</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">transform1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  mat A(n, n, fill::ones);  <span class="co">// create a matrix filled with ones</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  A.transform([](<span class="dt">double</span> val) { <span class="cf">return</span> (val + <span class="fl">122.0</span>); });</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A); <span class="co">// Convert from C++ to R</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="for-each">For each<a class="anchor" aria-label="anchor" href="#for-each"></a>
</h2>
<p><code>.for_each(functor)</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>, and <code>field</code>. The argument can be a functor or lambda function.</p>
<ul>
<li>For dense matrices and fields, the processing is done column-by-column for all elements.</li>
<li>For sparse matrices, the processing is done column-by-column for non-zero elements.</li>
<li>For cubes, processing is done slice-by-slice, with each slice treated as a matrix.</li>
</ul>
<div class="section level3">
<h3 id="examples-13">Examples<a class="anchor" aria-label="anchor" href="#examples-13"></a>
</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">for_each1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  <span class="co">// add 122 to each element in a dense matrix, the '&amp;' is important</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>  mat D(n, n, fill::ones);</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>  D.for_each([](mat::<span class="dt">elem_type</span>&amp; val) { val += <span class="fl">122.0</span>; });</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>  <span class="co">// add 122 to each non-zero element in a sparse matrix</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>  sp_mat S;</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>  S.sprandu(n, n, <span class="fl">1.0</span>);</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>  S.for_each([](sp_mat::<span class="dt">elem_type</span>&amp; val) { val += <span class="fl">123.0</span>; });</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a>  <span class="co">// set the size of all matrices in a field</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a>  field&lt;mat&gt; F(<span class="dv">2</span>, <span class="dv">2</span>);</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a>  F.for_each([n](mat&amp; X) { X.zeros(n, n); });  <span class="co">// capture n for the lambda</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a>  mat res = D + S + F(<span class="dv">0</span>) + F(<span class="dv">1</span>);</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="set-size">Set size<a class="anchor" aria-label="anchor" href="#set-size"></a>
</h2>
<p>Change the size of an object, without explicitly preserving data and without initialising the elements (e.g., elements may contain garbage values, including <code>NaN</code>).</p>
<ul>
<li>
<code>.set_size(n_elem)</code> (member function of <code>Col</code>, <code>Row</code>, <code>field</code>)</li>
<li>
<code>.set_size(n_rows, n_cols)</code> (member function of <code>Mat</code>, <code>SpMat</code>, <code>field</code>)</li>
<li>
<code>.set_size(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code> and <code>field</code>)</li>
<li>
<code>.set_size(size(X))</code> (member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>, <code>field</code>)</li>
</ul>
<p>To initialise the elements to zero while changing the size, use <code>.zeros()</code> instead. To explicitly preserve data while changing the size, use <code>.reshape()</code> or <code>.resize()</code> instead.</p>
<div class="section level3">
<h3 id="examples-14">Examples<a class="anchor" aria-label="anchor" href="#examples-14"></a>
</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">set_size1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>  mat A;</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  A.set_size(n, n);  <span class="co">// or:  mat A(n, n, fill::none);</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>  mat B;</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>  B.set_size(size(A));  <span class="co">// or:  mat B(size(A), fill::none);</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>  vec C;</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>  C.set_size(n);  <span class="co">// or:  vec v(n, fill::none);</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>  A.fill(<span class="fl">1.0</span>);  <span class="co">// set all elements to 1.0</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>  B.fill(<span class="fl">2.0</span>);  <span class="co">// set all elements to 2.0</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>  C.fill(<span class="fl">3.0</span>);  <span class="co">// set all elements to 3.0</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>  vec res = A.col(<span class="dv">0</span>) + B.col(<span class="dv">1</span>) + C;</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="reshape">Reshape<a class="anchor" aria-label="anchor" href="#reshape"></a>
</h2>
<p>Recreate an object according to given size specifications, with the elements taken from the previous version of the object in a column-wise manner. The elements in the generated object are placed column-wise (e.g., the first column is filled up before filling the second column)</p>
<ul>
<li>
<code>.reshape(n_rows, n_cols)</code> (member function of <code>Mat</code> and <code>SpMat</code>)</li>
<li>
<code>.reshape(n_rows, n_cols, n_slices)</code> (member function of <code>Cube</code>)</li>
<li>
<code>.reshape(size(X))</code> (member function of <code>Mat</code>, <code>Cube</code>, <code>SpMat</code>)</li>
</ul>
<p>The layout of the elements in the recreated object will be different to the layout in the previous version of the object</p>
<p>If the total number of elements in the previous version of the object is less than the specified size, the extra elements in the recreated object are set to zero</p>
<p>If the total number of elements in the previous version of the object is greater than the specified size, only a subset of the elements is taken</p>
<div class="section level3">
<h3 id="examples-15">Examples<a class="anchor" aria-label="anchor" href="#examples-15"></a>
</h3>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">reshape1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  mat A(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::randu);</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>  A.reshape(n - <span class="dv">1</span>, n + <span class="dv">1</span>);</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-2">Caveats<a class="anchor" aria-label="anchor" href="#caveats-2"></a>
</h3>
<ul>
<li>
<code>.reshape()</code> is considerably slower than <code>.set_size()</code>.</li>
<li>To change the size without preserving data, use <code>.set_size()</code>.</li>
<li>To grow/shrink the object while preserving the elements and the layout of the elements, use <code>.resize()</code>
</li>
<li>To flatten a matrix into a vector, use <code>vectorise()</code> or <code>.as_col()</code>/<code>.as_row()</code>.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="resize">Resize<a class="anchor" aria-label="anchor" href="#resize"></a>
</h2>
<p>Resize an object according to given size specifications, while preserving the elements and the layout of the elements. It can be used for growing or shrinking an object (e.g., adding/removing rows, and/or columns, and/or slices).</p>
<ul>
<li>
<code>.resize(n_elem)</code>: member function of <code>Col</code>, <code>Row</code>.</li>
<li>
<code>.resize(n_rows, n_cols)</code>: member function of <code>Mat</code> and <code>SpMat</code>.</li>
<li>
<code>.resize(n_rows, n_cols, n_slices)</code>: member function of <code>Cube</code>.</li>
<li>
<code>.resize(size(X))</code>: member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>.</li>
</ul>
<div class="section level3">
<h3 id="examples-16">Examples<a class="anchor" aria-label="anchor" href="#examples-16"></a>
</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">resize1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  mat A(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::randu);</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  A.resize(n - <span class="dv">1</span>, n + <span class="dv">1</span>);</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-3">Caveats<a class="anchor" aria-label="anchor" href="#caveats-3"></a>
</h3>
<ul>
<li>
<code>.resize()</code> is considerably slower than <code>.set_size()</code>.</li>
<li>to change the size without preserving data, <code>.set_size()</code> instead.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="copy-size">Copy size<a class="anchor" aria-label="anchor" href="#copy-size"></a>
</h2>
<p><code>.copy_size(A)</code> sets the size of a matrix/vector/cube to be the same as matrix/vector/cube <code>A</code>.</p>
<div class="section level3">
<h3 id="examples-17">Examples<a class="anchor" aria-label="anchor" href="#examples-17"></a>
</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">copy_size1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>  mat B;</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>  B.copy_size(A);</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  <span class="dt">int</span> N = B.n_rows;</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>  <span class="dt">int</span> M = B.n_cols;</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>  </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>  writable::integers res({N, M});</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"n_rows"</span>, <span class="st">"n_cols"</span>});</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-1">Caveat<a class="anchor" aria-label="anchor" href="#caveat-1"></a>
</h3>
<p>To set the size of an object <code>B</code>, <code>A</code> must be of the same type as <code>B</code>. For example, the size of a matrix cannot be set by providing a cube.</p>
</div>
</div>
<div class="section level2">
<h2 id="reset">Reset<a class="anchor" aria-label="anchor" href="#reset"></a>
</h2>
<p><code>.reset()</code> sets a matrix/vector size to zero (the object will have no elements).</p>
<div class="section level3">
<h3 id="examples-18">Examples<a class="anchor" aria-label="anchor" href="#examples-18"></a>
</h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">reset1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>  A.reset();</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>  <span class="dt">int</span> N = A.n_rows;</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a>  <span class="dt">int</span> M = A.n_cols;</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>  </span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>  writable::integers res({N, M});</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"n_rows"</span>, <span class="st">"n_cols"</span>});</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a>  <span class="cf">return</span> as_integers(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="submatrix-views">Submatrix views<a class="anchor" aria-label="anchor" href="#submatrix-views"></a>
</h2>
<p>A collection of member functions of <code>Mat</code>, <code>Col</code> and <code>Row</code> classes that provide read/write access to submatrix views.</p>
<div class="section level3">
<h3 id="contiguous-views-for-matrix">Contiguous views for matrix<a class="anchor" aria-label="anchor" href="#contiguous-views-for-matrix"></a>
</h3>
<ul>
<li><code>X.col(col_number)</code></li>
<li><code>X.row(row_number)</code></li>
<li>
<code>X.cols(first_col, last_col)</code><br>
</li>
<li><code>X.rows(first_row, last_row)</code></li>
<li><code>X.submat(first_row, first_col, last_row, last_col)</code></li>
<li><code>X(span(first_row, last_row), span(first_col, last_col))</code></li>
<li><code>X(first_row, first_col, size(n_rows, n_cols))</code></li>
<li>
<code>X(first_row, first_col, size(Y))</code> (<code>Y</code> is a matrix)</li>
<li><code>X(span(first_row, last_row), col_number)</code></li>
<li><code>X(row_number, span(first_col, last_col))</code></li>
<li><code>X.head_cols(number_of_cols)</code></li>
<li><code>X.head_rows(number_of_rows)</code></li>
<li><code>X.tail_cols(number_of_cols)</code></li>
<li><code>X.tail_rows(number_of_rows)</code></li>
<li>
<code>X.unsafe_col(col_number)</code> (use with caution)</li>
</ul>
</div>
<div class="section level3">
<h3 id="contiguous-views-for-vector">Contiguous views for vector<a class="anchor" aria-label="anchor" href="#contiguous-views-for-vector"></a>
</h3>
<ul>
<li><code>Y(span(first_index, last_index))</code></li>
<li><code>Y.subvec(first_index, last_index)</code></li>
<li>
<code>Y.subvec(first_index, size(X))</code> (<code>X</code> is a vector)<br>
</li>
<li><code>Y.head(number_of_elements)</code></li>
<li><code>Y.tail(number_of_elements)</code></li>
</ul>
</div>
<div class="section level3">
<h3 id="non-contiguous-views-for-matrix-or-vector">Non-contiguous views for matrix or vector:<a class="anchor" aria-label="anchor" href="#non-contiguous-views-for-matrix-or-vector"></a>
</h3>
<ul>
<li><code>X.elem(vector_of_indices)</code></li>
<li><code>X(vector_of_indices)</code></li>
<li><code>X.cols(vector_of_column_indices)</code></li>
<li><code>X.rows(vector_of_row_indices)</code></li>
<li><code>X.submat(vector_of_row_indices, vector_of_column_indices)</code></li>
<li><code>X(vector_of_row_indices, vector_of_column_indices)</code></li>
</ul>
<p>Instances of <code>span(start, end)</code> can be replaced by <code>span::all_</code> to indicate the entire range.</p>
<p>For functions requiring one or more vector of indices, for example <code>X.submat(vector_of_row_indices, vector_of_column_indices)</code>, each vector of indices must be of type <code>uvec</code>.</p>
<p>In the function <code>X.elem(vector_of_indices)</code>, elements specified in <code>vector_of_indices</code> are accessed. <code>X</code> is interpreted as one long vector, with column-by-column ordering of the elements of <code>X</code>. The <code>vector_of_indices</code> must evaluate to a vector of type <code>uvec</code> (e.g., generated by the <code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function). The aggregate set of the specified elements is treated as a column vector (e.g., the output of <code>X.elem()</code> is always a column vector).</p>
<p>The function <code>.unsafe_col()</code> is provided for speed reasons and should be used only if you know what you are doing. It creates a seemingly independent <code>Col</code> vector object (e.g., <code>vec</code>), but uses memory from the existing matrix object. As such, the created vector is not alias safe, and does not take into account that the underlying matrix memory could be freed (e.g., due to any operation involving a size change of the matrix).</p>
</div>
<div class="section level3">
<h3 id="examples-19">Examples<a class="anchor" aria-label="anchor" href="#examples-19"></a>
</h3>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">subview1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>  mat A(n, n, fill::zeros);</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  A.submat(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) = randu&lt;mat&gt;(<span class="dv">3</span>,<span class="dv">3</span>);</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>  A(span(<span class="dv">0</span>,<span class="dv">2</span>), span(<span class="dv">1</span>,<span class="dv">3</span>)) = randu&lt;mat&gt;(<span class="dv">3</span>,<span class="dv">3</span>);</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>  A(<span class="dv">0</span>,<span class="dv">1</span>, size(<span class="dv">3</span>,<span class="dv">3</span>)) = randu&lt;mat&gt;(<span class="dv">3</span>,<span class="dv">3</span>);</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>  mat B = A.submat(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>  mat C = A(span(<span class="dv">0</span>,<span class="dv">2</span>), span(<span class="dv">1</span>,<span class="dv">3</span>) );</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a>  mat D = A(<span class="dv">0</span>, <span class="dv">1</span>, size(<span class="dv">3</span>,<span class="dv">3</span>) );</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a>  A.col(<span class="dv">1</span>) = randu&lt;mat&gt;(<span class="dv">5</span>,<span class="dv">1</span>);</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a>  A(span::all, <span class="dv">1</span>) = randu&lt;mat&gt;(<span class="dv">5</span>,<span class="dv">1</span>);</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true"></a>  mat X(<span class="dv">5</span>, <span class="dv">5</span>, fill::randu);</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true"></a>    </span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true"></a>  <span class="co">// get all elements of X that are greater than 0.5</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true"></a>  vec q = X.elem( find(X &gt; <span class="fl">0.5</span>) );</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true"></a>    </span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true"></a>  <span class="co">// add 123 to all elements of X greater than 0.5</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true"></a>  X.elem( find(X &gt; <span class="fl">0.5</span>) ) += <span class="fl">123.0</span>;</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true"></a>    </span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true"></a>  <span class="co">// set four specific elements of X to 1</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true"></a>  uvec indices = { <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">8</span> };</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true"></a>    </span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true"></a>  X.elem(indices) = ones&lt;vec&gt;(<span class="dv">4</span>);</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true"></a>    </span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true"></a>  <span class="co">// add 123 to the last 5 elements of vector a</span></span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true"></a>  vec a(<span class="dv">10</span>, fill::randu);</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true"></a>  a.tail(<span class="dv">5</span>) += <span class="fl">123.0</span>;</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true"></a>    </span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true"></a>  <span class="co">// add 123 to the first 3 elements of column 2 of X</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true"></a>  X.col(<span class="dv">2</span>).head(<span class="dv">3</span>) += <span class="dv">123</span>;</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true"></a></span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="subcube-views-and-slices">Subcube views and slices<a class="anchor" aria-label="anchor" href="#subcube-views-and-slices"></a>
</h2>
<p>A collection of member functions of the <code>Cube</code> class that provide subcube views.</p>
<div class="section level3">
<h3 id="contiguous-views-for-cube">Contiguous views for cube<a class="anchor" aria-label="anchor" href="#contiguous-views-for-cube"></a>
</h3>
<ul>
<li><code>Q.slice(slice_number)</code></li>
<li><code>Q.slices(first_slice, last_slice)</code></li>
<li><code>Q.row(row_number)</code></li>
<li><code>Q.rows(first_row, last_row)</code></li>
<li><code>Q.col(col_number)</code></li>
<li><code>Q.cols(first_col, last_col)</code></li>
<li><code>Q.subcube( first_row, first_col, first_slice, last_row, last_col, last_slice)</code></li>
<li><code>Q(span(first_row, last_row), span(first_col, last_col), span(first_slice, last_slice))</code></li>
<li><code>Q(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></li>
<li>
<code>Q(first_row, first_col, first_slice, size(R))</code> (<code>R</code> is a cube)<br>
</li>
<li><code>Q.head_slices(number_of_slices)</code></li>
<li><code>Q.tail_slices(number_of_slices)</code></li>
<li><code>Q.tube(row, col)</code></li>
<li><code>Q.tube(first_row, first_col, last_row, last_col)</code></li>
<li><code>Q.tube(span(first_row, last_row), span(first_col, last_col))</code></li>
<li><code>Q.tube(first_row, first_col, size(n_rows, n_cols))</code></li>
</ul>
</div>
<div class="section level3">
<h3 id="non-contiguous-views-for-cube">Non-contiguous views for cube<a class="anchor" aria-label="anchor" href="#non-contiguous-views-for-cube"></a>
</h3>
<p><code>Q.elem(vector_of_indices)</code>, <code>Q(vector_of_indices)</code>, and <code>Q.slices( vector_of_slice_indices)</code> are instances of <code>span(a,b)</code> that can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code>, to indicate the entire range.</li>
<li>
<code>span(a)</code>, to indicate a particular row, column or slice.</li>
</ul>
<p>An individual slice, accessed via <code>.slice()</code>, is an instance of the <code>Mat</code> class (a reference to a matrix is provided).</p>
<p>All <code>.tube()</code> forms are variants of <code>.subcube()</code>, using <code>first_slice = 0</code> and <code>last_slice = Q.n_slices-1</code>. The <code>.tube(row,col)</code> form uses <code>row = first_row = last_row</code>, and <code>col = first_col = last_col</code>.</p>
<p>In the function <code>Q.elem(vector_of_indices)</code>, elements specified in <code>vector_of_indices</code> are accessed. <code>Q</code> is interpreted as one long vector, with slice-by-slice and column-by-column ordering of the elements of <code>Q</code>. The <code>vector_of_indices</code> must evaluate to a vector of type <code>uvec</code> (e.g., generated by the <code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> function). The aggregate set of the specified elements is treated as a column vector (e.g., the output of <code>Q.elem()</code> is always a column vector).</p>
<p>In the function <code>Q.slices(vector_of_slice_indices)</code>, slices specified in <code>vector_of_slice_indices</code> are accessed. The <code>vector_of_slice_indices</code> must evaluate to a vector of type <code>uvec</code>.</p>
</div>
<div class="section level3">
<h3 id="examples-20">Examples<a class="anchor" aria-label="anchor" href="#examples-20"></a>
</h3>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">subview2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>  cube A(n, <span class="dv">3</span>, <span class="dv">4</span>, fill::randu);</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>    </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>  mat B = A.slice(<span class="dv">1</span>); <span class="co">// each slice is a matrix</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>    </span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a>  A.slice(<span class="dv">0</span>) = randu&lt;mat&gt;(<span class="dv">2</span>,<span class="dv">3</span>);</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>  A.slice(<span class="dv">0</span>)(<span class="dv">1</span>,<span class="dv">2</span>) = <span class="fl">99.0</span>;</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>    </span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a>  A.subcube(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,  <span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>)           = randu&lt;cube&gt;(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>);</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a>  A(span(<span class="dv">0</span>,<span class="dv">1</span>), span(<span class="dv">0</span>,<span class="dv">1</span>), span(<span class="dv">1</span>,<span class="dv">2</span>)) = randu&lt;cube&gt;(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>);</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a>  A(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>, size(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))              = randu&lt;cube&gt;(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>);</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a>    </span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true"></a>  <span class="co">// add 123 to all elements of A greater than 0.5</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true"></a>  A.elem( find(A &gt; <span class="fl">0.5</span>) ) += <span class="fl">123.0</span>;</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true"></a>    </span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true"></a>  cube C = A.head_slices(<span class="dv">2</span>);  <span class="co">// get first two slices</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true"></a>    </span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true"></a>  A.head_slices(<span class="dv">2</span>) += <span class="fl">123.0</span>;</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true"></a></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true"></a>  mat res = A.slice(<span class="dv">0</span>) + B + C.slice(<span class="dv">1</span>);</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="subfield-views">Subfield views<a class="anchor" aria-label="anchor" href="#subfield-views"></a>
</h2>
<p>A collection of member functions of the <code>field</code> class that provide subfield views.</p>
<p>For a 2D field <code>F</code>, the subfields are accessed as:</p>
<ul>
<li><code>F.row(row_number)</code></li>
<li><code>F.col(col_number)</code></li>
<li><code>F.rows(first_row, last_row)</code></li>
<li><code>F.cols(first_col, last_col)</code></li>
<li><code>F.subfield(first_row, first_col, last_row, last_col)</code></li>
<li><code>F(span(first_row, last_row), span(first_col, last_col))</code></li>
<li>
<code>F(first_row, first_col, size(G))</code> (<code>G</code> is a 2D field)</li>
<li><code>F(first_row, first_col, size(n_rows, n_cols))</code></li>
</ul>
<p>For a 3D field <code>F</code>, the subfields are accessed as:</p>
<ul>
<li><code>F.slice(slice_number)</code></li>
<li><code>F.slices(first_slice, last_slice)</code></li>
<li><code>F.subfield(first_row, first_col, first_slice, last_row, last_col, last_slice)</code></li>
<li><code>F(span(first_row, last_row), span(first_col, last_col), span(first_slice, last_slice))</code></li>
<li>
<code>F(first_row, first_col, first_slice, size(G))</code> (<code>G</code> is a 3D field)</li>
<li><code>F(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></li>
</ul>
<p>Instances of <code>span(a,b)</code> can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code>, to indicate the entire range.</li>
<li>
<code>span(a)</code>, to indicate a particular row or column.</li>
</ul>
</div>
<div class="section level2">
<h2 id="diagonal">Diagonal<a class="anchor" aria-label="anchor" href="#diagonal"></a>
</h2>
<p><code>.diag()</code> is a member functions of <code>Mat</code> and <code>SpMat</code> with read/write access to the diagonal in a matrix. The argument can be empty or a value <code>k</code> to specify the diagonal to (<code>k = 0</code> by default). The diagonal is interpreted as a column vector within expressions.</p>
<ul>
<li>
<code>k = 0</code> indicates the main diagonal (default setting)</li>
<li>
<code>k &lt; 0</code> indicates the <code>k</code>-th sub-diagonal (below main diagonal, towards bottom-left corner)</li>
<li>
<code>k &gt; 0</code> indicates the <code>k</code>-th super-diagonal (above main diagonal, towards top-right corner)</li>
</ul>
<div class="section level3">
<h3 id="examples-21">Examples<a class="anchor" aria-label="anchor" href="#examples-21"></a>
</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">diagonal1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>  vec A = X.diag(); <span class="co">// extract the main diagonal</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>  <span class="dt">double</span> B = accu(X.diag(<span class="dv">1</span>)); <span class="co">// sum of elements on the first upper diagonal</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>  <span class="dt">double</span> C = accu(X.diag(-<span class="dv">1</span>)); <span class="co">// sum of elements on the first lower diagonal</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>  X.diag() = randu&lt;vec&gt;(n);</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>  X.diag() += A;</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a>  X.diag() /= B;</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true"></a>  X.diag() *= C;</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true"></a></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true"></a>  sp_mat S = sprandu&lt;sp_mat&gt;(n, n, <span class="fl">0.0</span>);</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true"></a>  S.diag().ones();</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true"></a></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true"></a>  vec v(S.diag());  <span class="co">// copy sparse diagonal to dense vector</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true"></a>  v += X.diag();</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true"></a></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(v);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-2">Caveat<a class="anchor" aria-label="anchor" href="#caveat-2"></a>
</h3>
<p>To calculate only the diagonal elements of a compound expression, use <code>diagvec()</code> or <code>diagmat()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="each-col">Each col<a class="anchor" aria-label="anchor" href="#each-col"></a>
</h2>
<p><code>.each_col()</code> is a member function of <code>Mat</code>. It applies a vector operation to each column of a matrix, and are similar to “broadcasting” in Matlab/Octave. The argument can be empty, a vector of indices, or a lambda function.</p>
<table class="table">
<thead><tr class="header">
<th>Operation</th>
<th><code>.each_col()</code></th>
<th><code>.each_col(vector_of_indices)</code></th>
<th><code>.each_col(lambda)</code></th>
</tr></thead>
<tbody>
<tr class="odd">
<td>
<code>+</code> addition</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>+=</code> in-place addition</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>-</code> subtraction</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>-=</code> in-place subtraction</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>%</code> element-wise multiplication</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>%=</code> in-place element-wise multiplication</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>/</code> element-wise division</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>/=</code> in-place element-wise division</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="odd">
<td>
<code>=</code> assignment (copy)</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr class="even">
<td>
<code>lambda</code> (lambda function)</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="examples-22">Examples<a class="anchor" aria-label="anchor" href="#examples-22"></a>
</h3>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">each_col1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>  mat X(n, n + <span class="dv">1</span>, fill::ones);</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>  <span class="co">// create a vector with n elements ranging from 5 to 10</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>  vec v = linspace&lt;vec&gt;(<span class="dv">5</span>, <span class="dv">10</span>, n);</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>  <span class="co">// in-place addition of v to each column vector of X</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>  X.each_col() += v;</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a>  <span class="co">// generate Y by adding v to each column vector of X</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a>  mat Y = X.each_col() + v;</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a>  <span class="co">// subtract v from columns 1 and 2 of X</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a>  X.cols(<span class="dv">0</span>, <span class="dv">1</span>).each_col() -= v;</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a>  uvec indices(<span class="dv">2</span>);</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a>  indices(<span class="dv">0</span>) = <span class="dv">1</span>;</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a>  indices(<span class="dv">1</span>) = <span class="dv">2</span>;</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true"></a></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true"></a>  X.each_col(indices) = v;  <span class="co">// copy v to columns 1 and 2 of X</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true"></a></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true"></a>  <span class="co">// lambda function with non-const vector</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true"></a>  X.each_col([](vec&amp; a) { <span class="dv">2</span> * a; });</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true"></a>  <span class="at">const</span> mat&amp; XX = X;</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true"></a></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true"></a>  <span class="co">// lambda function with const vector</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true"></a>  XX.each_col([](<span class="at">const</span> vec&amp; b) { <span class="dv">3</span> * b; });</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true"></a></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true"></a>  mat res = X + Y + XX;</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true"></a></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="each-row">Each row<a class="anchor" aria-label="anchor" href="#each-row"></a>
</h2>
<p><code>.each_row()</code>, <code>.each_row(vector_of_indices)</code>, <code>.each_row(lambdaction)</code> are member functions of <code>Mat</code>. These apply a vector operation to each row of a matrix, and are similar to “broadcasting” in Matlab/Octave.</p>
<div class="section level3">
<h3 id="form-1">Form 1<a class="anchor" aria-label="anchor" href="#form-1"></a>
</h3>
<p><code>.each_row()</code> supports the following operations:</p>
<ul>
<li>
<code>+</code> addition</li>
<li>
<code>+=</code> in-place addition</li>
<li>
<code>-</code> subtraction</li>
<li>
<code>-=</code> in-place subtraction</li>
<li>
<code>%</code> element-wise multiplication</li>
<li>
<code>%=</code> in-place element-wise multiplication</li>
<li>
<code>/</code> element-wise division</li>
<li>
<code>/=</code> in-place element-wise division</li>
<li>
<code>=</code> assignment (copy)</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-2">Form 2<a class="anchor" aria-label="anchor" href="#form-2"></a>
</h3>
<p><code>.each_row(vector_of_indices)</code> supports the same operations as form 1. The argument <code>vector_of_indices</code> contains a list of indices of the rows to be used, and it must evaluate to a vector of type <code>uvec</code>.</p>
</div>
<div class="section level3">
<h3 id="form-3">Form 3<a class="anchor" aria-label="anchor" href="#form-3"></a>
</h3>
<p><code>.each_col(lambdaction)</code> applies the given <code>lambdaction</code> to each column vector. The function must accept a reference to a <code>Row</code> object with the same element type as the underlying matrix.</p>
</div>
<div class="section level3">
<h3 id="examples-23">Examples<a class="anchor" aria-label="anchor" href="#examples-23"></a>
</h3>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">each_row1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  mat X(n + <span class="dv">1</span>, n, fill::ones);</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>  <span class="co">// create a vector with n elements ranging from 5 to 10</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>  rowvec v = linspace&lt;rowvec&gt;(<span class="dv">5</span>, <span class="dv">10</span>, n);</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a>  <span class="co">// in-place addition of v to each rows vector of X</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true"></a>  X.each_row() += v;</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true"></a>  <span class="co">// generate Y by adding v to each rows vector of X</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true"></a>  mat Y = X.each_row() + v;</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true"></a>  <span class="co">// subtract v from rows 1 and 2 of X</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true"></a>  X.rows(<span class="dv">0</span>, <span class="dv">1</span>).each_row() -= v;</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true"></a>  uvec indices(<span class="dv">2</span>);</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true"></a>  indices(<span class="dv">0</span>) = <span class="dv">1</span>;</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true"></a>  indices(<span class="dv">1</span>) = <span class="dv">2</span>;</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true"></a></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true"></a>  X.each_row(indices) = v;       <span class="co">// copy v to columns 1 and 2 of X</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true"></a></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true"></a>  <span class="co">// lambda function with non-const vector</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true"></a>  X.each_row([](rowvec&amp; a) { a / <span class="dv">2</span>; });</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true"></a></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true"></a>  <span class="at">const</span> mat&amp; XX = X;</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true"></a></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true"></a>  <span class="co">// lambda function with const vector</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true"></a>  XX.each_row([](<span class="at">const</span> rowvec&amp; b) { b / <span class="dv">3</span>; });</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true"></a></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true"></a>  mat res = X + Y + XX;</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true"></a></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="each-slice">Each slice<a class="anchor" aria-label="anchor" href="#each-slice"></a>
</h2>
<p><code>.each_slice()</code> is a member function of <code>Cube</code> that applies a matrix operation to each slice of a cube, with each slice treated as a matrix. It is similar to “broadcasting” in Matlab/Octave.</p>
<div class="section level3">
<h3 id="form-1-1">Form 1<a class="anchor" aria-label="anchor" href="#form-1-1"></a>
</h3>
<p><code>.each_slice(vector_of_indices)</code></p>
<p>Supported operations:</p>
<ul>
<li>
<code>+</code> addition</li>
<li>
<code>+=</code> in-place addition</li>
<li>
<code>-</code> subtraction</li>
<li>
<code>-=</code> in-place subtraction</li>
<li>
<code>%</code> element-wise multiplication</li>
<li>
<code>%=</code> in-place element-wise multiplication</li>
<li>
<code>/</code> element-wise division</li>
<li>
<code>/=</code> in-place element-wise division</li>
<li>
<code>*</code> matrix multiplication</li>
<li>
<code>*=</code> in-place matrix multiplication</li>
<li>
<code>=</code> assignment (copy)</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-2-1">Form 2<a class="anchor" aria-label="anchor" href="#form-2-1"></a>
</h3>
<p><code>.each_slice(lambdaction)</code></p>
<ul>
<li>The argument <em>vector_of_indices</em> contains a list of indices of the slices to be used; it must evaluate to a vector of type <code>uvec</code>.</li>
<li>Arithmetic operations as per form 1 are supported, except for <code>*</code> and <code>*=</code> (e.g., matrix multiplication).</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-3-1">Form 3<a class="anchor" aria-label="anchor" href="#form-3-1"></a>
</h3>
<p><code>.each_slice(lambdaction, use_mp)</code></p>
<ul>
<li>Apply the given <code>lambdaction</code> to each slice.</li>
<li>The function must accept a reference to a <code>Mat</code> object with the same element type as the underlying cube.</li>
</ul>
</div>
<div class="section level3">
<h3 id="form-4">Form 4<a class="anchor" aria-label="anchor" href="#form-4"></a>
</h3>
<ul>
<li>Apply the given <code>lambdaction</code> to each slice, as per form 3.</li>
<li>The argument <code>use_mp</code> is a bool to enable the use of OpenMP for multi-threaded execution of <code>lambdaction</code> on multiple slices at the same time.</li>
<li>The order of processing the slices is not deterministic (e.g., slice 2 can be processed before slice 1).</li>
<li>
<code>lambdaction</code> must be thread-safe, e.g., it must not write to variables outside of its scope.</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-24">Examples:<a class="anchor" aria-label="anchor" href="#examples-24"></a>
</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">each_slice1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  cube C(n, n + <span class="dv">1</span>, <span class="dv">6</span>, fill::randu);</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>  mat M = repmat(linspace&lt;vec&gt;(<span class="dv">1</span>, n, n), <span class="dv">1</span>, n + <span class="dv">1</span>);</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>  C.each_slice() += M;  <span class="co">// in-place addition of M to each slice of C</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a>  cube D = C.each_slice() + M;  <span class="co">// generate D by adding M to each slice of C</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a>  <span class="co">// sum all slices of D into a single n x (n + 1) matrix</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true"></a>  mat D_flat = sum(D, <span class="dv">2</span>);</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true"></a>  uvec indices(<span class="dv">2</span>);</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true"></a>  indices(<span class="dv">0</span>) = <span class="dv">2</span>;</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true"></a>  indices(<span class="dv">1</span>) = <span class="dv">4</span>;</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true"></a>  C.each_slice(indices) = M;  <span class="co">// copy M to slices 2 and 4 in C</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true"></a>  C.each_slice([](mat&amp; X) { X * <span class="fl">2.0</span>; });  <span class="co">// lambda function with non-const matrix</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true"></a>  mat C_flat = sum(C, <span class="dv">2</span>);</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true"></a></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true"></a>  <span class="at">const</span> cube&amp; CC = C;</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true"></a>  CC.each_slice([](<span class="at">const</span> mat&amp; X) { X / <span class="fl">3.0</span>; });  <span class="co">// lambda function with const matrix</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true"></a></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true"></a>  mat CC_flat = sum(CC, <span class="dv">2</span>);</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true"></a>  mat res = C_flat + D_flat + CC_flat;</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true"></a></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="set-real">Set real<a class="anchor" aria-label="anchor" href="#set-real"></a>
</h2>
<p><code>.set_real(X)</code> sets the real part of an object. <code>X</code> must have the same size as the recipient object.</p>
<div class="section level3">
<h3 id="examples-25">Examples<a class="anchor" aria-label="anchor" href="#examples-25"></a>
</h3>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">set_real1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>  mat A(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::randu);</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a>  cx_mat C(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::zeros);</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>  C.set_real(A);</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a>  <span class="cf">return</span> as_complex_matrix(C);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-3">Caveat<a class="anchor" aria-label="anchor" href="#caveat-3"></a>
</h3>
<p>To directly construct a complex matrix out of two real matrices, the following code is faster:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">set_real2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {    </span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>  mat A(n - <span class="dv">1</span>, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>  mat B(n - <span class="dv">1</span>, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>  </span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>  cx_mat C = cx_mat(A,B);</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a>  <span class="cf">return</span> as_complex_matrix(C);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="set-imaginary">Set imaginary<a class="anchor" aria-label="anchor" href="#set-imaginary"></a>
</h2>
<p><code>.set_imaginary(X)</code> sets the imaginary part of an object. <code>X</code> must have the same size as the recipient object.</p>
<div class="section level3">
<h3 id="examples-26">Examples<a class="anchor" aria-label="anchor" href="#examples-26"></a>
</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">set_imag1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>  mat B(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::randu);</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>  cx_mat C(n + <span class="dv">1</span>, n - <span class="dv">1</span>, fill::zeros);</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>  C.set_imag(B);</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a>  <span class="cf">return</span> as_complex_matrix(C);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-4">Caveat<a class="anchor" aria-label="anchor" href="#caveat-4"></a>
</h3>
<p>To directly construct a complex matrix out of two real matrices, the following code is faster:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">set_imag2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {    </span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>  mat A(n - <span class="dv">1</span>, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>  mat B(n - <span class="dv">1</span>, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>  </span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>  cx_mat C = cx_mat(A,B);</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>  <span class="cf">return</span> as_complex_matrix(C);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="insert-columns">Insert columns<a class="anchor" aria-label="anchor" href="#insert-columns"></a>
</h2>
<p><code>.insert_cols()</code> is a member function of <code>Mat</code>, <code>Row</code> and <code>Cube</code>. The arguments can be <code>colnumber, X</code> to indicate the column number and the matrix to insert, or <code>colnumber, number_of_cols</code> to indicate the column number and the number of columns to insert.</p>
<p>The <code>X</code> argument inserts a copy of <code>X</code> at the specified column. <code>X</code> must have the same number of rows (and slices) as the recipient object.</p>
<p>The <code>number_of_cols</code> argument expands the object by creating new columns that are set to zero.</p>
<div class="section level3">
<h3 id="examples-27">Examples<a class="anchor" aria-label="anchor" href="#examples-27"></a>
</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">insert_columns1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a>  mat A(n, n * <span class="dv">2</span>, fill::randu);</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>  mat B(n, n - <span class="dv">1</span>, fill::ones);</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>  <span class="co">// at column n - 1, insert a copy of B</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>  <span class="co">// A will now have 3n - 1 columns</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>  A.insert_cols(n - <span class="dv">1</span>, B);</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true"></a>  <span class="co">// at column 1, insert 2n zeroed columns</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true"></a>  <span class="co">// B will now have 3n - 1 columns</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true"></a>  B.insert_cols(<span class="dv">1</span>, n * <span class="dv">2</span>);</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true"></a>  mat res = A + B;</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="insert-rows">Insert rows<a class="anchor" aria-label="anchor" href="#insert-rows"></a>
</h2>
<p><code>.insert_rows()</code> is a member function of <code>Mat</code>, <code>Row</code> and <code>Cube</code>. The arguments can be <code>rownumber, X</code> to indicate the row number and the matrix to insert, or <code>rownumber, number_of_rows</code> to indicate the row number and the number of rows to insert.</p>
<p>The <code>X</code> argument inserts a copy of <code>X</code> at the specified column. <code>X</code> must have the same number of columns (and slices) as the recipient object.</p>
<p>The <code>number_of_rows</code> argument expands the object by creating new rows that are set to zero.</p>
<div class="section level3">
<h3 id="examples-28">Examples<a class="anchor" aria-label="anchor" href="#examples-28"></a>
</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">insert_rows1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>  mat A(n * <span class="dv">2</span>, n, fill::randu);</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>  mat B(n - <span class="dv">1</span>, n, fill::ones);</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>  <span class="co">// at row n - 1, insert a copy of B</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a>  <span class="co">// A will now have 3n - 1 rows</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a>  A.insert_rows(n - <span class="dv">1</span>, B);</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a>  <span class="co">// at row 1, insert 2n zeroed rows</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true"></a>  <span class="co">// B will now have 3n - 1 columns</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true"></a>  B.insert_rows(<span class="dv">1</span>, n * <span class="dv">2</span>);</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true"></a>  mat res = A + B;</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="insert-slice">Insert slice<a class="anchor" aria-label="anchor" href="#insert-slice"></a>
</h2>
<p><code>.insert_slices()</code> is a member function of <code>Cube</code>. The arguments can be <code>slice_number, X</code> to indicate the slice number and the matrix to insert, or <code>slice_number, number_of_slices</code> to indicate the slice number and the number of slices to insert.</p>
<p>The <code>X</code> argument inserts a copy of <code>X</code> at the specified slice. <code>X</code> must have the same number of columns and rows as the recipient object.</p>
<p>The <code>number_of_slices</code> argument expands the object by creating new slices that are set to zero.</p>
<div class="section level3">
<h3 id="examples-29">Examples<a class="anchor" aria-label="anchor" href="#examples-29"></a>
</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">insert_slices1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>  cube A(n, n, n * <span class="dv">2</span>, fill::randu);</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>  cube B(n, n, n - <span class="dv">1</span>, fill::ones);</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>  <span class="co">// At slice n - 1, insert a copy of B</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a>  <span class="co">// A will now have 3n - 1 slices</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a>  A.insert_slices(n - <span class="dv">1</span>, B);</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true"></a>  <span class="co">// At slice 1, insert 2n zeroed slices</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true"></a>  <span class="co">// B will now have 3n - 1 slices</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true"></a>  B.insert_slices(<span class="dv">1</span>, n * <span class="dv">2</span>);</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true"></a>  mat res = sum(A + B);</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true"></a></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shed-columns">Shed columns<a class="anchor" aria-label="anchor" href="#shed-columns"></a>
</h2>
<p><code>.shed_col(row_number)</code> and <code>.shed_cols(first_row, last_row)</code> are member functions of <code>Mat</code>, <code>Col</code>, <code>SpMat</code>, and <code>Cube</code>. With a single scalar argument it remove the specified column, and with two scalar arguments it removes the specified range of columns.</p>
<p><code>.shed_cols(vector_of_indices)</code> is a member function of <code>Mat</code> and <code>Col</code>. With a vector of indices it must evaluate to a vector of type <code>uvec</code> containing the indices of the columns to remove.</p>
<div class="section level3">
<h3 id="examples-30">Examples<a class="anchor" aria-label="anchor" href="#examples-30"></a>
</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">shed_columns1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>  mat A(n, n * <span class="dv">5</span>, fill::randu);</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>  <span class="co">// remove the first column</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>  A.shed_col(<span class="dv">0</span>);</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true"></a>  <span class="co">// remove columns 1 and 2</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true"></a>  A.shed_cols(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true"></a>  <span class="co">// remove columns 2 and 4</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true"></a>  uvec indices(<span class="dv">2</span>);</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true"></a>  indices(<span class="dv">0</span>) = <span class="dv">1</span>;</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true"></a>  indices(<span class="dv">1</span>) = <span class="dv">3</span>;</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true"></a>  A.shed_cols(indices);</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shed-rows">Shed rows<a class="anchor" aria-label="anchor" href="#shed-rows"></a>
</h2>
<p><code>.shed_row(row_number)</code> and <code>.shed_rows(first_row, last_row)</code> are member functions of <code>Mat</code>, <code>Col</code>, <code>SpMat</code>, and <code>Cube</code>. With a single scalar argument it remove the specified rows, and with two scalar arguments it removes the specified range of rows.</p>
<p><code>.shed_rows(vector_of_indices)</code> is a member function of <code>Mat</code> and <code>Row</code>. With a vector of indices it must evaluate to a vector of type <code>uvec</code> containing the indices of the rows to remove.</p>
<div class="section level3">
<h3 id="examples-31">Examples<a class="anchor" aria-label="anchor" href="#examples-31"></a>
</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">shed_rows1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>  mat A(n * <span class="dv">5</span>, n, fill::randu);</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>  <span class="co">// remove the first row</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>  A.shed_row(<span class="dv">0</span>);</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a>  <span class="co">// remove rows 1 and 2</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a>  A.shed_rows(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true"></a></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true"></a>  <span class="co">// remove rows 2 and 4</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true"></a>  uvec indices(<span class="dv">2</span>);</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true"></a>  indices(<span class="dv">0</span>) = <span class="dv">1</span>;</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true"></a>  indices(<span class="dv">1</span>) = <span class="dv">3</span>;</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true"></a>  A.shed_rows(indices);</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true"></a></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="shed-slices">Shed slices<a class="anchor" aria-label="anchor" href="#shed-slices"></a>
</h2>
<p><code>.shed_slices()</code> is a member function of <code>Cube</code>. With a single scalar argument it remove the specified slices, and with two scalar arguments it removes the specified range of slices. With a vector of indices it must evaluate to a vector of type <code>uvec</code> containing the indices of the rows to remove. The arguments can be <code>slice_number</code> to indicate the slice number to remove, <code>first_slice, last_slice</code> to indicate the range of slices to remove, or <code>vector_of_indices</code> to indicate the indices of the slices to remove.</p>
<div class="section level3">
<h3 id="examples-32">Examples<a class="anchor" aria-label="anchor" href="#examples-32"></a>
</h3>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">shed_slices1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>  cube A(n, n, n * <span class="dv">5</span>, fill::randu);</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>  <span class="co">// remove the first slice</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>  A.shed_slice(<span class="dv">0</span>);</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true"></a>  <span class="co">// remove slices 1 and 2</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true"></a>  A.shed_slices(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true"></a>  <span class="co">// remove slices 2 and 4</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true"></a>  uvec indices(<span class="dv">2</span>);</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true"></a>  indices(<span class="dv">0</span>) = <span class="dv">1</span>;</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true"></a>  indices(<span class="dv">1</span>) = <span class="dv">3</span>;</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true"></a>  A.shed_slices(indices);</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true"></a></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true"></a>  mat res = sum(A, <span class="dv">2</span>);</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true"></a></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="swap-columns">Swap columns<a class="anchor" aria-label="anchor" href="#swap-columns"></a>
</h2>
<p><code>.swap_cols( col1, col2 )</code> is a member functions of <code>Mat</code>, <code>Col</code>, <code>Row</code>, and <code>SpMat</code>. It swaps the contents of the specified columns.</p>
<div class="section level3">
<h3 id="examples-33">Examples<a class="anchor" aria-label="anchor" href="#examples-33"></a>
</h3>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">swap_columns1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>  mat A(n, n * <span class="dv">5</span>, fill::randu);</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a>  <span class="co">// swap columns 1 and 2</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a>  A.swap_cols(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true"></a>  <span class="co">// swap columns 2 and 4</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true"></a>  A.swap_cols(<span class="dv">1</span>, <span class="dv">3</span>);</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true"></a></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="swap-rows">Swap rows<a class="anchor" aria-label="anchor" href="#swap-rows"></a>
</h2>
<p><code>.swap_rows( col1, col2 )</code> is a member functions of <code>Mat</code>, <code>Col</code>, <code>Row</code>, and <code>SpMat</code>. It swaps the contents of the specified rows.</p>
<div class="section level3">
<h3 id="examples-34">Examples<a class="anchor" aria-label="anchor" href="#examples-34"></a>
</h3>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">swap_rows1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>  mat A(n * <span class="dv">5</span>, n, fill::randu);</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a>  <span class="co">// swap rows 1 and 2</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a>  A.swap_rows(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true"></a>  <span class="co">// swap rows 2 and 4</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true"></a>  A.swap_rows(<span class="dv">1</span>, <span class="dv">3</span>);</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true"></a></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="swap">Swap<a class="anchor" aria-label="anchor" href="#swap"></a>
</h2>
<p><code>.swap( X )</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, and <code>Cube</code>. It swaps the contents with object <code>X</code>.</p>
<div class="section level3">
<h3 id="examples-35">Examples<a class="anchor" aria-label="anchor" href="#examples-35"></a>
</h3>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">swap1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::zeros);</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>  mat B(n * <span class="dv">2</span>, n - <span class="dv">1</span>, fill::ones);</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a>  A.swap(B);</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="memory-pointer">Memory pointer<a class="anchor" aria-label="anchor" href="#memory-pointer"></a>
</h2>
<p><code>.memptr()</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, and <code>Cube</code>. It obtains a raw pointer to the memory used for storing elements. Data for matrices is stored in a column-by-column order. Data for cubes is stored in a slice-by-slice (matrix-by-matrix) order.</p>
<div class="section level3">
<h3 id="examples-36">Examples<a class="anchor" aria-label="anchor" href="#examples-36"></a>
</h3>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">memptr1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>  <span class="at">const</span> mat B(n, n, fill::randu);</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>  <span class="dt">double</span>* A_mem = A.memptr();</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>  <span class="at">const</span> <span class="dt">double</span>* B_mem = B.memptr();</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>  <span class="co">// alter A_mem</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>  <span class="co">// B_mem is const, so it cannot be altered</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n * n; ++i) {</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a>    A_mem[i] += <span class="fl">123.0</span> + B_mem[i];</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a>  }</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true"></a></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-4">Caveats<a class="anchor" aria-label="anchor" href="#caveats-4"></a>
</h3>
<ul>
<li>The pointer becomes invalid after any operation involving a size change or aliasing.</li>
<li>This function is not recommended for use unless you know what you are doing.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="column-pointer">Column pointer<a class="anchor" aria-label="anchor" href="#column-pointer"></a>
</h2>
<p><code>.colptr( col_number )</code> is a member function of the <code>Mat</code> class that obtains a raw pointer to the memory used by elements in the specified column.</p>
<div class="section level3">
<h3 id="examples-37">Examples<a class="anchor" aria-label="anchor" href="#examples-37"></a>
</h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">colptr1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>  <span class="co">// pointer to the memory of the first column of A</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>  <span class="dt">double</span>* Acol1_mem = A.colptr(<span class="dv">0</span>);</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a>  <span class="co">// alter memory</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a>    Acol1_mem[i] += <span class="fl">123.0</span>;</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true"></a>  }</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true"></a></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(A);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-5">Caveats<a class="anchor" aria-label="anchor" href="#caveats-5"></a>
</h3>
<ul>
<li>The pointer becomes invalid after any operation involving a size change or aliasing.</li>
<li>This function is not recommended for use unless you know what you are doing.</li>
<li>It is safer to use <code>submat()</code> instead.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="iterators">Iterators<a class="anchor" aria-label="anchor" href="#iterators"></a>
</h2>
<p>Iterators for traverse over all elements within the specified range. These return the column/row/slice of an object as a <code>uword</code> type.</p>
<div class="section level3">
<h3 id="member-functions">Member functions<a class="anchor" aria-label="anchor" href="#member-functions"></a>
</h3>
<p>Dense matrices and vectors (<code>Mat</code>, <code>Col</code>, and <code>Row</code>):</p>
<ul>
<li>
<code>.begin()</code> is an iterator referring to the first element.</li>
<li>
<code>.end()</code> is an iterator referring to the past the end element.</li>
<li>
<code>.begin_col(col_number)</code> is an iterator referring to the first element of the specified column.</li>
<li>
<code>.end_col(col_number)</code> is an iterator referring to the past-the-end element of the specified column.</li>
<li>
<code>begin_row(row_number)</code> is an iterator referring to the first element of the specified row.</li>
<li>
<code>end_row(row_number)</code> is an iterator referring to the past-the-end element of the specified row.</li>
</ul>
<p>Cubes (<code>Cube</code>):</p>
<ul>
<li>
<code>begin()</code> is an iterator referring to the first element.</li>
<li>
<code><a href="https://rdrr.io/r/stats/start.html" class="external-link">end()</a></code> is an iterator referring to the past-the-end element.</li>
<li>
<code>begin_slice(slice_number)</code> iterator referring to the first element of the specified slice.</li>
<li>
<code>end_slice(slice_number)</code> iterator referring to the past-the-end element of the specified slice.</li>
</ul>
<p>Sparse matrices (<code>SpMat</code>):</p>
<ul>
<li>
<code>begin()</code> is an iterator referring to the first element.</li>
<li>
<code><a href="https://rdrr.io/r/stats/start.html" class="external-link">end()</a></code> is an iterator referring to the past-the-end element.</li>
<li>
<code>begin_col(col_number)</code> is an iterator referring to the first element of the specified column.</li>
<li>
<code>end_col(col_number)</code> is an iterator referring to the past-the-end element of the specified column.</li>
<li>
<code>begin_row(row_number)</code> is an iterator referring to the first element of the specified row.</li>
<li>
<code>end_row(row_number)</code> is an iterator referring to the past-the-end element of the specified row.</li>
</ul>
<p>Dense submatrices and subcubes (<code>submatrix</code> and <code>subcube</code>):</p>
<ul>
<li>
<code>span(row, col)</code> and <code>span(row, col, slice)</code> can be used to specify the range of elements to iterate over.</li>
</ul>
</div>
<div class="section level3">
<h3 id="iterator-types">Iterator types<a class="anchor" aria-label="anchor" href="#iterator-types"></a>
</h3>
<p>Dense matrices and vectors (<code>Mat</code>, <code>Col</code>, and <code>Row</code>):</p>
<ul>
<li>
<code>mat::iterator</code>, <code>vec::iterator</code> and <code>rowvec::iterator</code> are random access iterators, for read/write access to elements (which are stored column by column).</li>
<li>
<code>mat::const_iterator</code>, <code>vec::const_iterator</code> and <code>rowvec::const_iterator</code> are random access iterators, for read-only access to elements (which are stored column by column)</li>
<li>
<code>mat::col_iterator</code>, <code>vec::col_iterator</code> and <code>rowvec::col_iterator</code> random access iterators, for read/write access to the elements of specified columns.</li>
<li>
<code>mat::const_col_iterator</code>, <code>vec::const_col_iterator</code> and <code>rowvec::const_col_iterator</code> are random access iterators, for read-only access to the elements of specified columns.</li>
<li>
<code>mat::row_iterator</code> is a bidirectional iterator, for read/write access to the elements of specified rows.</li>
<li>
<code>mat::const_row_iterator</code> is a bidirectional iterator, for read-only access to the elements of specified rows.</li>
<li>
<code>vec::row_iterator</code> and <code>rowvec::row_iterator</code> are random access iterators, for read/write access to the elements of specified rows.</li>
<li>
<code>vec::const_row_iterator</code> and <code>rowvec::const_row_iterator</code> are random access iterators, for read-only access to the elements of specified rows.</li>
</ul>
<p>Cubes (<code>Cube</code>):</p>
<ul>
<li>
<code>cube::iterator</code> is a random access iterator, for read/write access to elements. The elements are ordered slice by slice; the elements within each slice are ordered column by column.</li>
<li>
<code>cube::const_iterator</code> is a random access iterator, for read-only access to elements.</li>
<li>
<code>cube::slice_iterator</code> is a random access iterator, for read/write access to the elements of a particular slice. The elements are ordered column by column.</li>
<li>
<code>cube::const_slice_iterator</code> is a random access iterator, for read-only access to the elements of a particular slice.</li>
</ul>
<p>Sparse matrices (<code>SpMat</code>):</p>
<ul>
<li>
<code>sp_mat::iterator</code> is a bidirectional iterator, for read/write access to elements (which are stored column by column).</li>
<li>
<code>sp_mat::const_iterator</code> is a bidirectional iterator, for read-only access to elements (which are stored column by column).</li>
<li>
<code>sp_mat::col_iterator</code> is a bidirectional iterator, for read/write access to the elements of a specific column.</li>
<li>
<code>sp_mat::const_col_iterator</code> is a bidirectional iterator, for read-only access to the elements of a specific column.</li>
<li>
<code>sp_mat::row_iterator</code> is a bidirectional iterator, for read/write access to the elements of a specific row.</li>
<li>
<code>sp_mat::const_row_iterator</code> is a bidirectional iterator, for read-only access to the elements of a specific row.</li>
</ul>
</div>
<div class="section level3">
<h3 id="examples-38">Examples<a class="anchor" aria-label="anchor" href="#examples-38"></a>
</h3>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">iterators1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>  mat X(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>  mat::iterator it = X.begin();</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>  mat::iterator it_end = X.end();</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a>  <span class="cf">for</span> (; it != it_end; ++it) {</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>    (*it) += <span class="fl">123.0</span>;</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>  }</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true"></a>  mat::col_iterator col_it = X.begin_col(<span class="dv">1</span>);    <span class="co">// start of column 1</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true"></a>  mat::col_iterator col_it_end = X.end_col(n);  <span class="co">//   end of column n</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true"></a></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true"></a>  <span class="cf">for</span> (; col_it != col_it_end; ++col_it) {</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true"></a>    (*col_it) = <span class="fl">321.0</span>;</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true"></a>  }</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true"></a></span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">iterators2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>  cube X(n, n + <span class="dv">1</span>, n + <span class="dv">2</span>, fill::randu);</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a>  cube::iterator it = X.begin();</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>  cube::iterator it_end = X.end();</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true"></a>  <span class="cf">for</span> (; it != it_end; ++it) {</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true"></a>    (*it) += <span class="fl">123.0</span>;</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true"></a>  }</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true"></a>  cube::slice_iterator <span class="va">s_it</span> = X.begin_slice(<span class="dv">1</span>);    <span class="co">// start of slice 1</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true"></a>  cube::slice_iterator <span class="va">s_it_end</span> = X.end_slice(n);  <span class="co">// end of slice n</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true"></a></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true"></a>  <span class="cf">for</span> (; <span class="va">s_it</span> != <span class="va">s_it_end</span>; ++<span class="va">s_it</span>) {</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true"></a>    (*<span class="va">s_it</span>) = <span class="fl">321.0</span>;</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true"></a>  }</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true"></a></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true"></a>  mat res = sum(X, <span class="dv">2</span>);</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true"></a></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(res);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">iterators3_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>  sp_mat X = sprandu&lt;sp_mat&gt;(n, n * <span class="dv">2</span>, <span class="fl">0.1</span>);</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>  sp_mat::iterator it = X.begin();</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a>  sp_mat::iterator it_end = X.end();</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true"></a>  <span class="cf">for</span> (; it != it_end; ++it) {</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true"></a>    (*it) += <span class="fl">123.0</span>;</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true"></a>  }</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true"></a></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">iterators4_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">double</span>&amp; val : X(span(<span class="dv">0</span>, <span class="dv">1</span>), span(<span class="dv">1</span>, <span class="dv">1</span>))) {</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true"></a>    val = <span class="fl">123.0</span>;</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true"></a>  }</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true"></a></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(X);  <span class="co">// Convert from C++ to R</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-6">Caveats<a class="anchor" aria-label="anchor" href="#caveats-6"></a>
</h3>
<ul>
<li>Writing a zero value into a sparse matrix through an iterator will invalidate all current iterators associated with the sparse matrix.</li>
<li>To modify the non-zero elements in a safer manner, use <code>.transform()</code> or <code>.for_each()</code> instead of iterators.</li>
<li>For <code>submatrix</code> and <code>subcube</code> the iterators are intended only to be used with range-based for loops. Any other use is not supported. For example, the direct use of the <code>.begin()</code> and <code>.end()</code> functions, as well as the underlying iterators types is not supported. The implementation of submatrices and subcubes uses short-lived temporary objects that are subject to automatic deletion, and as such are error-prone to handle manually.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="compatibility-container-functions">Compatibility container functions<a class="anchor" aria-label="anchor" href="#compatibility-container-functions"></a>
</h2>
<p>Member functions for the <code>Col</code> and <code>Row</code> classes to mimic the functionality of containers in the C++ standard library:</p>
<ul>
<li>
<code>.front()</code> accesses the first element in a vector.</li>
<li>
<code>.back()</code> accesses the last element in a vector.</li>
</ul>
<p>Member functions for the <code>Col</code>, <code>Row</code>, <code>Mat</code>, <code>Cube</code> and <code>SpMat</code> classes to mimic the functionality of containers in the C++ standard library:</p>
<ul>
<li>
<code>.clear()</code> removes the elements from an object.</li>
<li>
<code>.empty()</code> returns <code>true</code> if the object has no elements and <code>false</code> if the object has one or more elements.<br>
</li>
<li>
<code>.size()</code> returns the total number of elements in an object.</li>
</ul>
<div class="section level3">
<h3 id="examples-39">Examples<a class="anchor" aria-label="anchor" href="#examples-39"></a>
</h3>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">compatibility1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a>  vec X(n, fill::randu);</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a>  writable::doubles res = {X.front(), X.back()};</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"front"</span>, <span class="st">"back"</span>});</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true"></a></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] integers <span class="va">compatibility2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>  mat X(n, n, fill::randu);</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>  writable::integers res(<span class="dv">2</span>);</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>  res[<span class="dv">0</span>] = X.n_rows;</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a>  X.clear();</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = X.n_rows;</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"before"</span>, <span class="st">"after"</span>});</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true"></a></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-matrix-to-column">Convert matrix to column<a class="anchor" aria-label="anchor" href="#convert-matrix-to-column"></a>
</h2>
<p><code>.as_col()</code> is a member function of the <code>Mat</code> class, it returns a flattened version of the matrix as a column vector. Flattening is done by concatenating all columns.</p>
<div class="section level3">
<h3 id="examples-40">Examples<a class="anchor" aria-label="anchor" href="#examples-40"></a>
</h3>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">as_col1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>  mat M(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a>  vec V = M.as_col();</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(V);</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-matrix-to-row">Convert matrix to row<a class="anchor" aria-label="anchor" href="#convert-matrix-to-row"></a>
</h2>
<p><code>.as_row()</code> is a member function of the <code>Mat</code> class, it returns a flattened version of the matrix as a row vector. Flattening is done by concatenating all rows.</p>
<div class="section level3">
<h3 id="examples-41">Examples<a class="anchor" aria-label="anchor" href="#examples-41"></a>
</h3>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">as_row1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a>  mat M(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true"></a>  vec V = M.as_row();</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(V);</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-5">Caveat<a class="anchor" aria-label="anchor" href="#caveat-5"></a>
</h3>
<p>Converting columns to rows is faster than converting rows to columns.</p>
</div>
</div>
<div class="section level2">
<h2 id="convert-column-to-matrix">Convert column to matrix<a class="anchor" aria-label="anchor" href="#convert-column-to-matrix"></a>
</h2>
<p><code>.col_as_mat(col_number)</code> is a member function of the <code>Cube</code> class, it returns a matrix of the specified cube column and the number of rows is preserved. Given a cube of size <code>R x C x S</code>, the resultant matrix size is <code>R x S</code>.</p>
<div class="section level3">
<h3 id="examples-42">Examples<a class="anchor" aria-label="anchor" href="#examples-42"></a>
</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">col_as_mat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a>  cube C(n, n + <span class="dv">1</span>, n + <span class="dv">2</span>, fill::randu);</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>  mat M = C.col_as_mat(<span class="dv">0</span>);  <span class="co">// size n x (n + 1)</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a>  </span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a>  writable::list res(<span class="dv">5</span>);</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(C.slice(<span class="dv">0</span>));</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(C.slice(<span class="dv">1</span>));</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C.slice(<span class="dv">2</span>));</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a>  res[<span class="dv">3</span>] = as_doubles_matrix(C.slice(<span class="dv">3</span>));</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a>  res[<span class="dv">4</span>] = as_doubles_matrix(M);</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"slice0"</span>, <span class="st">"slice1"</span>, <span class="st">"slice2"</span>, <span class="st">"slice3"</span>,</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true"></a>    <span class="st">"col_as_mat"</span>});</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true"></a></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-column-to-matrix-1">Convert column to matrix<a class="anchor" aria-label="anchor" href="#convert-column-to-matrix-1"></a>
</h2>
<p><code>.row_as_mat(row_number)</code> is a member function of the <code>Cube</code> class, it returns a matrix of the specified cube row and the number of columns is preserved. Given a cube of size <code>R x C x S</code>, the resultant matrix size is <code>S x C</code>.</p>
<div class="section level3">
<h3 id="examples-43">Examples<a class="anchor" aria-label="anchor" href="#examples-43"></a>
</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] list <span class="va">row_as_mat1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a>  cube C(n, n + <span class="dv">1</span>, n + <span class="dv">2</span>, fill::randu);</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a>  mat M = C.row_as_mat(<span class="dv">0</span>);  <span class="co">// size (n + 2) x (n + 1)</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>  writable::list res(<span class="dv">5</span>);</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = as_doubles_matrix(C.slice(<span class="dv">0</span>));</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = as_doubles_matrix(C.slice(<span class="dv">1</span>));</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true"></a>  res[<span class="dv">2</span>] = as_doubles_matrix(C.slice(<span class="dv">2</span>));</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true"></a>  res[<span class="dv">3</span>] = as_doubles_matrix(C.slice(<span class="dv">3</span>));</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true"></a>  res[<span class="dv">4</span>] = as_doubles_matrix(M);</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true"></a></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"slice0"</span>, <span class="st">"slice1"</span>, <span class="st">"slice2"</span>, <span class="st">"slice3"</span>,</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true"></a>    <span class="st">"row_as_mat"</span>});</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true"></a></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="convert-sparse-matrix-to-dense-matrix">Convert sparse matrix to dense matrix<a class="anchor" aria-label="anchor" href="#convert-sparse-matrix-to-dense-matrix"></a>
</h2>
<p><code>.as_dense()</code> is a member function of the <code>SpMat</code> class, it avoids the construction of an intermediate sparse matrix representation of the expression.</p>
<div class="section level3">
<h3 id="examples-44">Examples<a class="anchor" aria-label="anchor" href="#examples-44"></a>
</h3>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">as_dense1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a>  sp_mat A;</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a>  A.sprandu(n, n, <span class="fl">0.1</span>);</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a>  <span class="co">// extract column 1 of A directly into dense column vector</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true"></a>  colvec c = A.col(<span class="dv">0</span>).as_dense();</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true"></a></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true"></a>  <span class="co">// store the sum of each column of A directly in dense row vector</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true"></a>  rowvec r = sum(A).as_dense();</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true"></a></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(c + r.t());</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="dense-matrix-and-vector-transposition">Dense matrix and vector transposition<a class="anchor" aria-label="anchor" href="#dense-matrix-and-vector-transposition"></a>
</h2>
<p><code>.t()</code> is a member function of the <code>Mat</code>, <code>Col</code> and <code>Row</code> classes, it returns a transposed copy of the object. For real matrices, the transpose is a simple transposition of the elements. For complex matrices, the transpose is a Hermitian conjugate transposition of the elements (e.g., the signs of the imaginary components are flipped).</p>
<div class="section level3">
<h3 id="examples-45">Examples<a class="anchor" aria-label="anchor" href="#examples-45"></a>
</h3>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">transpose1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true"></a>  mat B = A.t();</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="sparse-matrix-transposition">Sparse matrix transposition<a class="anchor" aria-label="anchor" href="#sparse-matrix-transposition"></a>
</h2>
<p><code>.st()</code> is a member function of the <code>SpMat</code> classe, it returns a transposed copy of the object. For real matrices, it is not applicable. For complex matrices, the transpose is a simple transposition of the elements (e.g., the signs of imaginary components are not flipped).</p>
<div class="section level3">
<h3 id="examples-46">Examples<a class="anchor" aria-label="anchor" href="#examples-46"></a>
</h3>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles_matrix&lt;&gt; <span class="va">transpose2_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true"></a>  sp_mat A;</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true"></a>  A.sprandu(n, n + <span class="dv">1</span>, <span class="fl">0.1</span>);</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true"></a>  sp_mat B = A.t();</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles_matrix(B);</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="matrix-inversion">Matrix inversion<a class="anchor" aria-label="anchor" href="#matrix-inversion"></a>
</h2>
<p><code>.i()</code> is a member function of the <code>Mat</code> class, it provides an inverse of the matrix. If the matrix is not square sized, a <code>std::logic_error</code> exception is thrown. If the matrix appears to be singular, the output matrix is reset and a <code>std::runtime_error</code> exception is thrown.</p>
<div class="section level3">
<h3 id="examples-47">Examples<a class="anchor" aria-label="anchor" href="#examples-47"></a>
</h3>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">inverse1_</span>(<span class="at">const</span> doubles_matrix&lt;&gt;&amp; a,</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a>                                      <span class="at">const</span> doubles b) {</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true"></a>  mat A = as_Mat(a);</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true"></a>  vec B = as_Col(b);</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true"></a>  mat X = inv(A);</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true"></a>  vec Y = X * B;</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true"></a>  <span class="cf">return</span> as_doubles(Y);</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-7">Caveats<a class="anchor" aria-label="anchor" href="#caveats-7"></a>
</h3>
<ul>
<li>If the matrix is known to be symmetric positive definite, <code>inv_sympd()</code>.</li>
<li>To solve a system of linear equations, such as <code>Z = inv(X) * Y</code>, <code><a href="https://rdrr.io/r/base/solve.html" class="external-link">solve()</a></code> can be faster and/or more accurate.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="maximum-and-minimum">Maximum and minimum<a class="anchor" aria-label="anchor" href="#maximum-and-minimum"></a>
</h2>
<p><code>.min()</code> and <code>.max()</code> are member functions of the <code>Mat</code>, <code>Col</code>, <code>Row</code>, and <code>Cube</code> classes. These return the minimum and maximum values of the object, respectively. For objects with complex numbers, absolute values are used for comparison.</p>
<div class="section level3">
<h3 id="examples-48">Examples<a class="anchor" aria-label="anchor" href="#examples-48"></a>
</h3>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">maxmin1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true"></a>  mat A = randu&lt;mat&gt;(n, n);</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true"></a>  writable::doubles res(<span class="dv">2</span>);</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.max();</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true"></a>  res[<span class="dv">1</span>] = A.min();</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"max"</span>, <span class="st">"min"</span>});</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="linear-index-of-maximum-and-minimum">Linear index of maximum and minimum<a class="anchor" aria-label="anchor" href="#linear-index-of-maximum-and-minimum"></a>
</h2>
<p><code>.index_min()</code> and <code>.index_max()</code> are member functions of the <code>Mat</code>, <code>Col</code>, <code>Row</code>, and <code>Cube</code> classes. They return the linear index of the minimum and maximum values of the object, respectively. For objects with complex numbers, absolute values are used for comparison. The returned index is of type <code>uword</code>.</p>
<div class="section level3">
<h3 id="examples-49">Examples<a class="anchor" aria-label="anchor" href="#examples-49"></a>
</h3>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] doubles <span class="va">index_maxmin1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a>  mat A = randu&lt;mat&gt;(n, n);</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true"></a>  writable::doubles res(<span class="dv">6</span>);</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true"></a>  res[<span class="dv">0</span>] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(A.index_max());</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true"></a>  res[<span class="dv">1</span>] = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(A.index_min());</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A(<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true"></a>  res[<span class="dv">3</span>] = A(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true"></a>  res[<span class="dv">4</span>] = A(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true"></a>  res[<span class="dv">5</span>] = A(<span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true"></a></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"index_max"</span>, <span class="st">"index_min"</span>, <span class="st">"element0"</span>, <span class="st">"element1"</span>,</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true"></a>    <span class="st">"element2"</span>, <span class="st">"element3"</span>});</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true"></a></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="in-range">In-range<a class="anchor" aria-label="anchor" href="#in-range"></a>
</h2>
<p><code>.in_range(** i **)</code> is a member function of <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code> and <code>field</code>, it returns <code>true</code> if the given location or span is currently valid and <code>false</code> if the object is empty, the location is out of bounds, or the span is out of bounds.</p>
<table class="table">
<colgroup>
<col width="73%">
<col width="3%">
<col width="3%">
<col width="3%">
<col width="4%">
<col width="5%">
<col width="5%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Mat</th>
<th>Col</th>
<th>Row</th>
<th>Cube</th>
<th>SpMat</th>
<th>Field</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>.in_range(span(start, end))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.in_range(row, col)</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(span(start_row, end_row), span(start_col, end_col))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td><code>.in_range(row, col, slice)</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(span(start_row, end_row), span(start_col, end_col), span(start_slice, end_slice))</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr class="even">
<td>
<code>.in_range(first_row, first_col, size(X))</code> (<code>X</code> is a matrix or field)</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(first_row, first_col, size(n_rows, n_cols))</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="even">
<td>
<code>.in_range(first_row, first_col, first_slice, size(Q))</code> (<code>Q</code> is a cube or field)</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr class="odd">
<td><code>.in_range(first_row, first_col, first_slice, size(n_rows, n_cols, n_slices))</code></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>Instances of <code>span(a,b)</code> can be replaced by:</p>
<ul>
<li>
<code>span()</code> or <code>span::all</code> to indicate the entire range.</li>
<li>
<code>span(a)</code> to indicate a particular row, column, or slice.</li>
</ul>
<div class="section level3">
<h3 id="examples-50">Examples<a class="anchor" aria-label="anchor" href="#examples-50"></a>
</h3>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">in_range1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.in_range(<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true"></a>  res[<span class="dv">1</span>] = A.in_range(<span class="dv">3</span>, <span class="dv">4</span>);</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A.in_range(<span class="dv">4</span>, <span class="dv">5</span>);</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true"></a></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"in_range00"</span>, <span class="st">"in_range34"</span>, <span class="st">"in_range45"</span>});</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-empty">Is empty<a class="anchor" aria-label="anchor" href="#is-empty"></a>
</h2>
<p><code>.is_empty()</code> is a member function of the <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, <code>SpMat</code>, and <code>field</code> classes. It returns <code>true</code> if the object has no elements and <code>false</code> if the object has one or more elements.</p>
<div class="section level3">
<h3 id="examples-51">Examples<a class="anchor" aria-label="anchor" href="#examples-51"></a>
</h3>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_empty1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a>  mat A(n, n + <span class="dv">1</span>, fill::randu);</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a>  writable::logicals res(<span class="dv">2</span>);</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_empty();</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a>  A.reset();</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = A.is_empty();</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"before_reset"</span>, <span class="st">"after_reset"</span>});</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-vectorcolumn-vectorrow-vector">Is vector/column vector/row vector<a class="anchor" aria-label="anchor" href="#is-vectorcolumn-vectorrow-vector"></a>
</h2>
<p><code>.is_vec()</code>, <code>.is_colvec()</code> and <code>.is_rowvec()</code> are member functions of <code>Mat</code> and <code>SpMat</code>.</p>
<ul>
<li>
<code>.is_vec()</code> returns <code>true</code> if the matrix can be interpreted as a vector (either column or row vector) and <code>false</code> otherwise.</li>
<li>
<code>.is_colvec()</code> returns <code>true</code> if the matrix can be interpreted as a column vector and <code>false</code> otherwise.<br>
</li>
<li>
<code>.is_rowvec()</code> returns <code>true</code> if the matrix can be interpreted as a row vector and <code>false</code> otherwise.</li>
</ul>
<div class="section level3">
<h3 id="examples-52">Examples<a class="anchor" aria-label="anchor" href="#examples-52"></a>
</h3>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_vec1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true"></a>  mat A(n, <span class="dv">1</span>, fill::randu);</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true"></a>  mat B(<span class="dv">1</span>, n, fill::randu);</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true"></a>  mat C(<span class="dv">0</span>, <span class="dv">1</span>, fill::randu);</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true"></a>  mat D(<span class="dv">1</span>, <span class="dv">0</span>, fill::randu);</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true"></a></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true"></a>  writable::logicals res(<span class="dv">5</span>);</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_vec();</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true"></a>  res[<span class="dv">1</span>] = A.is_colvec();</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = B.is_rowvec();</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true"></a>  res[<span class="dv">3</span>] = C.is_colvec();</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true"></a>  res[<span class="dv">4</span>] = D.is_rowvec();</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true"></a></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"Nx1_is_vec"</span>, <span class="st">"Nx1_is_colvec"</span>, <span class="st">"1xN_is_rowvec"</span>,</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true"></a>    <span class="st">"0x1_is_colvec"</span>, <span class="st">"1x0_is_rowvec"</span>});</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true"></a></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-6">Caveat<a class="anchor" aria-label="anchor" href="#caveat-6"></a>
</h3>
<p>Do not assume that the vector has elements if these functions return <code>true</code>. It is possible to have an empty vector (e.g., 0x1 as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-sorted">Is sorted<a class="anchor" aria-label="anchor" href="#is-sorted"></a>
</h2>
<p><code>.is_sorted()</code>, <code>.is_sorted(sort_direction)</code> and <code>.is_sorted(sort_direction, dim)</code> are member function of <code>Mat</code>, <code>Row</code>, and <code>Col</code>. For matrices and vectors with complex numbers, order is checked via absolute values.</p>
<p>If the object is a vector, these return a <code>bool</code> indicating whether the elements are sorted. If the object is a matrix, these return a <code>bool</code> indicating whether the elements are sorted in each column (<code>dim = 0</code>, default) or each row (<code>dim = 1</code>), and the <code>dim</code> argument is optional.</p>
<p>The <code>sort_direction</code> argument is optional, <code>sort_direction</code> can be one of the following strings:</p>
<ul>
<li>
<code>"ascend"</code>: the elements are ascending, consecutive elements can be equal, and this is the default operation.</li>
<li>
<code>"descend"</code>: the elements are descending, and consecutive elements can be equal.</li>
<li>
<code>"strictascend"</code>: the elements are strictly ascending, and consecutive elements cannot be equal.</li>
<li>
<code>"strictdescend"</code>: the elements are strictly descending, and consecutive elements cannot be equal.</li>
</ul>
<div class="section level3">
<h3 id="examples-53">Examples<a class="anchor" aria-label="anchor" href="#examples-53"></a>
</h3>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_sorted1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a>  vec a(n, fill::randu);</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a>  vec b = sort(a);</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true"></a>  mat A(<span class="dv">10</span>, <span class="dv">10</span>, fill::randu);</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true"></a></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true"></a>  writable::logicals res(<span class="dv">4</span>);</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true"></a>  res[<span class="dv">0</span>] = a.is_sorted();</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = b.is_sorted();</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A.is_sorted(<span class="st">"descend"</span>, <span class="dv">1</span>);</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true"></a>  res[<span class="dv">4</span>] = A.is_sorted(<span class="st">"ascend"</span>, <span class="dv">1</span>);</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true"></a></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"a_sorted"</span>, <span class="st">"b_sorted"</span>, <span class="st">"A_descend"</span>,</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true"></a>    <span class="st">"A_ascend"</span>});</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true"></a></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-upper-triangularlower-triangular">Is upper triangular/lower triangular<a class="anchor" aria-label="anchor" href="#is-upper-triangularlower-triangular"></a>
</h2>
<p><code>.is_trimatu()</code> and <code>.is_trimatl()</code> are member functions of <code>Mat</code> and <code>SpMat</code>. <code>.is_trimatu()</code> returns <code>true</code> if the matrix is upper triangular (e.g., the matrix is square sized and all elements below the main diagonal are zero) and <code>false</code> otherwise. <code>.is_trimatl()</code> returns <code>true</code> if the matrix is lower triangular (e.g., the matrix is square sized and all elements above the main diagonal are zero) and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-54">Examples<a class="anchor" aria-label="anchor" href="#examples-54"></a>
</h3>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_triangular1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true"></a>  mat B = trimatl(A);</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = B.is_trimatu();</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_trimatl();</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true"></a></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true"></a>  B.reset();</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = B.is_trimatu();</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true"></a></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"is_trimatu"</span>, <span class="st">"is_trimatl"</span>,</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true"></a>    <span class="st">"is_trimatu_after_reset"</span>});</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true"></a></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-7">Caveat<a class="anchor" aria-label="anchor" href="#caveat-7"></a>
</h3>
<p>If these functions return <code>true</code>, do not assume that the matrix contains non-zero elements on or above/below the main diagonal. It is possible to have an empty matrix (e.g., 0x0 as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-diagonal">Is diagonal<a class="anchor" aria-label="anchor" href="#is-diagonal"></a>
</h2>
<p><code>is_diagmat()</code> is a member function of <code>Mat</code> and <code>SpMat</code>. It returns <code>true</code> if the matrix is diagonal (e.g., all elements outside of the main diagonal are zero). If the matrix is not square sized, a <code>std::logic_error</code> exception is thrown.</p>
<div class="section level3">
<h3 id="examples-55">Examples<a class="anchor" aria-label="anchor" href="#examples-55"></a>
</h3>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_diagonal1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a>  mat B = diagmat(A);</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true"></a></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_diagmat();</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_diagmat();</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true"></a></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true"></a>  A.reset();</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A.is_diagmat();</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true"></a></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_diagmat"</span>, <span class="st">"B_diagmat"</span>,</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true"></a>    <span class="st">"A_diagmat_after_reset"</span>});</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true"></a></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-8">Caveat<a class="anchor" aria-label="anchor" href="#caveat-8"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the matrix contains non-zero elements on the main diagonal only. It is possible to have an empty matrix (e.g., 0x0 as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-square">Is square<a class="anchor" aria-label="anchor" href="#is-square"></a>
</h2>
<p><code>.is_square()</code> is a member function of the <code>Mat</code> and <code>SpMat</code> classes. It returns <code>true</code> if the matrix is square sized (e.g., the number of rows is equal to the number of columns) and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-56">Examples<a class="anchor" aria-label="anchor" href="#examples-56"></a>
</h3>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_square1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true"></a>  mat B = diagmat(A);</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_square();</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_square();</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true"></a></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true"></a>  A.reset();</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A.is_square();</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true"></a></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_square"</span>, <span class="st">"B_square"</span>,</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true"></a>    <span class="st">"A_square_after_reset"</span>});</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true"></a></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-8">Caveats<a class="anchor" aria-label="anchor" href="#caveats-8"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the matrix is non-empty. It is possible to have an empty matrix (e.g., 0x0 as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-symmetric">Is symmetric<a class="anchor" aria-label="anchor" href="#is-symmetric"></a>
</h2>
<p><code>.is_symmetric()</code> is a member function of the <code>Mat</code> and <code>SpMat</code> classes. It returns <code>true</code> if the matrix is symmetric (e.g., the matrix is square sized and the transpose is equal to the original matrix) and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-57">Examples<a class="anchor" aria-label="anchor" href="#examples-57"></a>
</h3>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_symmetric1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true"></a>  mat B = symmatu(A);</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_symmetric();</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_symmetric();</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true"></a></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true"></a>  A.reset();</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A.is_symmetric();</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true"></a></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_symmetric"</span>, <span class="st">"B_symmetric"</span>,</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true"></a>    <span class="st">"A_symmetric_after_reset"</span>});</span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true"></a></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-9">Caveats<a class="anchor" aria-label="anchor" href="#caveats-9"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the matrix is non-empty. It is possible to have an empty matrix (e.g., 0x0 as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-hermitian">Is hermitian<a class="anchor" aria-label="anchor" href="#is-hermitian"></a>
</h2>
<p><code>.is_hermitian()</code> is a member function of the <code>Mat</code> and <code>SpMat</code> classes. It returns <code>true</code> if the matrix is Hermitian or self-adjoint (e.g., the matrix is square sized and the conjugate transpose is equal to the original matrix) and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-58">Examples<a class="anchor" aria-label="anchor" href="#examples-58"></a>
</h3>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_hermitian1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true"></a>  cx_mat A(n, n, fill::randu);</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true"></a>  cx_mat B = A.t() * A;</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true"></a></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_hermitian();</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_hermitian();</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true"></a></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true"></a>  A.reset();</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A.is_hermitian();</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true"></a></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_hermitian"</span>, <span class="st">"B_hermitian"</span>,</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true"></a>    <span class="st">"A_hermitian_after_reset"</span>});</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true"></a></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveats-10">Caveats<a class="anchor" aria-label="anchor" href="#caveats-10"></a>
</h3>
<p>If this function returns <code>true</code>, do not assume that the matrix is non-empty. It is possible to have an empty matrix (e.g., 0x0 as in the examples).</p>
</div>
</div>
<div class="section level2">
<h2 id="is-symmetrichermitian-positive-definite">Is symmetric/hermitian positive definite<a class="anchor" aria-label="anchor" href="#is-symmetrichermitian-positive-definite"></a>
</h2>
<p><code>.is_sympd()</code> and <code>.is_sympd(tol)</code> are a member function of the <code>Mat</code> and <code>SpMat</code> classes. It returns <code>true</code> if the matrix is symmetric/hermitian positive definite within a tolerance (e.g., the matrix is square sized and all its eigenvalues are positive) and <code>false</code> otherwise. The <code>tol</code> argument is optional, the default is <code>tol = 100 * datum::eps * norm(X, "fro")</code>.</p>
<div class="section level3">
<h3 id="examples-59">Examples<a class="anchor" aria-label="anchor" href="#examples-59"></a>
</h3>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_sympd1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true"></a>  mat B = A * A.t();</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_sympd();</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_sympd();</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true"></a></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true"></a>  A.reset();</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true"></a>  res[<span class="dv">2</span>] = A.is_sympd();</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true"></a></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_sympd"</span>, <span class="st">"B_sympd"</span>,</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true"></a>    <span class="st">"A_sympd_after_reset"</span>});</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true"></a></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-zero">Is zero<a class="anchor" aria-label="anchor" href="#is-zero"></a>
</h2>
<p><code>.is_zero()</code> and <code>.is_zero(tol)</code> are a member function of the <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, and <code>SpMat</code> classes. It returns <code>true</code> if all elements are zero within a tolerance and <code>false</code> otherwise. For complex numbers, each component (real and imaginary) is checked separately. The <code>tol</code> argument is optional.</p>
<div class="section level3">
<h3 id="examples-60">Examples<a class="anchor" aria-label="anchor" href="#examples-60"></a>
</h3>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_zero1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true"></a>  cube B(n, n, n, fill::zeros);</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true"></a>  sp_mat C(n, n);</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true"></a></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_zero(<span class="fl">0.005</span>);</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_zero(<span class="fl">0.005</span>);</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true"></a>  res[<span class="dv">2</span>] = C.is_zero(<span class="fl">0.005</span>);</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true"></a></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_is_zero"</span>, <span class="st">"B_is_zero"</span>, <span class="st">"C_is_zero"</span>});</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true"></a></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="is-finite">Is finite<a class="anchor" aria-label="anchor" href="#is-finite"></a>
</h2>
<p><code>.is_finite()</code> is a member function of the <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, and <code>SpMat</code> classes. It returns <code>true</code> if all elements are finite and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-61">Examples<a class="anchor" aria-label="anchor" href="#examples-61"></a>
</h3>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">is_finite1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true"></a>  cube B(n, n, n, fill::randu);</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true"></a>  sp_mat C(n, n);</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true"></a></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true"></a>  <span class="co">// Insert infinite values</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true"></a>  B(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) = datum::inf;</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true"></a>  C(<span class="dv">0</span>, <span class="dv">0</span>) = -<span class="fl">1.0</span> * datum::inf;</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true"></a></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.is_finite();</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.is_finite();</span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true"></a>  res[<span class="dv">2</span>] = C.is_finite();</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true"></a></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_is_finite"</span>, <span class="st">"B_is_finite"</span>, <span class="st">"C_is_finite"</span>});</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true"></a></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="has-infinity">Has infinity<a class="anchor" aria-label="anchor" href="#has-infinity"></a>
</h2>
<p><code>.has_inf()</code> is a member function of the <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, and <code>SpMat</code> classes. It returns <code>true</code> if the object contains at least one infinite value and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-62">Examples<a class="anchor" aria-label="anchor" href="#examples-62"></a>
</h3>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">has_inf1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a>  cube B(n, n, n, fill::randu);</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a>  sp_mat C(n, n);</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true"></a>  <span class="co">// Insert infinite values</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true"></a>  B(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) = datum::inf;</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true"></a>  C(<span class="dv">0</span>, <span class="dv">0</span>) = -<span class="fl">1.0</span> * datum::inf;</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true"></a></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.has_inf();</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.has_inf();</span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true"></a>  res[<span class="dv">2</span>] = C.has_inf();</span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true"></a></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_has_inf"</span>, <span class="st">"B_has_inf"</span>, <span class="st">"C_has_inf"</span>});</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true"></a></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="has-not-a-number">Has not-a-number<a class="anchor" aria-label="anchor" href="#has-not-a-number"></a>
</h2>
<p><code>.has_nan()</code> is a member function of the <code>Mat</code>, <code>Col</code>, <code>Row</code>, <code>Cube</code>, and <code>SpMat</code> classes. It returns <code>true</code> if the object contains at least one not-a-number (NaN) value and <code>false</code> otherwise.</p>
<div class="section level3">
<h3 id="examples-63">Examples<a class="anchor" aria-label="anchor" href="#examples-63"></a>
</h3>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a>[[<span class="at">cpp11</span>::<span class="at">register</span>]] logicals <span class="va">has_nan1_</span>(<span class="at">const</span> <span class="dt">int</span>&amp; n) {</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a>  mat A(n, n, fill::randu);</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true"></a>  cube B(n, n, n, fill::randu);</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true"></a>  sp_mat C(n, n);</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true"></a></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true"></a>  <span class="co">// Insert NaN values</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true"></a>  B(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>) = datum::nan;</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true"></a>  C(<span class="dv">0</span>, <span class="dv">0</span>) = -<span class="fl">1.0</span> * datum::nan;</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true"></a></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true"></a>  writable::logicals res(<span class="dv">3</span>);</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true"></a>  res[<span class="dv">0</span>] = A.has_nan();</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true"></a>  res[<span class="dv">1</span>] = B.has_nan();</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true"></a>  res[<span class="dv">2</span>] = C.has_nan();</span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true"></a></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true"></a>  res.attr(<span class="st">"names"</span>) = strings({<span class="st">"A_has_nan"</span>, <span class="st">"B_has_nan"</span>, <span class="st">"C_has_nan"</span>});</span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true"></a></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true"></a>  <span class="cf">return</span> res;</span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="caveat-9">Caveat<a class="anchor" aria-label="anchor" href="#caveat-9"></a>
</h3>
<p><code>NaN</code> is not equal to anything, even itself.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Mauricio Vargas Sepulveda, Conrad Sanderson.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
