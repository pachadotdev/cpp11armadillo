`as_dense()`

*   Member function of any sparse matrix expression
  
*   Returns a dense vector/matrix representation of the sparse matrix expression
  
*   This function aims to avoid construction of the intermediate sparse matrix representation of the expression  
    (applicable to some expressions)
  
*   Examples:
    
    sp_mat A; A.sprandu(1000, 1000, 0.1);
    
    // store the sum of each column of A directly in dense row vector 
    rowvec r = sum(A).as_dense();      
    
    // extract column 123 of A directly into dense column vector
    colvec c = A.col(123).as_dense();  
    
  
*   See also:
    *   [as_scalar()](#as_scalar)
    *   [.as_col() / .as_row()](#as`Col`row)
  

* * *

  

`t()  
.st()`

*   Member functions of any matrix or vector expression
  
*   For real (non-complex) matrix:
    *   _.t()_ provides a transposed copy of the matrix
    *   _.st()_ is not applicable
  
*   For complex matrix:
    *   _.t()_ provides a Hermitian (conjugate) transposed copy (e.g., signs of imaginary components are flipped)
    *   _.st()_ provides a simple transposed copy (e.g., signs of imaginary components are not flipped)
  
*   Examples:
    
    mat A(4, 5, fill::randu);
    mat B = A.t();
    
  
*   See also:
    *   [trans()](#trans)
    *   [reverse()](#reverse)
    *   [.as_col() / .as_row()](#as`Col`row)
    *   [transpose in Wikipedia](https://en.wikipedia.org/wiki/Transpose)
    *   [transpose in MathWorld](https://mathworld.wolfram.com/Transpose.html)
    *   [conjugate transpose in Wikipedia](https://en.wikipedia.org/wiki/Conjugate_transpose)
    *   [conjugate transpose in MathWorld](https://mathworld.wolfram.com/ConjugateTranspose.html)
  

* * *

  

`i()`

*   Member function of any matrix expression
  
*   Provides an inverse of the matrix expression
  
*   If the matrix expression is not square sized, a _std::logic_error_ exception is thrown
  
*   If the matrix expression appears to be singular, the output matrix is reset and a _std::runtime_error_ exception is thrown
  
*   **Caveats:**
    *   if matrix _A_ is know to be symmetric positive definite, [inv_sympd()](#inv_sympd) is faster
    *   to solve a system of linear equations, such as _Z = inv(X)\*Y_, [solve()](#solve) can be faster and/or more accurate
  
*   Examples:
    
    mat A(4, 4, fill::randu);
    
    mat X = A.i();
    
    mat Y = (A+A).i();
    
*   See also:
    *   [inv()](#inv)
    *   [rcond()](#rcond)
    *   [pinv()](#pinv)
    *   [solve()](#solve)
  

* * *

  

`min()`  
`max()`

*   Return the extremum value of any matrix or cube expression
  
*   For objects with complex numbers, absolute values are used for comparison
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    
    double max_val = A.max();
    
  
*   See also:
    *   [.index_min() & .index_max()](#index_min_and_index_max_member)
    *   [min() & max()](#min_and_max) (standalone functions with extended functionality)
    *   [clamp()](#clamp)
    *   [running_stat](#running_stat)
    *   [running_stat_vec](#running_stat_vec)
  

* * *

  

`index_min()`  
`index_max()`

*   Return the linear index of the extremum value of any matrix or cube expression
  
*   For objects with complex numbers, absolute values are used for comparison
  
*   The returned index is of type [uword](#uword)
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    
    uword i = A.index_max();
    
    double max_val = A(i);
    
  
*   See also:
    *   [.min() & .max()](#min_and_max_member)
    *   [index_min() & index_max()](#index_min_and_index_max_standalone) (standalone functions with extended functionality)
    *   [ind2sub()](#ind2sub)
    *   [sort_index()](#sort_index)
    *   [find()](#find)
    *   [element access](#element_access)
  

* * *

  

`eval()`  

*   Member function of any matrix or vector expression
  
*   Explicitly forces the evaluation of a delayed expression and outputs a matrix
  
*   This function should be used sparingly and only in cases where it is absolutely necessary; indiscriminate use can degrade performance
  
*   Examples:
    
    cx_mat A( randu<mat>(4,4), randu<mat>(4,4) );
    
    real(A).eval().save("A_real.dat", raw_ascii);
    imag(A).eval().save("A_imag.dat", raw_ascii);
    
  
*   See also:
    *   [as_scalar()](#as_scalar)
    *   [Mat class](#Mat)
  

* * *

  

`in_range(** i **)`

  

 

(member of `Mat`, `Col`, `Row`, `Cube`, `SpMat`, `field`)

`in_range( span(**start**,** end**) )`

  

 

(member of `Mat`, `Col`, `Row`, `Cube`, `SpMat`, `field`)

 

`in_range(** row**,** col **)`

  

 

(member of `Mat`, `Col`, `Row`, `SpMat`, `field`)

`in_range(** **span(**start_row**,** end_row**), span(**start_col**,** end_col**)` **)`

  

 

(member of `Mat`, `Col`, `Row`, `SpMat`, `field`)

 

`in_range(** row**,** col**,** slice **)`

  

 

(member of `Cube` and `field`)

`in_range(** **span(**start_row**,** end_row**), span(**start_col**,** end_col**), span(**start_slice**,** end_slice**)` **)`

  

 

(member of `Cube` and `field`)

 

`in_range(** first_row**,** first_col**, size(**X**) )`   _(X is a matrix or field)_

  

 

(member of `Mat`, `Col`, `Row`, `SpMat`, `field`)

`in_range(** first_row**,** first_col**, size(**n_rows**,** n_cols**) )`

  

 

(member of `Mat`, `Col`, `Row`, `SpMat`, `field`)

 

`in_range(** first_row**,** first_col**,** first_slice**, size(**Q**) )`   _(Q is a cube or field)_

  

 

(member of `Cube` and `field`)

`in_range(** first_row**,** first_col**,** first_slice**, size(**n_rows**,** n_cols n_slices**) )`

  

 

(member of `Cube` and `field`)

*   Returns _true_ if the given location or span is currently valid
  
*   Returns _false_ if the object is empty, the location is out of bounds, or the span is out of bounds
  
*   Instances of _span(a,b)_ can be replaced by:
    *   _span()_ or _span::all_, to indicate the entire range
    *   _span(a)_, to indicate a particular row, column or slice
  
*   Examples:
    
    mat A(4, 5, fill::randu);
    
    cout << A.in_range(0,0) << endl;  // true
    cout << A.in_range(3,4) << endl;  // true
    cout << A.in_range(4,5) << endl;  // false
    
  
*   See also:
    *   [element access](#element_access)
    *   [submatrix views](#submat)
    *   [subcube views](#subcube)
    *   [subfield views](#subfield)
    *   [.set_size()](#set_size)
  

* * *

  

`is_empty()`

*   Returns _true_ if the object has no elements
  
*   Returns _false_ if the object has one or more elements
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    cout << A.is_empty() << endl;
    
    A.reset();
    cout << A.is_empty() << endl;
    
  
*   See also:
    *   [.is_square()](#is_square)
    *   [.is_vec()](#is_vec)
    *   [.is_finite()](#is_finite)
    *   [.reset()](#reset)
  

* * *

  

`is_vec()`  
`is_colvec()`  
`is_rowvec()`

*   Member functions of `Mat` and `SpMat`
  
*   .is_vec():
    *   returns _true_ if the matrix can be interpreted as a vector (either column or row vector)
    *   returns _false_ if the matrix does not have exactly one column or one row
  
*   .is_colvec():
    *   returns _true_ if the matrix can be interpreted as a column vector
    *   returns _false_ if the matrix does not have exactly one column
  
*   .is_rowvec():
    *   returns _true_ if the matrix can be interpreted as a row vector
    *   returns _false_ if the matrix does not have exactly one row
  
*   **Caveat:** do not assume that the vector has elements if these functions return _true_; it is possible to have an empty vector (eg. 0x1)
  
*   Examples:
    
    mat A(1, 5, fill::randu);
    mat B(5, 1, fill::randu);
    mat C(5, 5, fill::randu);
    
    cout << A.is_vec() << endl;
    cout << B.is_vec() << endl;
    cout << C.is_vec() << endl;
    
  
*   See also:
    *   [.is_empty()](#is_empty)
    *   [.is_square()](#is_square)
    *   [.is_finite()](#is_finite)
  

* * *

  

`is_sorted()`  
`is_sorted( sort_direction )`  
`is_sorted( sort_direction, dim )`

*   Member function of `Mat`, `Row` and `Col`
  
*   If the object is a vector, return a _bool_ indicating whether the elements are sorted
  
*   If the object is a matrix, return a _bool_ indicating whether the elements are sorted in each column (_dim = 0_), or each row (_dim = 1_)
  
*   The _sort_direction_ argument is optional; _sort_direction_ is one of:
    
    `"ascend"`
    
     ↦ 
    
    elements are ascending; consecutive elements can be equal; this is the **default operation**
    
    `"descend"`
    
     ↦ 
    
    elements are descending; consecutive elements can be equal
    
    `"strictascend"`
    
     ↦ 
    
    elements are strictly ascending; consecutive elements cannot be equal
    
    `"strictdescend"`
    
     ↦ 
    
    elements are strictly descending; consecutive elements cannot be equal
    
  
*   The _dim_ argument is optional; by default _dim = 0_ is used
  
*   For matrices and vectors with complex numbers, order is checked via absolute values
  
*   Examples:
    
    vec a(10, fill::randu);
    vec b = sort(a);
    
    bool check1 = a.is_sorted();
    bool check2 = b.is_sorted();
    
    
    mat A(10, 10, fill::randu);
    
    // check whether each column is sorted in descending manner
    cout << A.is_sorted("descend") << endl;
    
    // check whether each row is sorted in ascending manner
    cout << A.is_sorted("ascend", 1) << endl;
    
  
*   See also:
    *   [sort()](#sort)
    *   [sort_index()](#sort_index)
  

* * *

  

`is_trimatu()`  
`is_trimatl()`

*   Member functions of `Mat` and `SpMat`
  
*   _.is_trimatu()_:
    *   return _true_ if the matrix is upper triangular, e.g., the matrix is square sized and all elements below the main diagonal are zero; return _false_ otherwise
    *   **caveat:** if this function returns _true_, do not assume that the matrix contains non-zero elements on or above the main diagonal
  
*   _.is_trimatl()_:
    *   return _true_ if the matrix is lower triangular, e.g., the matrix is square sized and all elements above the main diagonal are zero; return _false_ otherwise
    *   **caveat:** if this function returns _true_, do not assume that the matrix contains non-zero elements on or below the main diagonal
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B = trimatl(A);
    
    cout << A.is_trimatu() << endl;
    cout << B.is_trimatl() << endl;
    
  
*   See also:
    *   [trimatu() / trimatl()](#trimat)
    *   [.is_symmetric()](#is_symmetric)
    *   [.is_diagmat()](#is_diagmat)
    *   [Triangular matrix in MathWorld](https://mathworld.wolfram.com/TriangularMatrix.html)
    *   [Triangular matrix in Wikipedia](https://en.wikipedia.org/wiki/Triangular_matrix)
  

* * *

  

`is_diagmat()`

*   Member function of `Mat` and `SpMat`
  
*   Return _true_ if the matrix is diagonal, e.g., all elements outside of the main diagonal are zero
  
*   Return _false_ otherwise
  
*   **Caveat:** if this function returns _true_, do not assume that the matrix contains non-zero elements on the main diagonal
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B = diagmat(A);
    
    cout << A.is_diagmat() << endl;
    cout << B.is_diagmat() << endl;
    
  
*   See also:
    *   [diagmat()](#diagmat)
    *   [.is_trimatu() / .is_trimatl()](#is_trimat)
    *   [.is_symmetric()](#is_symmetric)
    *   [Diagonal matrix in MathWorld](https://mathworld.wolfram.com/DiagonalMatrix.html)
    *   [Diagonal matrix in Wikipedia](https://en.wikipedia.org/wiki/Diagonal_matrix)
  

* * *

  

`is_square()`

*   Member function of `Mat` and `SpMat`
  
*   Returns _true_ if the matrix is square, e.g., number of rows is equal to the number of columns
  
*   Returns _false_ if the matrix is not square
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B(6, 7, fill::randu);
    
    cout << A.is_square() << endl;
    cout << B.is_square() << endl;
    
  
*   See also:
    *   [.is_symmetric()](#is_symmetric)
    *   [.is_hermitian()](#is_hermitian)
    *   [.is_empty()](#is_empty)
    *   [.is_vec()](#is_vec)
    *   [.is_finite()](#is_finite)
  

* * *

  

`is_symmetric()`  
`is_symmetric( tol )`

*   Member function of `Mat` and `SpMat`
  
*   Returns _true_ if the matrix is symmetric
  
*   Returns _false_ if the matrix is not symmetric
  
*   The _tol_ argument is optional; if _tol_ is specified, the given matrix _X_ is considered symmetric if _norm(X - X.st(), "inf") / norm (X, "inf") ≤ tol_
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B = A.t() \* A;
    
    cout << A.is_symmetric() << endl;
    cout << B.is_symmetric() << endl;
    
  
*   See also:
    *   [.is_hermitian()](#is_hermitian)
    *   [.is_sympd()](#is_sympd)
    *   [.is_square()](#is_square)
    *   [.is_trimatu() / .is_trimatl()](#is_trimat)
    *   [Symmetric matrix in Wikipedia](https://en.wikipedia.org/wiki/Symmetric_matrix)
    *   [Symmetric matrix in MathWorld](https://mathworld.wolfram.com/SymmetricMatrix.html)
  

* * *

  

`is_hermitian()`  
`is_hermitian( tol )`

*   Member function of `Mat` and `SpMat`
  
*   Returns _true_ if the matrix is hermitian (self-adjoint)
  
*   Returns _false_ if the matrix is not hermitian
  
*   The _tol_ argument is optional; if _tol_ is specified, the given matrix _X_ is considered hermitian if _norm(X - X.t(), "inf") / norm (X, "inf") ≤ tol_
  
*   Examples:
    
    cx_mat A(5, 5, fill::randu);
    cx_mat B = A.t() \* A;
    
    cout << A.is_hermitian() << endl;
    cout << B.is_hermitian() << endl;
    
  
*   See also:
    *   [.is_symmetric()](#is_symmetric)
    *   [.is_sympd()](#is_sympd)
    *   [.is_square()](#is_square)
    *   [Hermitian matrix in Wikipedia](https://en.wikipedia.org/wiki/Hermitian_matrix)
    *   [Hermitian matrix in MathWorld](https://mathworld.wolfram.com/HermitianMatrix.html)
  

* * *

  

`is_sympd()`  
`is_sympd( tol )`

*   Member function of `Mat` and any dense matrix expression
  
*   Returns _true_ if the matrix is symmetric/hermitian positive definite within the tolerance given by _tol_
  
*   Returns _false_ otherwise
  
*   The _tol_ argument is optional; if _tol_ is not specified, by default _tol = 100 \* datum::eps \* norm(X, "fro")_
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    
    mat B = A.t() \* A;
    
    cout << A.is_sympd() << endl;
    cout << B.is_sympd() << endl;
    
  
*   See also:
    *   [.is_symmetric()](#is_symmetric)
    *   [.is_hermitian()](#is_hermitian)
    *   [datum::eps](#constants)
  

* * *

  

`is_zero()`  
`is_zero(** tolerance **)`

*   For objects with non-complex elements: return _true_ if each element has an absolute value ≤ _tolerance_; return _false_ otherwise
  
*   For objects with complex elements: return _true_ if for each element, each component (real and imaginary) has an absolute value ≤ _tolerance_; return _false_ otherwise
  
*   The argument _tolerance_ is optional; by default _tolerance = 0_
  
*   Examples:
    
    mat A(5, 5, fill::zeros);
    
    A(0,0) = datum::eps;
    
    cout << A.is_zero()           << endl;
    cout << A.is_zero(datum::eps) << endl;
    
  
*   See also:
    *   [.clean()](#clean)
    *   [all()](#all)
    *   [datum::eps](#constants)
    *   [approx_equal()](#approx_equal)
  

* * *

  

`is_finite()`

*   Member function of `Mat`, `Col`, `Row`, `Cube`, `SpMat`
  
*   Returns _true_ if all elements of the object are finite
  
*   Returns _false_ if at least one of the elements of the object is non-finite (�infinity or NaN)
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B(5, 5, fill::randu);
    
    B(1,1) = datum::inf;
    
    cout << A.is_finite() << endl;
    cout << B.is_finite() << endl;
    
  
*   See also:
    *   [.has_inf()](#has_inf)
    *   [.has_nan()](#has_nan)
    *   [find_finite()](#find_finite)
    *   [find_nonfinite()](#find_nonfinite)
    *   [constants (pi, nan, inf, ...)](#constants)
  

* * *

  

`has_inf()`

*   Member function of `Mat`, `Col`, `Row`, `Cube`, `SpMat`
  
*   Returns _true_ if at least one of the elements of the object is �infinity
  
*   Returns _false_ otherwise
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B(5, 5, fill::randu);
    
    B(1,1) = datum::inf;
    
    cout << A.has_inf() << endl;
    cout << B.has_inf() << endl;
    
  
*   See also:
    *   [.has_nan()](#has_nan)
    *   [.replace()](#replace)
    *   [.is_finite()](#is_finite)
    *   [find_nonfinite()](#find_nonfinite)
    *   [constants (pi, nan, inf, ...)](#constants)
  

* * *

  

`has_nan()`

*   Member function of `Mat`, `Col`, `Row`, `Cube`, `SpMat`
  
*   Returns _true_ if at least one of the elements of the object is NaN (not-a-number)
  
*   Returns _false_ otherwise
  
*   **Caveat:** `NaN` is not equal to anything, even itself
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B(5, 5, fill::randu);
    
    B(1,1) = datum::nan;
    
    cout << A.has_nan() << endl;
    cout << B.has_nan() << endl;
    
  
*   See also:
    *   [.has_inf()](#has_inf)
    *   [.replace()](#replace)
    *   [.is_finite()](#is_finite)
    *   [find_nonfinite()](#find_nonfinite)
    *   [constants (pi, nan, inf, ...)](#constants)
  

* * *

  

`print()`  
`print( header )`  
  
`print( stream )`  
`print( stream, header )`

*   Member functions of `Mat`, `Col`, `Row`, `SpMat`, `Cube` and `field`
  
*   Print the contents of an object to the _std::cout_ stream (default), or a user specified stream, with an optional header string
  
*   Objects can also be printed using the << stream operator
  
*   Elements of a field can only be printed if there is an associated _operator<<_ function defined
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    mat B(6, 6, fill::randu);
    
    A.print();
    
    // print a transposed version of A
    A.t().print();
    
    // "B:" is the optional header line
    B.print("B:");
    
    cout << A << endl;
    
    cout << "B:" << endl;
    cout << B << endl;
    
  
*   See also:
    *   [.raw_print()](#raw_print)
    *   [.brief_print()](#brief_print)
    *   [saving & loading matrices](#save_load_mat)
    *   [initialising elements](#element_initialisation)
    *   [output streams](#output_streams)
  

* * *

  

`raw_print()`  
`raw_print( header )`  
  
`raw_print( stream )`  
`raw_print( stream, header )`

*   Member functions of `Mat`, `Col`, `Row`, `SpMat` and `Cube`
  
*   Similar to the [.print()](#print) member function, with the difference that no formatting of the output is done; the stream's parameters such as precision, cell width, etc. can be set manually
  
*   If the cell width is set to zero, a space is printed between the elements
  
*   Examples:
    
    mat A(5, 5, fill::randu);
    
    cout.precision(11);
    cout.setf(ios::fixed);
    
    A.raw_print(cout, "A:");
    
  
*   See also:
    *   [.print()](#print)
    *   [.brief_print()](#brief_print)
    *   [std::ios_base::fmtflags](https://en.cppreference.com/w/cpp/io/ios_base/fmtflags) (cppreference.com)
    *   [std::ios_base::fmtflags](https://cplusplus.com/reference/ios/ios_base/fmtflags/) (cplusplus.com)
  

* * *

  

`brief_print()`  
`brief_print( header )`  
  
`brief_print( stream )`  
`brief_print( stream, header )`

*   Member functions of `Mat`, `Col`, `Row`, `SpMat` and `Cube`
  
*   Print a shortened/abridged version of an object and its size to the _std::cout_ stream (default), or a user specified stream, with an optional header string
  
*   Can be useful for gaining a glimpse of large matrices
  
*   Examples:
    
    mat A(123, 456, fill::randu);
    
    A.brief_print("A:");
    
    // possible output:
    // 
    // A:
    // \[matrix size: 123x456\]
    //    0.8402   0.7605   0.6218      ...   0.9744
    //    0.3944   0.9848   0.0409      ...   0.7799
    //    0.7831   0.9350   0.4140      ...   0.8835
    //         :        :        :        :        :        
    //    0.4954   0.1826   0.9848      ...   0.1918
    
  
*   See also:
    *   [.print()](#print)
    *   [.raw_print()](#raw_print)
  

* * *

  

**saving / loading matrices & cubes**  
  

`save(** filename **)`  
`save(** filename**,** file_type **)`  
  
`save(** stream **)`  
`save(** stream**,** file_type **)`  
  
`save( hdf5_name(**filename**,** dataset**) )`  
`save( hdf5_name(**filename**,** dataset**,** settings**) )`  
  
`save( csv_name(**filename**,** header**) )`  
`save( csv_name(**filename**,** header**,** settings**) )`

      

`load(** filename **)`  
`load(** filename**,** file_type **)`  
  
`load(** stream **)`  
`load(** stream**,** file_type **)`  
  
`load( hdf5_name(**filename**,** dataset**) )`  
`load( hdf5_name(**filename**,** dataset**,** settings**) )`  
  
`load( csv_name(**filename**,** header**) )`  
`load( csv_name(**filename**,** header**,** settings**) )`

  

*   Member functions of `Mat`, `Col`, `Row`, `Cube` and `SpMat`
  
*   Store/retrieve data in a file or stream (**caveat:** the stream must be opened in binary mode)
  
*   On success, _.save()_ and _.load()_ return a _bool_ set to _true_
  
*   On failure, _.save()_ and _.load()_ return a _bool_ set to _false_; additionally, _.load()_ resets the object so that it has no elements
  
*   _file_type_ can be one of the following:  
      
    
    **auto_detect**
    
      
    
    Used only by _.load()_ only: attempt to automatically detect the file type as one of the formats described below;  
    \[ default operation for _.load()_ \]  
      
    
    **arma_binary**  
    
      
    
    Numerical data stored in machine dependent binary format, with a simple header to speed up loading. The header indicates the type and size of matrix/cube.  
    \[ default operation for _.save()_ \]  
      
    
    **arma_ascii**
    
      
    
    Numerical data stored in human readable text format, with a simple header to speed up loading. The header indicates the type and size of matrix/cube.  
      
    
    **raw_binary**
    
      
    
    Numerical data stored in machine dependent raw binary format, without a header. Matrices are loaded to have one column, while cubes are loaded to have one slice with one column. The [.reshape()](#reshape_member) function can be used to alter the size of the loaded matrix/cube without losing data.  
      
    
    **raw_ascii**
    
      
    
    Numerical data stored in raw ASCII format, without a header. The numbers are separated by whitespace. The number of columns must be the same in each row. Cubes are loaded as one slice. Data which was saved in Matlab/Octave using the _\-ascii_ option can be read in Armadillo, except for complex numbers. Complex numbers are stored in standard C++ notation, which is a tuple surrounded by brackets: eg. (1.23,4.56) indicates 1.24 + 4.56i.  
      
    
    **csv_ascii**
    
      
    
    Numerical data stored in comma separated value (CSV) text format, **without** a header. To save/load **with** a header, use the **csv_name(**filename,header**)` specification instead (more details below). Handles complex numbers stored in the compound form of 1.24+4.56i. Applicable to `Mat` and `SpMat`.  
      
    
    **coord_ascii**
    
      
    
    Numerical data stored as a text file in coordinate list format, without a header. Only non-zero values are stored.  
    For real matrices, each line contains information in the following format:  `row column value`  
    For complex matrices, each line contains information in the following format:  `row column real_value imag_value`  
    The rows and columns start at zero.  
    Armadillo ≥ 10.3: applicable to `Mat` and `SpMat`; Armadillo ≤ 10.2: applicable to `SpMat` only.  
    **Caveat:** not supported by _auto_detect_.  
      
    
    **pgm_binary**
    
      
    
    Image data stored in Portable Gray Map (PGM) format. Applicable to `Mat` only. Saving _int_, _float_ or _double_ matrices is a lossy operation, as each element is copied and converted to an 8 bit representation. As such the matrix should have values in the \[0,255\] interval, otherwise the resulting image may not display correctly.  
      
    
    **ppm_binary**
    
      
    
    Image data stored in Portable Pixel Map (PPM) format. Applicable to `Cube` only. Saving _int_, _float_ or _double_ matrices is a lossy operation, as each element is copied and converted to an 8 bit representation. As such the cube/field should have values in the \[0,255\] interval, otherwise the resulting image may not display correctly.  
      
    
    **hdf5_binary**
    
      
    
    Numerical data stored in portable [HDF5](https://en.wikipedia.org/wiki/Hierarchical_Data_Format) binary format.
    
    *   for saving, the default dataset name within the HDF5 file is "dataset"
    *   for loading, the order of operations is: (1) try loading a dataset named "dataset", (2) try loading a dataset named "value", (3) try loading the first available dataset
    *   to explicitly control the dataset name, specify it via the **hdf5_name()` argument (more details below)
    
  
*   **Caveat:** for saving / loading HDF5 files, support for HDF5 must be enabled within Armadillo's [configuration](#config_hpp); the _hdf5.h_ header file must be available on your system and you will need to link with the HDF5 library (eg. `_-lhdf5_`). HDF5 support can be enabled by defining [ARMA_USE_HDF5](#config_hpp) before including the armadillo header:  
    `#define ARMA_USE_HDF5   #include <armadillo>`
  
*   By providing either **hdf5_name(**filename**,** dataset**)` or **hdf5_name(**filename**,** dataset**,** settings**)`, the _file_type_ type is assumed to be _hdf5_binary_  
      
    *   the _dataset_ argument specifies an HDF5 dataset name (eg. "my_dataset") that can include a full path (eg. "/group_name/my_dataset"); if a blank dataset name is specified (e.g., ""), it is assumed to be "dataset"  
          
        
    *   the _settings_ argument is optional; it is one of the following, or a combination thereof:  
          
        
        `hdf5_opts::trans`
        
           
        
        save/load the data with columns transposed to rows (and vice versa)
        
        `hdf5_opts::append`
        
           
        
        instead of overwriting the file, append the specified dataset to the file;  
        the specified dataset must not already exist in the file
        
        `hdf5_opts::replace`
        
           
        
        instead of overwriting the file, replace the specified dataset in the file  
        **caveat:** HDF5 may not automatically reclaim deleted space; use [h5repack](https://support.hdfgroup.org/HDF5/Tutor/cmdtooledit.html) to clean HDF5 files
        
          
        the above settings can be combined using the `+` operator; for example: `hdf5_opts::trans + hdf5_opts::append`
  
*   By providing either **csv_name(**filename**,** header**)` or **csv_name(**filename**,** header**,** settings**)`, the file is assumed to have data in comma separated value (CSV) text format  
      
    *   the _header_ argument specifies the object which stores the separate elements of the header line; it must have the type `[field<std::string>](#field)`  
          
        
    *   the optional _settings_ argument is one of the following, or a combination thereof:  
          
        
        `csv_opts::trans`
        
           
        
        save/load the data with columns transposed to rows (and vice versa)
        
        `csv_opts::no_header`
        
           
        
        assume there is no header line; the _header_ argument is not referenced
        
        `csv_opts::semicolon`
        
           
        
        use semicolon (;) instead of comma (,) as the separator character
        
        `csv_opts::strict`
        
           
        
        interpret missing values as NaN (not applicable to sparse matrices)
        
          
        the above settings can be combined using the `+` operator; for example: `csv_opts::trans + csv_opts::no_header`
  
*   Examples:
    
    mat A(5, 6, fill::randu);
    
    // default save format is arma_binary
    A.save("A.bin");
    
    // save in raw_ascii format
    A.save("A.txt", raw_ascii);
    
    // save in CSV format without a header
    A.save("A.csv", csv_ascii);
    
    // save in CSV format with a header
    field<std::string> header(A.n_cols);
    header(0) = "foo";
    header(1) = "bar";  // etc
    A.save( csv_name("A.csv", header) );
    
    // save in HDF5 format with internal dataset named as "my_data"
    A.save(hdf5_name("A.h5", "my_data"));
    
    // automatically detect format type while loading
    mat B;
    B.load("A.bin");
    
    // force loading in arma_ascii format
    mat C;
    C.load("A.txt", arma_ascii);
    
    
    // example of testing for success
    mat D;
    bool ok = D.load("A.bin");
    
    if(ok == false)
      {
      cout << "problem with loading" << endl;
      }
    
  
*   See also:
    *   [HDF](https://en.wikipedia.org/wiki/Hierarchical_Data_Format) in Wikipedia
    *   [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) in Wikipedia
    *   [saving / loading fields](#save_load_field)
  

* * *

  

**saving / loading fields**  
  

`save( name )`  
`save( name, file_type )`  
  
`save( stream )`  
`save( stream, file_type )`

      

`load( name )`  
`load( name, file_type )`  
  
`load( stream )`  
`load( stream, file_type )`

  

*   Store/retrieve data in a file or stream (**caveat:** the stream must be opened in binary mode)
  
*   On success, _.save()_ and _.load()_ return a _bool_ set to _true_
  
*   On failure, _.save()_ and _.load()_ return a _bool_ set to _false_; additionally, _.load()_ resets the object so that it has no elements
  
*   Fields with objects of type _std::string_ are saved and loaded as raw text files. The text files do not have a header. Each string is separated by a whitespace. _load()_ will only accept text files that have the same number of strings on each line. The strings can have variable lengths.
  
*   Other than storing string fields as text files, the following file formats are supported:  
      
    
    **auto_detect**
    
      
    
      
    *   _.load()_: attempt to automatically detect the field format type as one of the formats described below; this is the default operation
      
    
    **arma_binary**
    
      
    
      
    *   objects are stored in machine dependent binary format
    *   default type for fields of type `Mat`, `Col`, `Row` or `Cube`
    *   only applicable to fields of type `Mat`, `Col`, `Row` or `Cube`
      
    
    **ppm_binary**
    
      
    
      
    *   image data stored in Portable Pixmap Map (PPM) format
    *   only applicable to fields of type `Mat`, `Col` or `Row`
    *   _.load()_: loads the specified image and stores the red, green and blue components as three separate matrices; the resulting field is comprised of the three matrices, with the red, green and blue components in the first, second and third matrix, respectively
    *   _.save()_: saves a field with exactly three matrices of equal size as an image; it is assumed that the red, green and blue components are stored in the first, second and third matrix, respectively; saving _int_, _float_ or _double_ matrices is a lossy operation, as each matrix element is copied and converted to an 8 bit representation
    
  
*   See also:
    *   [saving / loading matrices and cubes](#save_load_mat)
