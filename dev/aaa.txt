<div class="pagebreak"></div>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Functions of Vectors&thinsp;/&thinsp;Matrices&thinsp;/&thinsp;Cubes</b></font>
<br>
<br>



<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="abs"></a>
<b>abs( X )</b>
<ul>
<li>
Obtain the magnitude of each element
</li>
<br>
<li>
Usage for non-complex X:
<ul>
<li>Y = abs(X)</li>
<li>X and Y must have the same matrix type or cube type, such as <i>mat</i> or <i>cube</i></li>
</ul>
</li>
<br>
<li>
Usage for complex X:
<ul>
<li><i>real_object_type</i> Y = abs(X)</li>
<li>The type of X must be a complex matrix or complex cube, such as <i>cx_mat</i> or <i>cx_cube</i></li>
<li>The type of Y must be the real counterpart to the type of X; if X has the type <i>cx_mat</i>, then the type of Y must be <i>mat</i>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);
mat B = abs(A); 

cx_mat X(5, 5, fill::randu);
   mat Y = abs(X);
</pre>
</ul>
</li>
<li>
See also:
<ul>
<li><a href="#arg">arg()</a></li>
<li><a href="#conj">conj()</a></li>
<li><a href="#imag_real">imag() / real()</a></li>
<li><a href="#pow">pow()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="accu"></a>
<b>accu( X )</b>
<ul>
<li>
Accumulate (sum) all elements of a vector, matrix or cube
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 6, fill::randu);
mat B(5, 6, fill::randu);

double x = accu(A);

double y = accu(A % B);

// accu(A % B) is a "multiply-and-accumulate" operation
// as operator % performs element-wise multiplication
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#sum">sum()</a></li>
<li><a href="#cumsum">cumsum()</a></li>
<li><a href="#trace">trace()</a></li>
<li><a href="#stats_fns">mean()</a></li>
<li><a href="#dot">dot()</a></li>
<li><a href="#as_scalar">as_scalar()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="affmul"></a>
<b>affmul( A, B )</b>
<ul>
<li>Multiply matrix <i>A</i> by an automatically extended form of <i>B</i></li>
<br>
<li><i>A</i> is typically an affine transformation matrix</li>
<br>
<li><i>B</i> can be a vector or matrix, and is treated as having an additional row of ones</li>
<br>
<li>The number of columns in <i>A</i> must be equal to number of rows in the extended form of <i>B</i> (ie. A.n_cols = B.n_rows+1)</li>
<br>
<li>If <i>A</i> is 3x3 and <i>B</i> is 2x1, the equivalent matrix multiplication is:</li>
<pre>
&#9121; C<sub>0</sub> &#9124;   &#9121; A<sub>00</sub> A<sub>01</sub> A<sub>02</sub> &#9124;   &#9121; B<sub>0</sub> &#9124;
&#9122; C<sub>1</sub> &#9125; = &#9122; A<sub>10</sub> A<sub>11</sub> A<sub>12</sub> &#9125; x &#9122; B<sub>1</sub> &#9125;
&#9123; C<sub>2</sub> &#9126;   &#9123; A<sub>20</sub> A<sub>21</sub> A<sub>22</sub> &#9126;   &#9123; 1<sub> </sub> &#9126;
</pre>
<li>If <i>A</i> is 2x3 and <i>B</i> is 2x1, the equivalent matrix multiplication is:</li>
<pre>
&#9121; C<sub>0</sub> &#9124;   &#9121; A<sub>00</sub> A<sub>01</sub> A<sub>02</sub> &#9124;   &#9121; B<sub>0</sub> &#9124;
&#9123; C<sub>1</sub> &#9126; = &#9123; A<sub>10</sub> A<sub>11</sub> A<sub>12</sub> &#9126; x &#9122; B<sub>1</sub> &#9125;
                          &#9123; 1<sub> </sub> &#9126;
</pre>
<li>
Examples:
<ul>
<pre>
mat A(2, 3, fill::randu);
vec B(2,    fill::randu);

vec C = affmul(A,B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#operators">math operators</a></li>
<li><a href="https://en.wikipedia.org/wiki/Affine_transformation">Affine transformation in Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transformation_matrix">Transformation matrix in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="all"></a>
<b>all( V )</b>
<br><b>all( X )</b>
<br><b>all( X, dim )</b>
<ul>
<li>For vector <i>V</i>, return <i>true</i> if all elements of the vector are non-zero or satisfy a relational condition</li>
<br>
<li>
For matrix <i>X</i> and
<ul>
<li>
<i>dim&thinsp;=&thinsp;0</i>, return a row vector (of type <a href="#Row">urowvec</a> or <a href="#Mat">umat</a>),
with each element (0 or 1) indicating whether the corresponding column of <i>X</i> has all non-zero elements</li>
<li>
<i>dim&thinsp;=&thinsp;1</i>, return a column vector (of type <a href="#Col">ucolvec</a> or <a href="#Mat">umat</a>),
with each element (0 or 1) indicating whether the corresponding row of <i>X</i> has all non-zero elements</li>
</ul>
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Relational operators can be used instead of <i>V</i> or <i>X</i>, eg. <i>A&thinsp;&gt;&thinsp;0.5</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec V(10,   fill::randu);
mat X(5, 5, fill::randu);


// status1 will be set to true if vector V has all non-zero elements
bool status1 = all(V);

// status2 will be set to true if vector V has all elements greater than 0.5
bool status2 = all(V &gt; 0.5);

// status3 will be set to true if matrix X has all elements greater than 0.6;
// note the use of vectorise()
bool status3 = all(vectorise(X) &gt; 0.6);

// generate a row vector indicating which columns of X have all elements greater than 0.7
umat A = all(X &gt; 0.7);

</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#any">any()</a></li>
<li><a href="#approx_equal">approx_equal()</a></li>
<li><a href="#find">find()</a></li>
<li><a href="#is_zero">.is_zero()</a></li>
<li><a href="#conv_to">conv_to()</a> (convert between matrix/vector types)</li>
<li><a href="#vectorise">vectorise()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="any"></a>
<b>any( V )</b>
<br><b>any( X )</b>
<br><b>any( X, dim )</b>
<ul>
<li>For vector <i>V</i>, return <i>true</i> if any element of the vector is non-zero or satisfies a relational condition</li>
<br>
<li>
For matrix <i>X</i> and
<ul>
<li>
<i>dim&thinsp;=&thinsp;0</i>, return a row vector (of type <a href="#Row">urowvec</a> or <a href="#Mat">umat</a>),
with each element (0 or 1) indicating whether the corresponding column of <i>X</i> has any non-zero elements</li>
<li>
<i>dim&thinsp;=&thinsp;1</i>, return a column vector (of type <a href="#Col">ucolvec</a> or <a href="#Mat">umat</a>),
with each element (0 or 1) indicating whether the corresponding row of <i>X</i> has any non-zero elements</li>
</ul>
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Relational operators can be used instead of <i>V</i> or <i>X</i>, eg. <i>A&thinsp;&gt;&thinsp;0.9</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec V(10,   fill::randu);
mat X(5, 5, fill::randu);


// status1 will be set to true if vector V has any non-zero elements
bool status1 = any(V);

// status2 will be set to true if vector V has any elements greater than 0.5
bool status2 = any(V &gt; 0.5);

// status3 will be set to true if matrix X has any elements greater than 0.6;
// note the use of vectorise()
bool status3 = any(vectorise(X) &gt; 0.6);

// generate a row vector indicating which columns of X have elements greater than 0.7
umat A = any(X &gt; 0.7);

</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#all">all()</a></li>
<li><a href="#approx_equal">approx_equal()</a></li>
<li><a href="#find">find()</a></li>
<li><a href="#conv_to">conv_to()</a> (convert between matrix/vector types)</li>
<li><a href="#vectorise">vectorise()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="approx_equal"></a>
<b>approx_equal( A, B, method, tol )</b>
<br><b>approx_equal( A, B, method, abs_tol, rel_tol )</b>
<ul>
<li>
Return <i>true</i> if all corresponding elements in <i>A</i> and <i>B</i> are approximately equal
</li>
<br>
<li>
Return <i>false</i> if any of the corresponding elements in <i>A</i> and <i>B</i> are not approximately equal, or if <i>A</i> and <i>B</i> have different dimensions
</li>
<br>
<li>
The argument <i>method</i> controls how the approximate equality is determined; it is one of:
<ul>
<table>
<tbody>
<tr><td><code>"absdiff"</code></td><td>&nbsp;&mapsto;&nbsp;</td><td>scalars <i>x</i> and <i>y</i> are considered equal if <i>|x&thinsp;&minus;&thinsp;y|&thinsp;&thinsp;&le;&thinsp;&thinsp;tol</i></td></tr>
<tr><td><code>"reldiff"</code></td><td>&nbsp;&mapsto;&nbsp;</td><td>scalars <i>x</i> and <i>y</i> are considered equal if <i>|x&thinsp;&minus;&thinsp;y|&thinsp;/&thinsp;max(&thinsp;|x|,&thinsp;|y|&thinsp;)&thinsp;&thinsp;&le;&thinsp;&thinsp;tol</i></td></tr>
<tr><td><code>"both"</code></td><td>&nbsp;&mapsto;&nbsp;</td><td>scalars <i>x</i> and <i>y</i> are considered equal if <i>|x&thinsp;&minus;&thinsp;y|&thinsp;&thinsp;&le;&thinsp;&thinsp;abs_tol</i>&nbsp;<b>or</b>&nbsp;<i>|x&thinsp;&minus;&thinsp;y|&thinsp;/&thinsp;max(&thinsp;|x|,&thinsp;|y|&thinsp;)&thinsp;&thinsp;&le;&thinsp;&thinsp;rel_tol</i></td></tr>
</tbody>
</table>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);
mat B = A + 0.001;

bool same1 = approx_equal(A, B, "absdiff", 0.002);


mat C = 1000 * randu&lt;mat&gt;(5,5);
mat D = C + 1;

bool same2 = approx_equal(C, D, "reldiff", 0.1);

bool same3 = approx_equal(C, D, "both", 2, 0.1);
</pre>
</ul>
</li>
<li>
See also:
<ul>
<li><a href="#all">all()</a></li>
<li><a href="#any">any()</a></li>
<li><a href="#find">find()</a></li>
<li><a href="#is_zero">.is_zero()</a></li>
<li><a href="#operators">relational operators</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="arg"></a>
<b>arg( X )</b>
<ul>
<li>
Obtain the phase angle (in radians) of each element
</li>
<br>
<li>
Usage for non-complex X:
<ul>
<li>Y = arg(X)</li>
<li>X and Y must have the same matrix type or cube type, such as <i>mat</i> or <i>cube</i></li>
<li>non-complex elements are treated as complex elements with zero imaginary component
</li>
</ul>
</li>
<br>
<li>
Usage for complex X:
<ul>
<li><i>real_object_type</i> Y = arg(X)</li>
<li>The type of X must be a complex matrix or complex cube, such as <i>cx_mat</i> or <i>cx_cube</i></li>
<li>The type of Y must be the real counterpart to the type of X; if X has the type <i>cx_mat</i>, then the type of Y must be <i>mat</i>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
cx_mat A(5, 5, fill::randu);
   mat B = arg(A); 
</pre>
</ul>
</li>
<li>
See also:
<ul>
<li><a href="#abs">abs()</a></li>
<li><a href="#trig_fns">atan2()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Argument_(complex_analysis)">Argument (complex analysis) in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/ComplexArgument.html">Complex Argument in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="as_scalar"></a>
<b>as_scalar( expression )</b>
<ul>
<li>
Evaluate an expression that results in a 1x1 matrix,
followed by converting the 1x1 matrix to a pure scalar
</li>
<br>
<li>
Optimised expression evaluations are automatically used when a binary or trinary expression is given (ie. 2 or 3 terms)
</li>
<br>
<li>
Examples:
<ul>
<pre>
rowvec r(5, fill::randu);
colvec q(5, fill::randu);

mat X(5, 5, fill::randu);

// examples of expressions which have optimised implementations

double a = as_scalar(r*q);
double b = as_scalar(r*X*q);
double c = as_scalar(r*diagmat(X)*q);
double d = as_scalar(r*inv(diagmat(X))*q);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#as_col_row">.as_col()&nbsp;/&nbsp;.as_row()</a></li>
<li><a href="#as_dense">.as_dense()</a></li>
<li><a href="#vectorise">vectorise()</a></li>
<li><a href="#accu">accu()</a></li>
<li><a href="#trace">trace()</a></li>
<li><a href="#dot">dot()</a></li>
<li><a href="#norm">norm()</a></li>
<li><a href="#conv_to">conv_to()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="clamp"></a>
<b>clamp( X, min_val, max_val )</b>
<ul>
<li>
Create a copy of <i>X</i> with each element clamped to the [<i>min_val</i>,&thinsp;<i>max_val</i>] interval;
<br>any value lower than <i>min_val</i> will be set to <i>min_val</i>, and any value higher than <i>max_val</i> will be set to <i>max_val</i>
</li>
<br>
<li>
For objects with complex elements, the real and imaginary components are clamped separately
</li>
<br>
<li>
If <i>X</i> is a sparse matrix, clamping is applied only to the non-zero elements
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = clamp(A, 0.2,     0.8); 

mat C = clamp(A, A.min(), 0.8); 

mat D = clamp(A, 0.2, A.max()); 
</pre>
</ul>
</li>
<li>
See also:
<ul>
<li><a href="#clamp_member">.clamp()</a> (member function)</li>
<li><a href="#min_and_max_member">.min() &amp; .max()</a></li>
<li><a href="#clean">.clean()</a></li>
<li><a href="#replace">.replace()</a></li>
<li><a href="#find">find()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cond"></a>
<b>cond( A )</b>
<ul>
<li>Return the condition number of matrix <i>A</i> (the ratio of the largest singular value to the smallest)</li>
<br>
<li>Matrix <i>A</i> is well-conditioned when the condition number is close to 1</li>
<br>
<li>Matrix <i>A</i> is ill-conditioned (poorly conditioned) when the condition number is large</li>
<br>
<li>The computation is based on singular value decomposition</li>
<br>
<li><b>Caveat:</b> calculating the approximate reciprocal condition number via <a href="#rcond">rcond()</a> is considerably more efficient</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

double c = cond(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#rcond">rcond()</a></li>
<li><a href="#rank">rank()</a></li>
<li><a href="#inv">inv()</a></li>
<li><a href="#svd">svd()</a></li>
<li><a href="https://mathworld.wolfram.com/ConditionNumber.html">condition number in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Condition_number">condition number in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="conj"></a>
<b>conj( X )</b>
<ul>
<li>
Obtain the complex conjugate of each element in a complex matrix or cube
</li>
<br>
<li>
Examples:
<ul>
<pre>
cx_mat X(5, 5, fill::randu);
cx_mat Y = conj(X);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#abs">abs()</a></li>
<li><a href="#imag_real">imag() / real()</a></li>
<li><a href="#trans">trans()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="conv_to"></a>
<b>
conv_to&lt; <i>type</i> &gt;::from( X )
</b>
<ul>
<li>
Convert (cast) from one matrix type to another (eg. <i>mat</i> to <i>imat</i>), or one cube type to another (eg. <i>cube</i> to <i>icube</i>)
</li>
<br>
<li>
Conversion between <i>std::vector</i> and Armadillo matrices/vectors is also possible
</li>
<br>
<li>
Conversion of a <i>mat</i> object into <i>colvec</i>, <i>rowvec</i> or <i>std::vector</i> is possible if the object can be interpreted as a vector
</li>
<br>
<li>
<b>Caveat:</b> to convert an expression that results in a 1x1 matrix to a pure scalar value, use <a href="#as_scalar">as_scalar()</a>
</li>
<br>
<li>
Examples:
<ul>
<pre>
 mat A(5, 5, fill::randu);
fmat B = conv_to&lt;fmat&gt;::from(A);

typedef std::vector&lt;double&gt; stdvec;

stdvec x(3);
x[0] = 0.0; x[1] = 1.0;  x[2] = 2.0;

colvec y = conv_to&lt; colvec &gt;::from(x);
stdvec z = conv_to&lt; stdvec &gt;::from(y); 
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#as_dense">.as_dense()</a></li>
<li><a href="#imag_real">imag() / real()</a></li>
<li><a href="#adv_constructors_mat">advanced constructors (matrices)</a></li>
<li><a href="#adv_constructors_cube">advanced constructors (cubes)</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cross"></a>
<b>cross( A, B )</b>
<ul>
<li>
Calculate the cross product between A and B, under the assumption that A and B are 3 dimensional vectors
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec a(3, fill::randu);
vec b(3, fill::randu);

vec c = cross(a,b);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#dot">dot()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cross_product">Cross product in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/CrossProduct.html">Cross product in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cumsum"></a>
<b>cumsum( V )</b>
<br><b>cumsum( X )</b>
<br><b>cumsum( X, dim )</b>
<ul>
<li>
For vector <i>V</i>, return a vector of the same orientation, containing the cumulative sum of elements
</li>
<br>
<li>
For matrix <i>X</i>, return a matrix containing the cumulative sum of elements in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);
mat B = cumsum(A);
mat C = cumsum(A, 1);

vec x(10, fill::randu);
vec y = cumsum(x);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#cumprod">cumprod()</a></li>
<li><a href="#accu">accu()</a></li>
<li><a href="#sum">sum()</a></li>
<li><a href="#diff">diff()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="cumprod"></a>
<b>cumprod( V )</b>
<br><b>cumprod( X )</b>
<br><b>cumprod( X, dim )</b>
<ul>
<li>
For vector <i>V</i>, return a vector of the same orientation, containing the cumulative product of elements
</li>
<br>
<li>
For matrix <i>X</i>, return a matrix containing the cumulative product of elements in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);
mat B = cumprod(A);
mat C = cumprod(A, 1);

vec x(10, fill::randu);
vec y = cumprod(x);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#cumsum">cumsum()</a></li>
<li><a href="#prod">prod()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="det"></a>
<table>
<tbody>
<tr><td><b>val = det( A )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;1)</td></tr>
<tr><td><b>det( val, A )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;2)</td></tr>
</tbody>
</table>
<ul>
<li>Calculate the determinant of square matrix <i>A</i>, based on LU decomposition</li>
<br>
<li>form 1: return the determinant</li>
<br>
<li>form 2: store the calculated determinant in <i>val</i> and return a bool indicating success</li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the calculation fails:
<ul>
<li><i>val = det(A)</i> throws a <i>std::runtime_error</i> exception</li>
<li><i>det(val,A)</i> returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li><b>Caveat:</b> <a href="#log_det">log_det()</a> is preferred, as it's less likely to suffer from numerical underflows/overflows</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

double val1 = det(A);         // form 1

double val2;
bool success = det(val2, A);  // form 2
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#log_det">log_det()</a></li>
<li><a href="#rcond">rcond()</a></li>
<li><a href="https://mathworld.wolfram.com/Determinant.html">determinant in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Determinant">determinant in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="diagmat"></a>
<b>diagmat( V )</b>
<br><b>diagmat( V, k )</b>
<br>
<br><b>diagmat( X )</b>
<br><b>diagmat( X, k )</b>
<ul>
<li>
Generate a diagonal matrix from vector <i>V</i> or matrix <i>X</i>
</li>
<br>
<li>
Given vector <i>V</i>:
<ul>
<li>generate a square matrix with the <i>k</i>-th diagonal containing a copy of the vector; all other elements are set to zero</li>
</ul>
</li>
<br>
<li>
Given matrix <i>X</i>:
<ul>
<li>generate a matrix with the <i>k</i>-th diagonal containing a copy of the <i>k</i>-th diagonal of <i>X</i>; all other elements are set to zero</li>
<li>if <i>X</i> is an expression, the evaluation of the expression aims to calculate only the diagonal elements</li>
</ul>
</li>
<br>
<li>The argument <i>k</i> is optional; by default <i>k&thinsp;=&thinsp;0</i></li>
<br>
<li>
The argument <i>k</i> specifies the diagonal to use:
<ul>
<li><i>k&thinsp;=&thinsp;0</i> indicates the main diagonal (default setting)</li>
<li><i>k&thinsp;&lt;&thinsp;0</i> indicates the <i>k</i>-th sub-diagonal (below main diagonal, towards bottom-left corner)</li>
<li><i>k&thinsp;&gt;&thinsp;0</i> indicates the <i>k</i>-th super-diagonal (above main diagonal, towards top-right corner)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);
mat B = diagmat(A);
mat C = diagmat(A,1);

vec v(5, fill::randu);
mat D = diagmat(v);
mat E = diagmat(v,1);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#diag">.diag()</a></li>
<li><a href="#is_diagmat">.is_diagmat()</a></li>
<li><a href="#diagvec">diagvec()</a></li>
<li><a href="#diags_spdiags">diags() / spdiags()</a></li>
<li><a href="#trace">trace()</a></li>
<li><a href="#trimat">trimatu() / trimatl()</a></li>
<li><a href="#symmat">symmatu() / symmatl()</a></li>
<li><a href="#reshape">reshape()</a></li>
<li><a href="#vectorise">vectorise()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Diagonal_matrix">diagonal matrix in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="diagvec"></a>
<b>diagvec( X )</b>
<br><b>diagvec( X, k )</b>
<ul>
<li>
Extract the <i>k</i>-th diagonal from matrix <i>X</i>
</li>
<br>
<li>The argument <i>k</i> is optional; by default <i>k&thinsp;=&thinsp;0</i></li>
<br>
<li>
The argument <i>k</i> specifies the diagonal to extract:
<ul>
<li><i>k&thinsp;=&thinsp;0</i> indicates the main diagonal (default setting)</li>
<li><i>k&thinsp;&lt;&thinsp;0</i> indicates the <i>k</i>-th sub-diagonal (below main diagonal, towards bottom-left corner)</li>
<li><i>k&thinsp;&gt;&thinsp;0</i> indicates the <i>k</i>-th super-diagonal (above main diagonal, towards top-right corner)</li>
</ul>
</li>
<br>
<li>
The extracted diagonal is interpreted as a column vector
</li>
<br>
<li>
If <i>X</i> is an expression, the evaluation of the expression aims to calculate only the diagonal elements
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

vec d = diagvec(A);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#diag">.diag()</a></li>
<li><a href="#diagmat">diagmat()</a></li>
<li><a href="#trace">trace()</a></li>
<li><a href="#vectorise">vectorise()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="diags_spdiags"></a>
<table>
<tbody>
<tr><td style="text-align: right;"><b>diags( V, D, n_rows, n_cols )</b></td></tr>
<tr><td style="text-align: right;"><b>spdiags( V, D, n_rows, n_cols )</b></td></tr>
</tbody>
</table>
<ul>
<li>
Generate a matrix with diagonals specified by vector <i>D</i> copied from corresponding column vectors in matrix <i>V</i>
</li>
<br>
<li>
Function <i>diags()</i> generates a dense matrix, while function <i>spdiags()</i> generates a sparse matrix; in both cases the generated matrix has the same element type as matrix <i>V</i>
</li>
<br>
<li>
Given vector <i>D</i> must be a vector of type <a href="#Col">ivec</a> or <a href="#Row">irowvec</a>
</li>
<br>
<li>
The number of columns in given matrix <i>V</i> must match the number of elements in vector <i>D</i>
</li>
<br>
<li>
Each element in vector <i>D</i> specifies diagonal <i>k</i>, where:
<ul>
<li><i>k&thinsp;=&thinsp;0</i> indicates the main diagonal</li>
<li><i>k&thinsp;&lt;&thinsp;0</i> indicates the <i>k</i>-th sub-diagonal (below main diagonal, towards bottom-left corner)</li>
<li><i>k&thinsp;&gt;&thinsp;0</i> indicates the <i>k</i>-th super-diagonal (above main diagonal, towards top-right corner)</li>
</ul>
</li>
<br>
<li>
For <i>k&thinsp;&lt;&thinsp;0</i>, vectors from matrix <i>V</i> are truncated at the end
</li>
<br>
<li>
For <i>k&thinsp;&gt;&thinsp;0</i>, vectors from matrix <i>V</i> are truncated from the start
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat  V(10, 3, fill::randu);

ivec D = {-1, 0, +1};

mat X = diags(V, D, 10, 10);

sp_mat Y = spdiags(V, D, 10, 10);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#diag">.diag()</a></li>
<li><a href="#diagmat">diagmat()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Band_matrix">band matrix in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="diff"></a>
<b>diff( V )</b>
<br><b>diff( V, k )</b>
<br>
<br><b>diff( X )</b>
<br><b>diff( X, k )</b>
<br><b>diff( X, k, dim )</b>
<ul>
<li>
For vector <i>V</i>, return a vector of the same orientation, containing the differences between consecutive elements
</li>
<br>
<li>
For matrix <i>X</i>, return a matrix containing the differences between consecutive elements in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
The optional argument <i>k</i> indicates that the differences are calculated recursively <i>k</i> times; by default <i>k&thinsp;=&thinsp;1</i> is used
</li>
<br>
<li>
The resulting number of differences is <i>n&thinsp;&minus;&thinsp;k</i>, where <i>n</i> is the number of elements; if <i>n&thinsp;&le;&thinsp;k</i>, the number of differences is zero (ie. an empty vector/matrix is returned)
</li>
<br>
<li>
The argument <i>dim</i> is optional; by default <i>dim&thinsp;=&thinsp;0</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec a = linspace&lt;vec&gt;(1,10,10);

vec b = diff(a);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#trapz">trapz()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Numerical_differentiation">numerical differentiation in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/NumericalDifferentiation.html">numerical differentiation in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="dot"></a>
<b>dot( A, B )</b>
<br><b>cdot( A, B )</b>
<br><b>norm_dot( A, B )</b>
<ul>
<li>
<i>dot(A,B)</i>: dot product of <i>A</i> and <i>B</i>, treating <i>A</i> and <i>B</i> as vectors
</li>
<br>
<li>
<i>cdot(A,B)</i>: as per <i>dot(A,B)</i>, but the complex conjugate of <i>A</i> is used
</li>
<br>
<li>
<i>norm_dot(A,B)</i>: normalised dot product; equivalent to <i>dot(A,B)&thinsp;&thinsp;/&thinsp;&thinsp;(&thinsp;&#8741;A&#8741;&middot;&#8741;B&#8741;&thinsp;)</i>
</li>
<br>
<li>
<b>Caveat:</b> <a href="#norm">norm()</a> is more robust for calculating the norm, as it handles underflows and overflows
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec a(10, fill::randu);
vec b(10, fill::randu);

double x = dot(a,b);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#norm">norm()</a></li>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#cross">cross()</a></li>
<li><a href="#conj">conj()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="eps"></a>
<b>eps( X )</b>
<ul>
<li>
Obtain the positive distance of the absolute value of each element of <i>X</i> to the next largest representable floating point number
</li>
<br>
<li>
<i>X</i> can be a scalar (eg. <i>double</i>), vector or matrix
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(4, 5, fill::randu);
mat B = eps(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#constants">datum::eps</a></li>
<li><a href="https://mathworld.wolfram.com/Floating-PointArithmetic.html">Floating-Point Arithmetic in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE Standard for Floating-Point Arithmetic in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="expmat"></a>
<b>B = expmat( A )</b>
<br><b>expmat( B, A )</b>
<ul>
<li>Matrix exponential of general square matrix <i>A</i></li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the matrix exponential cannot be found:
<ul>
<li><i>B = expmat(A)</i> resets <i>B</i> and throws a <i>std::runtime_error</i> exception</li>
<li><i>expmat(B,A)</i> resets <i>B</i> and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li>
<b>Caveats:</b>
<ul>
<li>the matrix exponential operation is generally <b>not</b> the same as applying the <a href="#misc_fns">exp()</a> function to each element</li>
<li>if matrix <i>A</i> is symmetric, <a href="#expmat_sym">expmat_sym()</a> is faster</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = expmat(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#expmat_sym">expmat_sym()</a></li>
<li><a href="#logmat">logmat()</a></li>
<li><a href="#sqrtmat">sqrtmat()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/MatrixExponential.html">matrix exponential in MathWorld</a></li>
<li><a href="http://doi.org/10.1137/S00361445024180">Nineteen Dubious Ways to Compute the Exponential of a Matrix, Twenty-Five Years Later</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="expmat_sym"></a>
<b>B = expmat_sym( A )</b>
<br><b>expmat_sym( B, A )</b>
<ul>
<li>Matrix exponential of symmetric/hermitian matrix <i>A</i></li>
<br>
<li>The computation is based on eigen decomposition</li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the matrix exponential cannot be found:
<ul>
<li><i>B = expmat_sym(A)</i> resets <i>B</i> and throws a <i>std::runtime_error</i> exception</li>
<li><i>expmat_sym(B,A)</i> resets <i>B</i> and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<!--
<br>
<li><b>Caveat:</b> there is no explicit check whether <i>A</i> is symmetric/hermitian</li>
-->
<br>
<li><b>Caveat:</b> the matrix exponential operation is generally <b>not</b> the same as applying the <a href="#misc_fns">exp()</a> function to each element</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = A*A.t();   // make symmetric matrix

mat C = expmat_sym(B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#expmat">expmat()</a></li>
<li><a href="#logmat_sympd">logmat_sympd()</a></li>
<li><a href="#sqrtmat_sympd">sqrtmat_sympd()</a></li>
<li><a href="#is_symmetric">.is_symmetric()</a></li>
<li><a href="#is_hermitian">.is_hermitian()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/MatrixExponential.html">matrix exponential in MathWorld</a></li>
<li><a href="http://doi.org/10.1137/S00361445024180">Nineteen Dubious Ways to Compute the Exponential of a Matrix, Twenty-Five Years Later</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="find"></a>
<b>find( X )</b>
<br><b>find( X, k )</b>
<br><b>find( X, k, s )</b>
<ul>
<li>Return a column vector containing the indices of elements of <i>X</i> that are non-zero or satisfy a relational condition</li>
<br>
<li>The output vector must have the type <a href="#Col">uvec</a>
(ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)
</li>
<br>
<li>
<i>X</i> is interpreted as a vector, with column-by-column ordering of the elements of <i>X</i>
</li>
<br>
<li>Relational operators can be used instead of <i>X</i>, eg. <i>A&thinsp;&gt;&thinsp;0.5</i>
</li>
<br>
<li>If <i>k&thinsp;=&thinsp;0</i> (default), return the indices of all non-zero elements, otherwise return at most <i>k</i> of their indices</li>
<br>
<li>If <i>s&thinsp;=&thinsp;"first"</i> (default), return at most the first <i>k</i> indices of the non-zero elements
</li>
<br>
<li>If <i>s&thinsp;=&thinsp;"last"</i>, return at most the last <i>k</i> indices of the non-zero elements
</li>
<br>
<li>
<b>Caveats:</b>
<ul>
<li>to clamp values to an interval, <a href="#clamp">clamp()</a> is more efficient</li>
<li>to replace a specific value, <a href="#replace">.replace()</a> is more efficient</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);
mat B(5, 5, fill::randu);

uvec q1 = find(A &gt; B);
uvec q2 = find(A &gt; 0.5);
uvec q3 = find(A &gt; 0.5, 3, "last");

// change elements of A greater than 0.5 to 1
A.elem( find(A &gt; 0.5) ).ones();
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#all">all()</a></li>
<li><a href="#any">any()</a></li>
<li><a href="#clamp">clamp()</a></li>
<li><a href="#transform">.transform()</a></li>
<li><a href="#find_finite">find_finite()</a></li>
<li><a href="#find_nonfinite">find_nonfinite()</a></li>
<li><a href="#find_nan">find_nan()</a></li>
<li><a href="#find_unique">find_unique()</a></li>
<li><a href="#nonzeros">nonzeros()</a></li>
<li><a href="#unique">unique()</a></li>
<li><a href="#sort_index">sort_index()</a></li>
<li><a href="#ind2sub">ind2sub()</a></li>
<li><a href="#index_min_and_index_max_member">.index_min() &amp; .index_max()</a></li>
<li><a href="#trimat_ind">trimatu_ind() / trimatl_ind()</a></li>
<li><a href="#submat">submatrix views</a></li>
<li><a href="#subcube">subcube views</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="find_finite"></a>
<b>find_finite( X )</b>
<ul>
<li>Return a column vector containing the indices of elements of <i>X</i> that are finite (ie. not &plusmn;Inf and not NaN)</li>
<br>
<li>The output vector must have the type <a href="#Col">uvec</a>
(ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)
</li>
<br>
<li>
<i>X</i> is interpreted as a vector, with column-by-column ordering of the elements of <i>X</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

A(1,1) = datum::inf;

// accumulate only finite elements
double val = accu( A.elem( find_finite(A) ) );
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#find">find()</a></li>
<li><a href="#find_nonfinite">find_nonfinite()</a></li>
<li><a href="#find_nan">find_nan()</a></li>
<li><a href="#is_finite">.is_finite()</a></li>
<li><a href="#replace">.replace()</a></li>
<li><a href="#has_inf">.has_inf()</a></li>
<li><a href="#has_nan">.has_nan()</a></li>
<li><a href="#submat">submatrix views</a></li>
<li><a href="#constants">constants (pi, nan, inf, ...)</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="find_nonfinite"></a>
<b>find_nonfinite( X )</b>
<ul>
<li>Return a column vector containing the indices of elements of <i>X</i> that are non-finite (ie. &plusmn;Inf or NaN)</li>
<br>
<li>The output vector must have the type <a href="#Col">uvec</a>
(ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)
</li>
<br>
<li>
<i>X</i> is interpreted as a vector, with column-by-column ordering of the elements of <i>X</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

A(1,1) = datum::inf;
A(2,2) = datum::nan;

// change non-finite elements to zero
A.elem( find_nonfinite(A) ).zeros();
</pre>
</ul>
</li>
<br>
<li>
<b>Caveat:</b> to replace instances of a specific non-finite value (eg. NaN or Inf),
it is more efficient to use <a href="#replace">.replace()</a>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#find">find()</a></li>
<li><a href="#find_finite">find_finite()</a></li>
<li><a href="#find_nan">find_nan()</a></li>
<li><a href="#is_finite">.is_finite()</a></li>
<li><a href="#replace">.replace()</a></li>
<li><a href="#has_inf">.has_inf()</a></li>
<li><a href="#has_nan">.has_nan()</a></li>
<li><a href="#submat">submatrix views</a></li>
<li><a href="#constants">constants (pi, nan, inf, ...)</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="find_nan"></a>
<b>find_nan( X )</b>
<ul>
<li>Return a column vector containing the indices of elements of <i>X</i> that are NaN (not-a-number)</li>
<br>
<li>The output vector must have the type <a href="#Col">uvec</a>
(ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)
</li>
<br>
<li>
<i>X</i> is interpreted as a vector, with column-by-column ordering of the elements of <i>X</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

A(2,3) = datum::nan;

uvec indices = find_nan(A);
</pre>
</ul>
</li>
<br>
<li>
<b>Caveat:</b> to replace instances of NaN values,
it is more efficient to use <a href="#replace">.replace()</a>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#find">find()</a></li>
<li><a href="#find_finite">find_finite()</a></li>
<li><a href="#find_nonfinite">find_nonfinite()</a></li>
<li><a href="#replace">.replace()</a></li>
<li><a href="#has_nan">.has_nan()</a></li>
<li><a href="#constants">constants (pi, nan, inf, ...)</a></li>
<li><a href="https://en.wikipedia.org/wiki/NaN">NaN</a> in Wikipedia</li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="find_unique"></a>
<b>find_unique( X )</b>
<br><b>find_unique( X, ascending_indices )</b>
<ul>
<li>Return a column vector containing the indices of unique elements of <i>X</i></li>
<br>
<li>The output vector must have the type <a href="#Col">uvec</a>
(ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)
</li>
<br>
<li>
<i>X</i> is interpreted as a vector, with column-by-column ordering of the elements of <i>X</i>
</li>
<br>
<li>The <i>ascending_indices</i> argument is optional; it is one of:
<ul>
<table>
<tbody>
<tr><td style="text-align: right;"><code>true</code></td><td>&nbsp;=&nbsp;</td><td>the returned indices are sorted to be ascending (<b>default setting</b>)</td></tr>
<tr><td style="text-align: right;"><code>false</code></td><td>&nbsp;=&nbsp;</td><td>the returned indices are in arbitrary order (faster operation)</td></tr>
</tbody>
</table>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = { { 2, 2, 4 }, 
          { 4, 6, 6 } };

uvec indices = find_unique(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#find">find()</a></li>
<li><a href="#unique">unique()</a></li>
<li><a href="#intersect">intersect()</a></li>
<li><a href="#submat">submatrix views</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="flip"></a>
<b>fliplr( X )</b>
<br><b>flipud( X )</b>
<ul>
<li>
<i>fliplr():</i> generate a copy of matrix <i>X</i>, with the order of the columns reversed
</li>
<br>
<li>
<i>flipud():</i> generate a copy of matrix <i>X</i>, with the order of the rows reversed
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = fliplr(A);
mat C = flipud(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#reverse">reverse()</a></li>
<li><a href="#shift">shift()</a></li>
<li><a href="#swap_rows">.swap_rows() &amp; .swap_cols()</a></li>
<li><a href="#t_st_members">.t()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="imag_real"></a>
<b>imag( X )</b>
<br><b>real( X )</b>
<ul>
<li>
Extract the imaginary/real part of a complex matrix or cube
</li>
<br>
<li>
Examples:
<ul>
<pre>
cx_mat C(5, 5, fill::randu);

mat    A = imag(C);
mat    B = real(C);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#set_imag">.set_imag()&nbsp;/&nbsp;.set_real()</a></li>
<li><a href="#abs">abs()</a></li>
<li><a href="#conj">conj()</a></li>
<li><a href="#conv_to">conv_to()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="ind2sub"></a>
<table>
<tbody>
<tr><td>uvec</td><td>&nbsp;sub&nbsp;=&nbsp;<b>ind2sub(&nbsp;size(</b>X<b>),</b>&nbsp;index&nbsp;<b>)</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;1)</td></tr>
<tr><td>umat</td><td>&nbsp;sub&nbsp;=&nbsp;<b>ind2sub(&nbsp;size(</b>X<b>),</b>&nbsp;vector_of_indices&nbsp;<b>)</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;2)</td></tr>
</tbody>
</table>
<ul>
<li>
Convert a linear index, or a vector of indices, to subscript notation
</li>
<br>
<li>
The argument <i><b>size(</b>X<b>)</b></i> can be replaced with <i><b>size(</b>n_rows<b>,</b>&thinsp;n_cols<b>)</b></i> or <i><b>size(</b>n_rows<b>,</b>&thinsp;n_cols<b>,</b>&thinsp;n_slices<b>)</b></i>
</li>
<br>
<li>
If an index is out of range, a <i>std::logic_error</i> exception is thrown
</li>
<br>
<li>
When only one index is given (form&nbsp;1), the subscripts are returned in a vector of type <a href="#Col">uvec</a>
</li>
<br>
<li>
When a vector of indices (of type <a href="#Col">uvec</a>) is given (form&nbsp;2), the corresponding subscripts are returned in each column of an <i>m&nbsp;x&nbsp;n</i> matrix of type <a href="#Mat">umat</a>;
<i>m=2</i> for matrix subscripts, while <i>m=3</i> for cube subscripts
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat M(4, 5, fill::randu);

uvec s = ind2sub( size(M), 6 );

cout &lt;&lt; "row: " &lt;&lt; s(0) &lt;&lt; endl;
cout &lt;&lt; "col: " &lt;&lt; s(1) &lt;&lt; endl;


uvec indices = find(M &gt; 0.5);
umat t       = ind2sub( size(M), indices );


cube Q(2,3,4);

uvec u = ind2sub( size(Q), 8 );

cout &lt;&lt; "row:   " &lt;&lt; u(0) &lt;&lt; endl;
cout &lt;&lt; "col:   " &lt;&lt; u(1) &lt;&lt; endl;
cout &lt;&lt; "slice: " &lt;&lt; u(2) &lt;&lt; endl;
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#size">size()</a></li>
<li><a href="#sub2ind">sub2ind()</a></li>
<li><a href="#element_access">element access</a></li>
<li><a href="#find">find()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="index_min_and_index_max_standalone"></a>
<table>
<tbody>
<tr>
<td>
<b>index_min( V )</b>
<br><b>index_min( M )</b>
<br><b>index_min( M, dim )</b>
<br><b>index_min( Q )</b>
<br><b>index_min( Q, dim )</b>
</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>
<b>index_max( V )</b>
<br><b>index_max( M )</b>
<br><b>index_max( M, dim )</b>
<br><b>index_max( Q )</b>
<br><b>index_max( Q, dim )</b>
</td>
</tr>
</tbody>
</table>
<ul>
<li>
For vector <i>V</i>, return the linear index of the extremum value; the returned index is of type <a href="#uword">uword</a>
</li>
<br>
<li>
For matrix <i>M</i> and:
<ul>
<li>
<i>dim&thinsp;=&thinsp;0</i>, return a row vector (of type <a href="#Row">urowvec</a> or <a href="#Mat">umat</a>), 
with each column containing the index of the extremum value in the corresponding column of <i>M</i>
</li>
<li>
<i>dim&thinsp;=&thinsp;1</i>, return a column vector (of type <a href="#Col">uvec</a> or <a href="#Mat">umat</a>),
with each row containing the index of the extremum value in the corresponding row of <i>M</i>
</li>
</ul>
</li>
<br>
<li>
For cube <i>Q</i>, return a cube (of type <a href="#Cube">ucube</a>) containing the indices of extremum values of elements along dimension <i>dim</i>, where <i>dim</i>&thinsp;&isin;&thinsp;{&thinsp;0,&thinsp;1,&thinsp;2&thinsp;}
</li>
<br>
<li>
For each column, row, or slice, the index starts at zero
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
For objects with complex numbers, absolute values are used for comparison
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec v(10, fill::randu);

uword i = index_max(v);
double max_val_in_v = v(i);


mat M(5, 6, fill::randu);

urowvec ii = index_max(M);
ucolvec jj = index_max(M,1);

double max_val_in_col_2 = M( ii(2), 2 );

double max_val_in_row_4 = M( 4, jj(4) );
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#min_and_max">min() &amp; max()</a></li>
<li><a href="#index_min_and_index_max_member">.index_min() &amp; .index_max()</a> (member functions)</li>
<li><a href="#sort_index">sort_index()</a></li>
<li><a href="#find">find()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="inplace_trans"></a>
<b>inplace_trans( X )
<br>inplace_trans( X, method )
<br>
<br>inplace_strans( X )
<br>inplace_strans( X, method )
</b>
<ul>
<li>
In-place / in-situ transpose of matrix <i>X</i>
</li>
<br>
<li>
For real (non-complex) matrix:
<ul>
<li><i>inplace_trans()</i> performs a normal transpose</li>
<li><i>inplace_strans()</i> not applicable</li>
</ul>
</li>
<br>
<li>
For complex matrix:
<ul>
<li><i>inplace_trans()</i> performs a Hermitian transpose (ie. the conjugate of the elements is taken during the transpose)</li>
<li><i>inplace_strans()</i> provides a transposed copy without taking the conjugate of the elements</li>
</ul>
</li>
<br>
<li>
The argument <i>method</i> is optional
</li>
<br>
<li>
By default, a greedy transposition algorithm is used; a low-memory algorithm can be used instead by explicitly setting <i>method</i> to <code>"lowmem"</code>
</li>
<br>
<li>
The low-memory algorithm is considerably slower than the greedy algorithm;
using the low-memory algorithm is only recommended for cases where <i>X</i> takes up more than half of available memory (ie. very large <i>X</i>)
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X(4,     5,     fill::randu);
mat Y(20000, 30000, fill::randu);

inplace_trans(X);            // use greedy algorithm by default

inplace_trans(Y, "lowmem");  // use low-memory (and slow) algorithm
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#t_st_members">.t()</a></li>
<li><a href="#trans">trans()</a></li>
<li><a href="https://en.wikipedia.org/wiki/In-place_matrix_transposition">inplace matrix transpose in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="intersect"></a>
<table>
<tbody>
<tr><td><b>C = intersect( A, B )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;1)</td></tr>
<tr><td><b>intersect( C, iA, iB, A, B )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;2)</td></tr>
</tbody>
</table>
<ul>
<li>
For form 1:
<ul>
<li>return the unique elements common to both <i>A</i> and <i>B</i>, sorted in ascending order</li>
</ul>
</li>
<br>
<li>
For form 2:
<ul>
<li>store in <i>C</i> the unique elements common to both <i>A</i> and <i>B</i>, sorted in ascending order</li>
<li>store in <i>iA</i> and <i>iB</i> the indices of the unique elements, such that <i>C = A.elem(iA)</i> and <i>C = B.elem(iB)</i></li>
<li><i>iA</i> and <i>iB</i> must have the type <a href="#Col">uvec</a> (ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)</li>
</ul>
</li>
<br>
<li>
<i>C</i> is a column vector if either <i>A</i> or <i>B</i> is a matrix or column vector;
<i>C</i> is a row vector if both <i>A</i> and <i>B</i> are row vectors
</li>
<br>
<li>
For matrices and vectors with complex numbers, ordering is via absolute values 
</li>
<br>
<li>
Examples:
<ul>
<pre>
ivec A = regspace&lt;ivec&gt;(4, 1);  // 4, 3, 2, 1
ivec B = regspace&lt;ivec&gt;(3, 6);  // 3, 4, 5, 6

ivec C = intersect(A,B);       // 3, 4

ivec CC;
uvec iA;
uvec iB;

intersect(CC, iA, iB, A, B);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#unique">unique()</a></li>
<li><a href="#find_unique">find_unique()</a></li>
<li><a href="#submat">submatrix views</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="join"></a>
<table>
<tbody>
<tr>
<td>
<b>join_rows( A, B )</b>
<br><b>join_rows( A, B, C )</b>
<br><b>join_rows( A, B, C, D )</b>
<br>&nbsp;
<br><b>join_cols( A, B )</b>
<br><b>join_cols( A, B, C )</b>
<br><b>join_cols( A, B, C, D )</b>
</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>
<b>join_horiz( A, B )</b>
<br><b>join_horiz( A, B, C )</b>
<br><b>join_horiz( A, B, C, D )</b>
<br>&nbsp;
<br><b>join_vert( A, B )</b>
<br><b>join_vert( A, B, C )</b>
<br><b>join_vert( A, B, C, D )</b>
</td>
</tr>
</tbody>
</table>
<ul>
<li>
<i>join_rows()</i> and <i>join_horiz()</i>: horizontal concatenation;
join the corresponding rows of the given matrices;
the given matrices must have the same number of rows
</li>
<br>
<li>
<i>join_cols()</i> and <i>join_vert()</i>: vertical concatenation;
join the corresponding columns of the given matrices;
the given matrices must have the same number of columns
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(4, 5, fill::randu);
mat B(4, 6, fill::randu);
mat C(6, 5, fill::randu);

mat AB = join_rows(A,B);
mat AC = join_cols(A,C);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#shed">.shed_rows&thinsp;/&thinsp;cols&thinsp;/&thinsp;slices</a></li>
<li><a href="#insert">.insert_rows&thinsp;/&thinsp;cols&thinsp;/&thinsp;slices</a></li>
<li><a href="#join_slices">join_slices()</a></li>
<li><a href="#submat">submatrix views</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="join_slices"></a>
<b>join_slices( cube C, cube D )</b>
<br><b>join_slices( mat  M, mat  N )</b>
<br>
<br><b>join_slices( mat  M, cube C )</b>
<br><b>join_slices( cube C, mat  M )</b>
<ul>
<li>
for two cubes <i>C</i> and <i>D</i>: join the slices of <i>C</i> with the slices of <i>D</i>;
cubes <i>C</i> and <i>D</i> must have the same number of rows and columns (ie. all slices must have the same size)
</li>
<br>
<li>
for two matrices <i>M</i> and <i>N</i>: treat <i>M</i> and <i>N</i> as cube slices and join them to form a cube with 2 slices;
matrices <i>M</i> and <i>N</i> must have the same number of rows and columns
</li>
<br>
<li>
for matrix <i>M</i> and cube <i>C</i>: treat <i>M</i> as a cube slice and join it with the slices of <i>C</i>;
matrix <i>M</i> and cube <i>C</i> must have the same number of rows and columns
</li>
<br>
<li>
Examples:
<ul>
<pre>
cube C(5, 10, 3, fill::randu);
cube D(5, 10, 4, fill::randu);

cube E = join_slices(C,D);

mat M(10, 20, fill::randu);
mat N(10, 20, fill::randu);

cube Q = join_slices(M,N);

cube R = join_slices(Q,M);

cube S = join_slices(M,Q);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#shed">.shed_rows&thinsp;/&thinsp;cols&thinsp;/&thinsp;slices</a></li>
<li><a href="#insert">.insert_rows&thinsp;/&thinsp;cols&thinsp;/&thinsp;slices</a></li>
<li><a href="#join">join_rows&thinsp;/&thinsp;cols</a></li>
<li><a href="#subcube">subcube views</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="kron"></a>
<b>kron( A, B )</b>

<ul>
<li>Kronecker tensor product</li>
<br>
<li>Given matrix <i>A</i> (with <i>n</i> rows and <i>p</i> columns) and matrix <i>B</i> (with <i>m</i> rows and <i>q</i> columns),
generate a matrix (with <i>nm</i> rows and <i>pq</i> columns) that denotes the tensor product of <i>A</i> and <i>B</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(4, 5, fill::randu);
mat B(5, 4, fill::randu);

mat K = kron(A,B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#repmat">repmat()</a></li>
<li><a href="#repelem">repelem()</a></li>
<li><a href="https://mathworld.wolfram.com/KroneckerProduct.html">Kronecker product in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="log_det"></a>
<table>
<tbody>
<tr><td><b>complex result = log_det( A )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;1)</td></tr>
<tr><td><b>log_det( val, sign, A )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;2)</td></tr>
</tbody>
</table>
<ul>
<li>Log determinant of square matrix <i>A</i>, based on LU decomposition</li>
<br>
<li>form 1: return the complex log determinant
<ul>
<li>
if matrix <i>A</i> is real and the determinant is positive:
<ul>
<li>the real part is the log determinant</li>
<li>the imaginary part is zero</li>
</ul>
</li>
<li>
if matrix <i>A</i> is real and the determinant is negative:
<ul>
<li>the real part is log abs(determinant)</li>
<li>the imaginary part is equal to <i><a href="#constants">datum::pi</a></i></li>
</ul>
</li>
</ul>
<br>
<li>form 2: store the calculated log determinant in <i>val</i> and <i>sign</i>, and return a bool indicating success;
<br>the determinant is equal to <i>exp(val)&thinsp;&middot;&thinsp;sign</i>
</li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the log determinant cannot be found:
<ul>
<li><i>result = log_det(A)</i> throws a <i>std::runtime_error</i> exception</li>
<li><i>log_det(val, sign, A)</i> returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

cx_double result = log_det(A);    // form 1

double val;
double sign;

bool ok = log_det(val, sign, A);  // form 2
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#log_det_sympd">log_det_sympd()</a></li>
<li><a href="#det">det()</a></li>
<li><a href="#rcond">rcond()</a></li>
<li><a href="#cx_double">cx_double</a></li>
<li><a href="https://mathworld.wolfram.com/Determinant.html">determinant in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Determinant">determinant in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="log_det_sympd"></a>
<table>
<tbody>
<tr><td><b>result = log_det_sympd( A )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;1)</td></tr>
<tr><td><b>log_det_sympd( result, A )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;2)</td></tr>
</tbody>
</table>
<ul>
<li>Log determinant of symmetric positive definite matrix <i>A</i></li>
<br>
<li>form 1: return the log determinant</li>
<br>
<li>form 2: store the calculated log determinant in <i>result</i> and return a bool indicating success</li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the log determinant cannot be found:
<ul>
<li><i>result = log_det_sympd(A)</i> throws a <i>std::runtime_error</i> exception</li>
<li><i>log_det_sympd(result, A)</i> returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = A.t() * A;  // make symmetric matrix

double result1 = log_det_sympd(B);           // form 1

double result2;
bool   success = log_det_sympd(result2, B);  // form 2
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#log_det">log_det()</a></li>
<li><a href="#rcond">rcond()</a></li>
<li><a href="https://mathworld.wolfram.com/Determinant.html">determinant in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Determinant">determinant in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="logmat"></a>
<b>B = logmat( A )</b>
<br><b>logmat( B, A )</b>
<ul>
<li>Complex matrix logarithm of general square matrix <i>A</i></li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the matrix logarithm cannot be found:
<ul>
<li><i>B = logmat(A)</i> resets <i>B</i> and throws a <i>std::runtime_error</i> exception</li>
<li><i>logmat(B,A)</i> resets <i>B</i> and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li><b>Caveats:</b>
<ul>
<li>the matrix logarithm operation is generally <b>not</b> the same as applying the <a href="#misc_fns">log()</a> function to each element</li>
<li>if matrix <i>A</i> is symmetric positive definite, <a href="#logmat_sympd">logmat_sympd()</a> is faster</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
   mat A(5, 5, fill::randu);

cx_mat B = logmat(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#logmat_sympd">logmat_sympd()</a></li>
<li><a href="#expmat">expmat()</a></li>
<li><a href="#sqrtmat">sqrtmat()</a></li>
<li><a href="#imag_real">real()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Logarithm_of_a_matrix">matrix logarithm in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="logmat_sympd"></a>
<b>B = logmat_sympd( A )</b>
<br><b>logmat_sympd( B, A )</b>
<ul>
<li>Matrix logarithm of symmetric/hermitian positive definite matrix <i>A</i></li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the matrix logarithm cannot be found:
<ul>
<li><i>B = logmat_sympd(A)</i> resets <i>B</i> and throws a <i>std::runtime_error</i> exception</li>
<li><i>logmat_sympd(B,A)</i> resets <i>B</i> and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<!--
<br>
<li><b>Caveat:</b> there is no explicit check whether <i>A</i> is symmetric/hermitian positive definite</li>
-->
<br>
<li><b>Caveat:</b> the matrix logarithm operation is generally <b>not</b> the same as applying the <a href="#misc_fns">log()</a> function to each element</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = A*A.t();   // make symmetric matrix

mat C = logmat_sympd(B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#logmat">logmat()</a></li>
<li><a href="#expmat_sym">expmat_sym()</a></li>
<li><a href="#sqrtmat_sympd">sqrtmat_sympd()</a></li>
<li><a href="#is_sympd">.is_sympd()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Logarithm_of_a_matrix">matrix logarithm in Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Positive-definite_matrix">positive definite matrix in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/PositiveDefiniteMatrix.html">positive definite matrix in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="min_and_max"></a>
<table>
<tbody>
<tr>
<td>
<b>min( V )</b>
<br><b>min( M )</b>
<br><b>min( M, dim )</b>
<br><b>min( Q )</b>
<br><b>min( Q, dim )</b>
<br><b>min( A, B )</b>
</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>
<b>max( V )</b>
<br><b>max( M )</b>
<br><b>max( M, dim )</b>
<br><b>max( Q )</b>
<br><b>max( Q, dim )</b>
<br><b>max( A, B )</b>
</td>
</tr>
</tbody>
</table>
<ul>
<li>
For vector <i>V</i>, return the extremum value
</li>
<br>
<li>
For matrix <i>M</i>, return the extremum value for each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
For cube <i>Q</i>, return the extremum values of elements along dimension <i>dim</i>, where <i>dim</i>&thinsp;&isin;&thinsp;{&thinsp;0,&thinsp;1,&thinsp;2&thinsp;}
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
For two matrices/cubes <i>A</i> and <i>B</i>, return a matrix/cube containing element-wise extremum values
</li>
<br>
<li>
For objects with complex numbers, absolute values are used for comparison
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec v(10, fill::randu);
double x = max(v);

mat M(10, 10, fill::randu);

rowvec a = max(M);
rowvec b = max(M,0); 
colvec c = max(M,1);

// element-wise maximum
mat X(5, 6, fill::randu);
mat Y(5, 6, fill::randu);
mat Z = arma::max(X,Y);  // use arma:: prefix to distinguish from std::max()
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#min_and_max_member">.min() &amp; .max()</a> (member functions)</li>
<li><a href="#index_min_and_index_max_standalone">index_min() &amp; index_max()</a>
<li><a href="#clamp">clamp()</a>
<li><a href="#stats_fns">statistics functions</a>
<li><a href="#running_stat">running_stat</a> - class for running statistics of scalars</li>
<li><a href="#running_stat_vec">running_stat_vec</a> - class for running statistics of vectors</li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="nonzeros"></a>
<b>nonzeros( X )</b>
<ul>
<li>
Return a column vector containing the non-zero <b>values</b> of <i>X</i>
</li>
<br>
<li>
<i>X</i> can be a sparse or dense matrix
</li>
<br>
<li>
<b>Caveats:</b>
<ul>
<li>
for dense matrices/vectors, 
to obtain the <b>number</b> of non-zero elements, 
the expression <code><a href="#accu">accu</a>(X != 0)</code> is more efficient
</li>
<li>
for sparse matrices,
to obtain the <b>number</b> of non-zero elements,
the <code><a href="#attributes">.n_nonzero</a></code> attribute is more efficient, eg. <code>X.n_nonzero</code>
</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
sp_mat A = sprandu&lt;sp_mat&gt;(100, 100, 0.1);
   vec a = nonzeros(A);

mat B(100, 100, fill::eye);
vec b = nonzeros(B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#find">find()</a>
<li><a href="#unique">unique()</a></li>
<li><a href="#vectorise">vectorise()</a>
<li><a href="#clean">.clean()</a>
<li><a href="#for_each">.for_each()</a>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="norm"></a>
<b>norm( X )</b>
<br><b>norm( X, p )</b>
<ul>
<li>
Compute the <i>p</i>-norm of <i>X</i>, where <i>X</i> is a vector or matrix
</li>
<br>
<li>
For vectors, <i>p</i> is an integer &ge;&thinsp;1, or one of: <code>"-inf"</code>, <code>"inf"</code>, <code>"fro"</code>
</li>
<br>
<li>
For matrices, <i>p</i> is one of: 1, 2, <code>"inf"</code>, <code>"fro"</code>
</li>
<br>
<li>
<code>"-inf"</code> is the minimum quasi-norm, <code>"inf"</code> is the maximum norm, <code>"fro"</code> is the Frobenius norm
</li>
<br>
<li>
The argument <i>p</i> is optional; by default <i>p&thinsp;=&thinsp;2</i> is used
</li>
<br>
<li>
For vector norm with <i>p&thinsp;=&thinsp;2</i> and matrix norm with <i>p&thinsp;=&thinsp;"fro"</i>, a robust algorithm is used to reduce the likelihood of underflows and overflows
</li>
<br>
<li>
<b>Caveats:</b>
<ul>
<li>matrix 2-norm (spectral norm) is based on SVD, which is computationally intensive; a faster alternative is <a href="#norm2est">norm2est()</a></li>
<li>to obtain the vector norm of each row or column of a matrix, use <a href="#vecnorm">vecnorm()</a></li>
<li>to obtain the zero/Hamming pseudo-norm (number of non-zero elements), use this expression: <code><a href="#accu">accu</a>(X&nbsp;!=&nbsp;0)</code></li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec q(5, fill::randu);

double x = norm(q, 2);
double y = norm(q, "inf");
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#vecnorm">vecnorm()</a></li>
<li><a href="#norm2est">norm2est()</a></li>
<li><a href="#normalise">normalise()</a></li>
<li><a href="#dot">dot()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Norm_(mathematics)">vector norm in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/VectorNorm.html">vector norm in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Matrix_norm">matrix norm in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/MatrixNorm.html">matrix norm in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="norm2est"></a>
<b>norm2est( X )</b>
<br><b>norm2est( X, tol )</b>
<br><b>norm2est( X, tol, max_iter )</b>
<ul>
<li>
Fast estimate of the 2-norm (spectral norm) of <i>X</i>, where <i>X</i> is a dense or sparse matrix
</li>
<br>
<li>
The estimate is found via an iterative algorithm which finishes when one of the following conditions is met:
<ul>
<li>
the relative difference between two consecutive estimates is less than the specified tolerance,
ie. |est<sub>1</sub>&thinsp;-&thinsp;est<sub>2</sub>| / max(est<sub>1</sub>&thinsp;,&thinsp;est<sub>2</sub>) &lt; tol
</li>
<li>the number of iterations is equal to <i>max_iter</i></li>
</ul>
</li>
<br>
<li>
The optional argument <i>tol</i> specifies the tolerance for the relative difference; by default <i>tol&thinsp;=&thinsp;1e-6</i> is used
</li>
<br>
<li>
The optional argument <i>max_iter</i> specifies the maximum number of iterations; by default <i>max_iter&thinsp;=&thinsp;100</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X(2000, 3000, fill::randu);

double x = norm2est(X);
double y = norm2est(X, 1e-5);
double z = norm2est(X, 1e-4, 10);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#norm">norm()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Matrix_norm">matrix norm in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/MatrixNorm.html">matrix norm in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="normalise"></a>
<b>normalise( V )</b>
<br><b>normalise( V, p )</b>
<br>
<br><b>normalise( X )</b>
<br><b>normalise( X, p )</b>
<br><b>normalise( X, p, dim )</b>
<ul>
<li>For vector <i>V</i>, return its normalised version (ie. having unit <i>p</i>-norm)</li>
<br>
<li>
For matrix <i>X</i>, return its normalised version, where each column (<i>dim&thinsp;=&thinsp;0</i>) or row (<i>dim&thinsp;=&thinsp;1</i>) has been normalised to have unit <i>p</i>-norm</li>
<br>
<li>
The <i>p</i> argument is optional; by default <i>p&thinsp;=&thinsp;2</i> is used
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec A(10, fill::randu);
vec B = normalise(A);
vec C = normalise(A, 1);

mat X(5, 6, fill::randu);
mat Y = normalise(X);
mat Z = normalise(X, 2, 1);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#norm">norm()</a></li>
<li><a href="#vecnorm">vecnorm()</a></li>
<li><a href="#dot">norm_dot()</a></li>
<li><a href="https://mathworld.wolfram.com/NormalizedVector.html">Normalised vector in MathWorld</a>
<li><a href="https://en.wikipedia.org/wiki/Unit_vector">Unit vector in Wikipedia</a>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="pow"></a>
<table>
<tbody>
<tr><td><b>pow( A, scalar )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;1)</td></tr>
<tr><td><b>pow( A, B )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;2)</td></tr>
<!--
<tr><td><b>pow( M.each_col(), C )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;3)</td></tr>
<tr><td><b>pow( M.each_row(), R )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;4)</td></tr>
<tr><td><b>pow( Q.each_slice(), M )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;5)</td></tr>
-->
</tbody>
</table>
<ul>
<li>Element-wise power operations</li>
<br>
<li>form 1: raise all elements in <i>A</i> to the power denoted by the given scalar</li>
<br>
<li>form 2: raise each element in <i>A</i> to the power denoted by the corresponding element in <i>B</i>; sizes of <i>A</i> and <i>B</i> must be the same</li>
<br>
<!--
<li>form 3: for each column vector of matrix <i>M</i>, raise each element to the power denoted by the corresponding element in column vector <i>C</i>;
<br>the number of rows in <i>M</i> and <i>C</i> must be the same</li>
<br>
<li>form 4: for each row vector of matrix <i>M</i>, raise each element to the power denoted by the corresponding element in row vector <i>R</i>;
<br>the number of columns in <i>M</i> and <i>R</i> must be the same</li>
<br>
<li>form 5: for each slice of cube <i>Q</i>, raise each element to the power denoted by the corresponding element in matrix <i>M</i>;
<br>the number of rows and columns in <i>Q</i> and <i>M</i> must be the same</li>
<br>
-->
<li><b>Caveats</b>:
<ul>
<li>to raise all elements to the power 2, use <a href="#misc_fns">square()</a> instead</li>
<li>for the matrix power operation, which takes into account matrix structure, use <a href="#powmat">powmat()</a></li>
</ul>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 6, fill::randu);
mat B(5, 6, fill::randu);

mat X = pow(A, 3.45);
mat Y = pow(A, B);
</pre>
<!--
   vec C(5, fill::randu);
rowvec R(6, fill::randu);

mat Z1 = pow(A.each_col(), C);
mat Z2 = pow(A.each_row(), R);
-->
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#powmat">powmat()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<!--
<li><a href="#each_colrow">.each_col() &amp; .each_row()</a></li>
<li><a href="#each_slice">.each_slice()</a></li>
-->
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="powmat"></a>
<b>B = powmat( A, n )</b>
<br><b>powmat( B, A, n )</b>
<ul>
<li>Matrix power operation: raise square matrix <i>A</i> to the power of <i>n</i>, where <i>n</i> has the type <i>int</i> or <i>double</i></li>
<br>
<li>If <i>n</i> has the type <i>double</i>, the resultant matrix <i>B</i> always has complex elements</li>
<br>
<li>For <i>n&thinsp;=&thinsp;0</i>, an identity matrix is generated</li>
<br>
<!--
<li>For <i>n&nbsp;&leq;&nbsp;-1</i>, inverse of <i>A</i> is raised to the power of <i>abs(n)</i></li>
<br>
-->
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the matrix power cannot be found:
<ul>
<li><i>B = powmat(A)</i> resets <i>B</i> and throws a <i>std::runtime_error</i> exception</li>
<li><i>powmat(B,A)</i> resets <i>B</i> and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li><b>Caveats</b>:
<ul>
<li>the matrix power operation is generally <b>not</b> the same as applying the <a href="#pow">pow()</a> function to each element</li>
<li>to find the inverse of a matrix, use <a href="#inv">inv()</a> instead</li>
<li>to solve a system of linear equations, use <a href="#solve">solve()</a> instead</li>
<li>to find the matrix square root, use <a href="#sqrtmat">sqrtmat()</a> instead</li>
</ul>
<br>
<li>
Examples:
<ul>
<pre>
   mat A(5, 5, fill::randu);

   mat B = powmat(A, 4);     //     integer exponent

cx_mat C = powmat(A, 4.56);  // non-integer exponent
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#pow">pow()</a></li>
<li><a href="#sqrtmat">sqrtmat()</a></li>
<li><a href="#inv">inv()</a></li>
<li><a href="#eye_standalone">eye()</a></li>
<li><a href="#operators">operators</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="prod"></a>
<b>prod( V )</b>
<br><b>prod( M )</b>
<br><b>prod( M, dim )</b>
<ul>
<li>
For vector <i>V</i>, return the product of all elements
</li>
<br>
<li>
For matrix <i>M</i>, return the product of elements in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec v(10, fill::randu);
double x = prod(v);

mat M(10, 10, fill::randu);

rowvec a = prod(M);
rowvec b = prod(M,0);
colvec c = prod(M,1);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#cumprod">cumprod()</a></li>
<li><a href="#operators">Schur product in operators</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="rank"></a>
<table>
<tbody>
<tr><td><b>r = rank( X )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;1)</td></tr>
<tr><td><b>r = rank( X, tolerance )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><b>rank( r, X )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>(form&nbsp;2)</td></tr>
<tr><td><b>rank( r, X, tolerance )</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>&nbsp;</td></tr>
</tbody>
</table>
<ul>
<li>Calculate the rank of matrix <i>X</i>, based on singular value decomposition</li>
<br>
<li>form 1: return the rank</li>
<br>
<li>form 2: store the calculated rank in <i>r</i> and return a bool indicating success</li>
<br>
<li>Any singular values less than <i>tolerance</i> are treated as zero</li>
<br>
<li>
The <i>tolerance</i> argument is optional; by default <i>tolerance = max_rc&thinsp;&middot;&thinsp;max_sv&thinsp;&middot;&thinsp;epsilon</i>, where:
<ul>
<li><i>max_rc</i> = max(X.n_rows,&thinsp;X.n_cols)</li>
<li><i>max_sv</i> = maximum singular value of <i>X</i>  (ie. spectral norm)</li>
<li><i>epsilon</i> = difference between 1 and the least value greater than 1 that is representable</li>
</ul>
</li>
<br>
<li>If the calculation fails:
<ul>
<li><i>r = rank(X)</i> throws a <i>std::runtime_error</i> exception</li>
<li><i>rank(r,X)</i> returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li>
<b>Caveat:</b> to distinguish from <code>std::rank</code>, use the <code>arma::</code> prefix, ie. <code>arma::rank(X)</code>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(4, 5, fill::randu);

uword r1 = rank(A);           // form 1

uword r2;
bool success = rank(r2,  A);  // form 2
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#rcond">rcond()</a></li>
<li><a href="#svd">svd()</a></li>
<li><a href="#orth">orth()</a></li>
<li><a href="#constants">datum::eps</a></li>
<li><a href="https://mathworld.wolfram.com/MatrixRank.html">Rank in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rank_(linear_algebra)">Rank in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="rcond"></a>
<b>rcond( A )</b>
<ul>
<li>
Return the 1-norm estimate of the reciprocal condition number of square matrix <i>A</i>
</li>
<br>
<li>
Values close to 1 suggest that <i>A</i> is well-conditioned
</li>
<br>
<li>
Values close to 0 suggest that <i>A</i> is badly conditioned
</li>
<br>
<li>
If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown
</li>
<br>
<li>
<b>Caveat:</b> to efficiently calculate rcond and matrix inverse at the same time, use <a href="#inv">inv()</a>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

double r = rcond(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#cond">cond()</a></li>
<li><a href="#rank">rank()</a></li>
<li><a href="#det">det()</a></li>
<li><a href="#inv">inv()</a></li>
<li><a href="#solve">solve()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="repelem"></a>
<b>repelem( A, num_copies_per_row, num_copies_per_col )</b>
<ul>
<li>Generate a matrix by replicating each element of matrix <i>A</i></li>
<br>
<li>The generated matrix has the following size:
<ul>
<table border="0">
<tbody>
<tr><td>n_rows</td><td>&nbsp;=&nbsp;</td><td>num_copies_per_row</td><td>*</td><td>A.n_rows</td></tr>
<tr><td>n_cols</td><td>&nbsp;=&nbsp;</td><td>num_copies_per_col</td><td>*</td><td>A.n_cols</td></tr>
</tbody>
</table>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(2, 3, fill::randu);

mat B = repelem(A, 4, 5);
</pre>
</ul>
</li>
<li>See also:
<ul>
<li><a href="#repmat">repmat()</a></li>
<li><a href="#kron">kron()</a></li>
<li><a href="#reshape">reshape()</a></li>
<li><a href="#resize">resize()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="repmat"></a>
<b>repmat( A, num_copies_per_row, num_copies_per_col )</b>
<ul>
<li>Generate a matrix by replicating matrix <i>A</i> in a block-like fashion</li>
<br>
<li>The generated matrix has the following size:
<ul>
<table border="0">
<tbody>
<tr><td>n_rows</td><td>&nbsp;=&nbsp;</td><td>num_copies_per_row</td><td>&times;</td><td>A.n_rows</td></tr>
<tr><td>n_cols</td><td>&nbsp;=&nbsp;</td><td>num_copies_per_col</td><td>&times;</td><td>A.n_cols</td></tr>
</tbody>
</table>
</ul>
</li>
<br>
<li>
<b>Caveat:</b> to apply a vector operation on each row or column of a matrix,
it is generally more efficient to use <a href="#each_colrow">.each_row()</a> or <a href="#each_colrow">.each_col()</a>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(2, 3, fill::randu);

mat B = repmat(A, 4, 5);
</pre>
</ul>
</li>
<li>See also:
<ul>
<li><a href="#each_colrow">.each_col() &amp; .each_row()</a> &nbsp; (vector operations applied to each column or row)</li>
<li><a href="#repelem">repelem()</a></li>
<li><a href="#kron">kron()</a></li>
<li><a href="#reshape">reshape()</a></li>
<li><a href="#resize">resize()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="reshape"></a>
<b>reshape( X, n_rows, n_cols )</b> &nbsp;&nbsp; (X is a vector or matrix)
<br><b>reshape( X, size(Y) )</b>
<br>
<br><b>reshape( Q, n_rows, n_cols, n_slices )</b> &nbsp;&nbsp; (Q is a cube)
<br><b>reshape( Q, size(R) )</b>
<ul>
<li>
Generate a vector/matrix/cube with given size specifications,
whose elements are taken from the given object in a column-wise manner;
the elements in the generated object are placed column-wise (ie. the first column is filled up before filling the second column)
</li>
<br>
<li>
The layout of the elements in the generated object will be different to the layout in the given object
</li>
<br>
<li>
If the total number of elements in the given object is less than the specified size,
the remaining elements in the generated object are set to zero
</li>
<br>
<li>
If the total number of elements in the given object is greater than the specified size,
only a subset of elements is taken from the given object
</li>
<br>
<li>
<b>Caveats:</b>
<ul>
<li>
to change the size without preserving data, use <a href="#set_size">.set_size()</a> instead, which is much faster
</li>
<li>
to grow/shrink a matrix while preserving the elements <b>as well as</b> the layout of the elements,
use <a href="#resize">resize()</a> instead
</li>
<li>
to flatten a matrix into a vector, use <a href="#vectorise">vectorise()</a> or <a href="#as_col_row">.as_col()&thinsp;/&thinsp;.as_row()</a> instead
</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(10, 5, fill::randu);

mat B = reshape(A, 5, 10);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#reshape_member">.reshape()</a> (member function)</li>
<li><a href="#set_size">.set_size()</a></li>
<li><a href="#resize">resize()</a></li>
<li><a href="#vectorise">vectorise()</a></li>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#conv_to">conv_to()</a></li>
<li><a href="#diagmat">diagmat()</a></li>
<li><a href="#repmat">repmat()</a></li>
<li><a href="#repelem">repelem()</a></li>
<li><a href="#size">size()</a></li>
<li><a href="#interp2">interp2()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="resize"></a>
<b>resize( X, n_rows, n_cols )</b> &nbsp;&nbsp; (X is a vector or matrix)
<br><b>resize( X, size(Y) )</b>
<br>
<br><b>resize( Q, n_rows, n_cols, n_slices )</b> &nbsp;&nbsp; (Q is a cube)
<br><b>resize( Q, size(R) )</b>
<ul>
<li>
Generate a vector/matrix/cube with given size specifications,
whose elements as well as the layout of the elements are taken from the given object
</li>
<br>
<li>
<b>Caveat:</b>
to change the size without preserving data, use <a href="#set_size">.set_size()</a> instead, which is much faster
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(4, 5, fill::randu);

mat B = resize(A, 7, 6);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#resize_member">.resize()</a> (member function of Mat and Cube)</li>
<li><a href="#set_size">.set_size()</a> (member function of Mat and Cube)</li>
<li><a href="#reshape">reshape()</a></li>
<li><a href="#vectorise">vectorise()</a></li>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#conv_to">conv_to()</a></li>
<li><a href="#repmat">repmat()</a></li>
<li><a href="#repelem">repelem()</a></li>
<li><a href="#size">size()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="reverse"></a>
<b>reverse( V )</b>
<br><b>reverse( X )</b>
<br><b>reverse( X, dim )</b>
<ul>
<li>
For vector <i>V</i>, generate a copy of the vector with the order of elements reversed
</li>
<br>
<li>
For matrix <i>X</i>, generate a copy of the matrix with the order of elements reversed in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec v(123, fill::randu);
vec y = reverse(v);

mat A(4, 5, fill::randu);
mat B = reverse(A);
mat C = reverse(A,1);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#flip">fliplr() &amp; flipud()</a></li>
<li><a href="#shift">shift()</a></li>
<li><a href="#sort">sort()</a></li>
<li><a href="#trans">trans()</a></li>
<li><a href="#t_st_members">.t()</a></li>
<li><a href="#swap_rows">.swap_rows() &amp; .swap_cols()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="roots"></a>
<b>R = roots( P )</b>
<br><b>roots( R, P )</b>
<ul>
<li>
Find the complex roots of a polynomial function represented via vector <i>P</i> and store them in column vector <i>R</i>
</li>
<br>
<li>
The polynomial function is modelled as:
<ul>
y = p<sub><sub>0</sub></sub>x<sup><sup>N</sup></sup>
  + p<sub><sub>1</sub></sub>x<sup><sup>N-1</sup></sup>
  + p<sub><sub>2</sub></sub>x<sup><sup>N-2</sup></sup>
  + ...
  + p<sub><sub>N-1</sub></sub>x<sup><sup>1</sup></sup>
  + p<sub><sub>N</sub></sub>
</ul>
where p<sub><sub>i</sub></sub> is the i-th polynomial coefficient in vector <i>P</i>
</li>
<br>
<li>The computation is based on eigen decomposition; if the decomposition fails:
<ul>
<li><i>R = roots(P)</i> resets <i>R</i> and throws a <i>std::runtime_error</i> exception</li>
<li><i>roots(R,P)</i> resets <i>R</i> and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
   vec P(5, fill::randu);
  
cx_vec R = roots(P);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#polyval">polyval()</a></li>
<li><a href="#polyfit">polyfit()</a></li>
<li><a href="#imag_real">real()</a></li>
<li><a href="#solve">solve()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Zero_of_a_function">zero of a function in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="shift"></a>
<b>shift( V, N )</b>
<br><b>shift( X, N )</b>
<br><b>shift( X, N, dim )</b>
<ul>
<li>
For vector <i>V</i>, generate a copy of the vector with the elements shifted by <i>N</i> positions in a circular manner
</li>
<br>
<li>
For matrix <i>X</i>, generate a copy of the matrix with the elements shifted by <i>N</i> positions in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
<i>N</i> can be positive or negative
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(4, 5, fill::randu);
mat B = shift(A, -1);
mat C = shift(A, +1);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#shuffle">shuffle()</a></li>
<li><a href="#flip">fliplr() &amp; flipud()</a></li>
<li><a href="#reverse">reverse()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="shuffle"></a>
<b>shuffle( V )</b>
<br><b>shuffle( X )</b>
<br><b>shuffle( X, dim )</b>
<ul>
<li>
For vector <i>V</i>, generate a copy of the vector with the elements shuffled
</li>
<br>
<li>
For matrix <i>X</i>, generate a copy of the matrix with the elements shuffled in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(4, 5, fill::randu);
mat B = shuffle(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#shift">shift()</a></li>
<li><a href="#sort">sort()</a></li>
<li><a href="#unique">unique()</a></li>
<li><a href="#randi">randi()</a></li>
<li><a href="#randperm">randperm()</a></li>
<li><a href="#rng_seed">RNG seed setting</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="size"></a>
<b>size(&nbsp;X&nbsp;)</b>
<br>
<b>size(&nbsp;n_rows,&nbsp;n_cols&nbsp;)</b>
<br>
<b>size(&nbsp;n_rows,&nbsp;n_cols,&nbsp;n_slices&nbsp;)</b>
<ul>
<li>
Obtain the dimensions of object <i>X</i>, or explicitly specify the dimensions
</li>
<br>
<li>
Dimensions provided via <i>size(...)</i> can be used in conjunction with
<a href="#Mat">matrix constructors</a>,
<a href="#submat">submatrix views</a>,
<a href="#randu">random matrix generation</a>,
<a href="#ind2sub">ind2sub()</a>, 
<a href="#sub2ind">sub2ind()</a>,
etc.
</li>
<br>
<li>
<i>size(&hellip;)</i> objects support simple arithmetic operations such as addition and multiplication
</li>
<br>
<li>
Two <i>size(&hellip;)</i> objects can be compared for equality/inequality
</li>
<br>
<li>
<i>size(&hellip;)</i> objects can be passed to an std::ostream (eg. cout) via &lt;&lt;
</li>
<br>
<li>
<b>Caveat:</b> to prevent interference from <a href="https://en.cppreference.com/w/cpp/iterator/size"><i>std::size()</i></a> in C++17,
preface Armadillo's <i>size(&hellip;)</i> with the <i>arma</i> namespace qualification, eg. <i>arma::size(&hellip;)</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5,6);

mat B(size(A), fill::zeros);

mat C; C.randu(size(A));

mat D = ones&lt;mat&gt;(size(A));

mat E(10,20, fill::ones);
E(3,4,size(C)) = C;    // access submatrix of E

mat F( size(A) + size(E) );

mat G( size(A) * 2 );

cout &lt;&lt; "size of A: " &lt;&lt; size(A) &lt;&lt; endl;

bool is_same_size = (size(A) == size(E));
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#attributes">attributes</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="sort"></a>
<b>sort( V )</b>
<br><b>sort( V, sort_direction )</b>
<br>
<br><b>sort( X )</b>
<br><b>sort( X, sort_direction )</b>
<br><b>sort( X, sort_direction, dim )</b>
<br>
<ul>
<li>For vector <i>V</i>, return a vector which is a sorted version of the input vector</li>
<br>
<li>For matrix <i>X</i>, return a matrix with the elements of the input matrix sorted in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>The <i>sort_direction</i> argument is optional; <i>sort_direction</i> is either <code>"ascend"</code> or <code>"descend"</code>; by default <code>"ascend"</code> is used</li>
<br>
<li>For matrices and vectors with complex numbers, sorting is via absolute values</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(10, 10, fill::randu);
mat B = sort(A);
</pre>
</ul>
</li>
<li>
See also:
<ul>
<li><a href="#sort_index">sort_index()</a></li>
<li><a href="#is_sorted">.is_sorted()</a></li>
<li><a href="#shuffle">shuffle()</a></li>
<li><a href="#unique">unique()</a></li>
<li><a href="#reverse">reverse()</a></li>
<li><a href="#randi">randi()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="sort_index"></a>
<b>sort_index( X )</b>
<br><b>sort_index( X, sort_direction )</b>
<br>
<br><b>stable_sort_index( X )</b>
<br><b>stable_sort_index( X, sort_direction )</b>
<ul>
<li>Return a vector which describes the sorted order of the elements of <i>X</i>
(ie. it contains the indices of the elements of <i>X</i>)
</li>
<br>
<li>The output vector must have the type <a href="#Col">uvec</a>
(ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)
</li>
<br>
<li>
<i>X</i> is interpreted as a vector, with column-by-column ordering of the elements of <i>X</i>
</li>
<br>
<li>The <i>sort_direction</i> argument is optional; <i>sort_direction</i> is either <code>"ascend"</code> or <code>"descend"</code>; by default <code>"ascend"</code> is used</li>
<br>
<li>The <i>stable_sort_index()</i> variant preserves the relative order of elements with equivalent values</li>
<br>
<li>For matrices and vectors with complex numbers, sorting is via absolute values</li>
<br>
<li>
Examples:
<ul>
<pre>
vec q(10, fill::randu);

uvec indices = sort_index(q);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#sort">sort()</a></li>
<li><a href="#find">find()</a></li>
<li><a href="#is_sorted">.is_sorted()</a></li>
<li><a href="#index_min_and_index_max_member">.index_min() &amp; .index_max()</a></li>
<li><a href="#ind2sub">ind2sub()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="sqrtmat"></a>
<b>B = sqrtmat( A )</b>
<br><b>sqrtmat( B, A )</b>
<ul>
<li>Complex square root of general square matrix <i>A</i></li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>
If matrix <i>A</i> appears to be singular, an approximate square root is attempted; additionally, <i>sqrtmat(B,A)</i> returns a bool set to false
</li>
<br>
<li><b>Caveats:</b>
<ul>
<li>the square root of a matrix is generally <b>not</b> the same as applying the <a href="#misc_fns">sqrt()</a> function to each element</li>
<li>if matrix <i>A</i> is symmetric positive definite, <a href="#sqrtmat_sympd">sqrtmat_sympd()</a> is faster</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
   mat A(5, 5, fill::randu);

cx_mat B = sqrtmat(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#sqrtmat_sympd">sqrtmat_sympd()</a></li>
<li><a href="#powmat">powmat()</a></li>
<li><a href="#expmat">expmat()</a></li>
<li><a href="#logmat">logmat()</a></li>
<li><a href="#chol">chol()</a></li>
<li><a href="#imag_real">real()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Square_root_of_a_matrix">square root of a matrix in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="sqrtmat_sympd"></a>
<b>B = sqrtmat_sympd( A )</b>
<br><b>sqrtmat_sympd( B, A )</b>
<ul>
<li>Square root of symmetric/hermitian positive definite matrix <i>A</i></li>
<br>
<li>If <i>A</i> is not square sized, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the square root cannot be found:
<ul>
<li><i>B = sqrtmat_sympd(A)</i> resets <i>B</i> and throws a <i>std::runtime_error</i> exception</li>
<li><i>sqrtmat_sympd(B,A)</i> resets <i>B</i> and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<!--
<br>
<li><b>Caveat:</b> there is no explicit check whether <i>A</i> is symmetric/hermitian positive definite</li>
-->
<br>
<li><b>Caveat:</b> the matrix square root operation is generally <b>not</b> the same as applying the <a href="#misc_fns">sqrt()</a> function to each element</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = A*A.t();   // make symmetric matrix

mat C = sqrtmat_sympd(B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#sqrtmat">sqrtmat()</a></li>
<li><a href="#expmat_sym">expmat_sym()</a></li>
<li><a href="#logmat_sympd">logmat_sympd()</a></li>
<li><a href="#chol">chol()</a></li>
<li><a href="#is_sympd">.is_sympd()</a></li>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Square_root_of_a_matrix">square root of a matrix in Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Positive-definite_matrix">positive definite matrix in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/PositiveDefiniteMatrix.html">positive definite matrix in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="sum"></a>
<b>sum( V )</b>
<br><b>sum( M )</b>
<br><b>sum( M, dim )</b>
<br><b>sum( Q )</b>
<br><b>sum( Q, dim )</b>
<ul>
<li>
For vector <i>V</i>, return the sum of all elements
</li>
<br>
<li>
For matrix <i>M</i>, return the sum of elements in each column (<i>dim&thinsp;=&thinsp;0</i>), or each row (<i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
For cube <i>Q</i>, return the sums of elements along dimension <i>dim</i>, where <i>dim</i> &isin; {&thinsp;0,&thinsp;1,&thinsp;2&thinsp;};
for example, <i>dim&thinsp;=&thinsp;0</i> indicates the sum of elements in each column within each slice
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
<b>Caveat:</b> to get a sum of all the elements regardless of the object type (ie. vector, or matrix, or cube), use <a href="#accu">accu()</a> instead
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec v(10, fill::randu);
double x = sum(v);

mat M(10, 10, fill::randu);

rowvec a = sum(M);
rowvec b = sum(M,0);
colvec c = sum(M,1);

double y = accu(M);   // find the overall sum regardless of object type
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#accu">accu()</a></li>
<li><a href="#cumsum">cumsum()</a></li>
<li><a href="#trace">trace()</a></li>
<li><a href="#trapz">trapz()</a></li>
<li><a href="#stats_fns">mean()</a></li>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#as_dense">.as_dense()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="sub2ind"></a>
<table>
<tbody>
<tr><td>uword&nbsp;</td><td>index</td><td>&nbsp;=&nbsp;<b>sub2ind(&nbsp;size(</b>M<b>),</b>&nbsp;row<b>,</b>&nbsp;col&nbsp;<b>)</b></td><td>(<i>M</i> is a matrix)</td></tr>
<tr><td>uvec&nbsp;</td><td>indices</td><td>&nbsp;=&nbsp;<b>sub2ind(&nbsp;size(</b>M<b>),</b>&nbsp;matrix_of_subscripts&nbsp;<b>)</b></td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>uword&nbsp;</td><td>index</td><td>&nbsp;=&nbsp;<b>sub2ind(&nbsp;size(</b>Q<b>),</b>&nbsp;row<b>,</b>&nbsp;col<b>,</b>&nbsp;slice&nbsp;<b>)</b></td><td>(<i>Q</i> is a cube)</td></tr>
<tr><td>uvec&nbsp;</td><td>indices</td><td>&nbsp;=&nbsp;<b>sub2ind(&nbsp;size(</b>Q<b>),</b>&nbsp;matrix_of_subscripts&nbsp;<b>)</b></td><td></td></tr>
</tbody>
</table>
<ul>
<li>
Convert subscripts to a linear index
</li>
<br>
<li>
The argument <i><b>size(</b>X<b>)</b></i> can be replaced with <i><b>size(</b>n_rows<b>,</b>&thinsp;n_cols<b>)</b></i> or <i><b>size(</b>n_rows<b>,</b>&thinsp;n_cols<b>,</b>&thinsp;n_slices<b>)</b></i>
</li>
<br>
<li>
For the <i>matrix_of_subscripts</i> argument, the subscripts must be stored in each column of an <i>m&thinsp;x&thinsp;n</i> matrix of type <a href="#Mat">umat</a>;
<i>m&thinsp;=&thinsp;2</i> for matrix subscripts, while <i>m&thinsp;=&thinsp;3</i> for cube subscripts
</li>
<br>
<li>
If a subscript is out of range, a <i>std::logic_error</i> exception is thrown
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat  M(4,5);
cube Q(4,5,6);

uword i = sub2ind( size(M), 2, 3 );
uword j = sub2ind( size(Q), 2, 3, 4 );
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#size">size()</a></li>
<li><a href="#ind2sub">ind2sub()</a></li>
<li><a href="#element_access">element access</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="symmat"></a>
<b>symmatu( A )</b>
<br><b>symmatu( A, do_conj )</b>
<br>
<br><b>symmatl( A )</b>
<br><b>symmatl( A, do_conj )</b>
<ul>
<li>
<i>symmatu(A)</i>: generate symmetric matrix from square matrix <i>A</i>, by reflecting the upper triangle to the lower triangle 
</li>
<br>
<li>
<i>symmatl(A)</i>: generate symmetric matrix from square matrix <i>A</i>, by reflecting the lower triangle to the upper triangle
</li>
<br>
<li>
If <i>A</i> is a complex matrix, the reflection uses the complex conjugate of the elements;
to disable the complex conjugate, set <i>do_conj</i> to <i>false</i>
</li>
<br>
<li>
If <i>A</i> is non-square, a <i>std::logic_error</i> exception is thrown
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat B = symmatu(A);
mat C = symmatl(A);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#diagmat">diagmat()</a></li>
<li><a href="#trimat">trimatu() / trimatl()</a></li>
<li><a href="#is_symmetric">.is_symmetric()</a></li>
<li><a href="#is_hermitian">.is_hermitian()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Symmetric_matrix">Symmetric matrix in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="trace"></a>
<b>trace( X )</b>
<ul>
<li>
Sum of the elements on the main diagonal of matrix <i>X</i>
</li>
<br>
<li>
If <i>X</i> is an expression, the evaluation of the expression aims to calculate only the diagonal elements
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

double x = trace(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#accu">accu()</a></li>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#diag">.diag()</a></li>
<li><a href="#diagvec">diagvec()</a></li>
<li><a href="#diagmat">diagmat()</a></li>
<li><a href="#sum">sum()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="trans"></a>
<b>trans( A )</b>
<br><b>strans( A )</b>
<ul>
<li>
For real (non-complex) matrix:
<ul>
<li><i>trans()</i> provides a transposed copy of the matrix</li>
<li><i>strans()</i> is not applicable</li>
</ul>
</li>
<br>
<li>
For complex matrix:
<ul>
<li><i>trans()</i> provides a Hermitian (conjugate) transposed copy (ie. signs of imaginary components are flipped)</li>
<li><i>strans()</i> provides a simple transposed copy (ie. signs of imaginary components are not flipped)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 10, fill::randu);

mat B = trans(A);
mat C = A.t();    // equivalent to trans(A), but more compact
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#t_st_members">.t()</a></li>
<li><a href="#inplace_trans">inplace_trans()</a></li>
<li><a href="#reverse">reverse()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transpose">transpose in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/Transpose.html">transpose in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Conjugate_transpose">conjugate transpose in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/ConjugateTranspose.html">conjugate transpose in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="trapz"></a>
<b>trapz( X, Y )</b>
<br><b>trapz( X, Y, dim )</b>
<br>
<br><b>trapz( Y )</b>
<br><b>trapz( Y, dim )</b>
<ul>
<li>
Compute the trapezoidal integral of <i>Y</i> with respect to spacing in <i>X</i>, in each column (<i>dim&thinsp;=&thinsp;0</i>) or each row (<i>dim&thinsp;=&thinsp;1</i>) of <i>Y</i>
</li>
<br>
<li>
<i>X</i> must be a vector; its length must equal either the number of rows in <i>Y</i> (when <i>dim&thinsp;=&thinsp;0</i>), or the number of columns in <i>Y</i> (when <i>dim&thinsp;=&thinsp;1</i>)
</li>
<br>
<li>
If <i>X</i> is not specified, unit spacing is used
</li>
<br>
<li>
The <i>dim</i> argument is optional; by default <i>dim&thinsp;=&thinsp;0</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec X = linspace&lt;vec&gt;(0, datum::pi, 1000);
vec Y = sin(X);

mat Z = trapz(X,Y);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#diff">diff()</a></li>
<li><a href="#sum">sum()</a></li>
<li><a href="#linspace">linspace()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Numerical_integration">numerical integration in Wikipedia</a>
<li><a href="https://mathworld.wolfram.com/NumericalIntegration.html">numerical integration in MathWorld</a>
<li><a href="https://en.wikipedia.org/wiki/Trapezoidal_rule">trapezoidal rule in Wikipedia</a>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="trimat"></a>
<b>trimatu( A )</b>
<br><b>trimatu( A, k )</b>
<br>
<br><b>trimatl( A )</b>
<br><b>trimatl( A, k )</b>
<ul>
<li>
Create a new matrix by copying either the upper or lower triangular part from square matrix <i>A</i>, and setting the remaining elements to zero
<ul>
<li><i>trimatu()</i> copies the upper triangular part</li>
<li><i>trimatl()</i> copies the lower triangular part</li>
</ul>
</li>
<br>
<li>
The argument <i>k</i> specifies the diagonal which inclusively delineates the boundary of the triangular part
<ul>
<li>
for <i>k&thinsp;&gt;&thinsp;0</i>, the <i>k</i>-th super-diagonal is used (above main diagonal, towards top-right corner)
</li>
<li>
for <i>k&thinsp;&lt;&thinsp;0</i>, the <i>k</i>-th sub-diagonal is used (below main diagonal, towards bottom-left corner)
</li>
</ul>
</li>
<br>
<li>
The argument <i>k</i> is optional; by default the main diagonal is used (<i>k&thinsp;=&thinsp;0</i>)
</li>
<br>
<li>
If <i>A</i> is non-square, a <i>std::logic_error</i> exception is thrown
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

mat U  = trimatu(A);
mat L  = trimatl(A);

mat UU = trimatu(A,  1);  // omit the main diagonal
mat LL = trimatl(A, -1);  // omit the main diagonal
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#is_trimat">.is_trimatu() / .is_trimatl()</a></li>
<li><a href="#trimat_ind">trimatu_ind() / trimatl_ind()</a></li>
<li><a href="#symmat">symmatu() / symmatl()</a></li>
<li><a href="#diagmat">diagmat()</a></li>
<li><a href="#nonzeros">nonzeros()</a></li>
<li><a href="https://mathworld.wolfram.com/TriangularMatrix.html">Triangular matrix in MathWorld</a></li>
<li><a href="https://en.wikipedia.org/wiki/Triangular_matrix">Triangular matrix in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>


<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="trimat_ind"></a>
<b>trimatu_ind( size(A) )</b>
<br><b>trimatu_ind( size(A), k )</b>
<br>
<br><b>trimatl_ind( size(A) )</b>
<br><b>trimatl_ind( size(A), k )</b>
<ul>
<li>
Return a column vector containing the indices of elements that form the upper or lower triangle part of matrix <i>A</i> 
<ul>
<li><i>trimatu_ind()</i> refers to the upper triangular part</li>
<li><i>trimatl_ind()</i> refers to the lower triangular part</li>
</ul>
</li>
<br>
<li>The output vector must have the type <a href="#Col">uvec</a>
(ie. the indices are stored as unsigned integers of type <a href="#uword">uword</a>)
</li>
<br>
<li>
The argument <i>k</i> specifies the diagonal which inclusively delineates the boundary of the triangular part
<ul>
<li>
for <i>k&thinsp;&gt;&thinsp;0</i>, the <i>k</i>-th super-diagonal is used (above main diagonal, towards top-right corner)
</li>
<li>
for <i>k&thinsp;&lt;&thinsp;0</i>, the <i>k</i>-th sub-diagonal is used (below main diagonal, towards bottom-left corner)
</li>
</ul>
</li>
<br>
<li>
The argument <i>k</i> is optional; by default the main diagonal is used (<i>k&thinsp;=&thinsp;0</i>)
</li>
<br>
<li>
The argument <i><b>size(</b>A<b>)</b></i> can be replaced with <i><b>size(</b>n_rows<b>,</b>&nbsp;n_cols<b>)</b></i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);

uvec upper_indices = trimatu_ind( size(A) );
uvec lower_indices = trimatl_ind( size(A) );

// extract upper/lower triangle into vector
vec upper_part = A(upper_indices);
vec lower_part = A(lower_indices);

// obtain indices without the main diagonal
uvec alt_upper_indices = trimatu_ind( size(A),  1);
uvec alt_lower_indices = trimatl_ind( size(A), -1);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#trimat">trimatu() / trimatl()</a></li>
<li><a href="#find">find()</a></li>
<li><a href="#submat">submatrix views</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="unique"></a>
<b>unique( A )</b>
<br>
<ul>
<li>
Return the unique elements of <i>A</i>, sorted in ascending order
</li>
<br>
<li>
If <i>A</i> is a vector, the output is also a vector with the same orientation (row or column) as <i>A</i>;
if <i>A</i> is a matrix, the output is always a column vector
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = { { 1, 2 }
          { 2, 3 } };

mat Y = unique(X);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#find">find()</a></li>
<li><a href="#find_unique">find_unique()</a></li>
<li><a href="#sort">sort()</a></li>
<li><a href="#shuffle">shuffle()</a></li>
<li><a href="#nonzeros">nonzeros()</a></li>
<li><a href="#intersect">intersect()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="vecnorm"></a>
<b>vecnorm( X )</b>
<br><b>vecnorm( X, p )</b>
<br><b>vecnorm( X, p, dim )</b>
<ul>
<li>
Compute the <i>p</i>-norm of each column vector <i>(dim&thinsp;=&thinsp;0)</i> or row vector <i>(dim&thinsp;=&thinsp;1)</i> of matrix <i>X</i>
</li>
<br>
<li>
<i>p</i> is an integer &ge;&thinsp;1, or <code>"-inf"</code> (minimum quasi-norm), or <code>"inf"</code> (maximum norm)
</li>
<br>
<li>
The arguments <i>p</i> and <i>dim</i> are optional; by default <i>p&thinsp;=&thinsp;2</i> and <i>dim&thinsp;=&thinsp;0</i> are used
</li>
<br>
<li>
<b>Caveat:</b> to compute the matrix norm, use <a href="#norm">norm()</a> instead
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X(4, 5, fill::randu);

rowvec r = vecnorm(X, 2);

colvec c = vecnorm(X, "inf", 1);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#norm">norm()</a></li>
<li><a href="#normalise">normalise()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Norm_(mathematics)">vector norm in Wikipedia</a></li>
<li><a href="https://mathworld.wolfram.com/VectorNorm.html">vector norm in MathWorld</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="vectorise"></a>
<b>vectorise( X )</b>
<br><b>vectorise( X, dim )</b>
<br><b>vectorise( Q )</b>
<ul>
<li>
Generate a flattened version of matrix <i>X</i> or cube <i>Q</i>
</li>
<br>
<li>
The argument <i>dim</i> is optional; by default <i>dim&thinsp;=&thinsp;0</i> is used
</li>
<br>
<li>
For <i>dim&thinsp;=&thinsp;0</i>, the elements are copied from <i>X</i> column-wise, resulting in a column vector; equivalent to concatenating all the columns of <i>X</i>
</li>
<br>
<li>
For <i>dim&thinsp;=&thinsp;1</i>, the elements are copied from <i>X</i> row-wise, resulting in a row vector; equivalent to concatenating all the rows of <i>X</i>
</li>
<br>
<li>
<b>Caveats:</b>
<ul>
<li>column-wise vectorisation is faster than row-wise vectorisation</li>
<li>for sparse matrices, row-wise vectorisation is not recommended</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X(4, 5, fill::randu);

vec v = vectorise(X);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#as_col_row">.as_col()&nbsp;/&nbsp;.as_row()</a></li>
<li><a href="#col_row_as_mat">.col_as_mat()&nbsp;/&nbsp;.row_as_mat()</a></li>
<li><a href="#nonzeros">nonzeros()</a></li>
<li><a href="#reshape">reshape()</a></li>
<li><a href="#resize">resize()</a></li>
<li><a href="#diagvec">diagvec()</a></li>
<li><a href="#as_scalar">as_scalar()</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="misc_fns"></a>
<b>miscellaneous element-wise functions:</b>
<ul>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td><b>exp      </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>log      </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>square</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>floor </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>erf   </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>tgamma</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>sign  </b></td></tr>
<tr><td><b>exp2     </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>log2     </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>sqrt  </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>ceil  </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>erfc  </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>lgamma</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td></tr>
<tr><td><b>exp10    </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>log10    </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>cbrt  </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>round </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td></tr>
<tr><td><b>expm1    </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>log1p    </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>trunc </b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td></tr>
<tr><td><b>trunc_exp</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>trunc_log</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td><td>&nbsp;&nbsp;&nbsp;</td><td><b>&nbsp;</b></td></tr>
</table>
</ul>
<ul>
<li>
Apply a function to each element
</li>
<br>
<li>
Usage:
<ul>
<li><i>B&thinsp;=&thinsp;fn(A)</i>, where <i>fn(A)</i> is one of the functions below</li>
<li><i>A</i> and <i>B</i> must have the same matrix type or cube type, such as <i>mat</i> or <i>cube</i></li>
</ul>
<br>
<table style="text-align: left;" border="0" cellpadding="2" cellspacing="2">
<tbody>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>exp(A)</code><sup>&nbsp;</sup>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-e exponential: <i>e<sup>&thinsp;x</sup></i>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>exp2(A)</code><sup>&nbsp;</sup>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-2 exponential: <i>2<sup>&thinsp;x</sup></i>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>exp10(A)</code><sup>&nbsp;</sup>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-10 exponential: <i>10<sup>&thinsp;x</sup></i>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>expm1(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      compute <code>exp(A)-1</code> accurately for values of A close to zero &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>trunc_exp(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-e exponential,
      truncated to avoid infinity &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>log(A)</code><sub>&nbsp;</sub>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      natural log: <i>log<sub>e</sub>&thinsp;x</i>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>log2(A)</code><sub>&nbsp;</sub>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-2 log: <i>log<sub><small>2</small></sub>&thinsp;x</i>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>log10(A)</code><sub>&nbsp;</sub>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-10 log: <i>log<sub><small>10</small></sub>&thinsp;x</i>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>log1p(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      compute <code>log(1+A)</code> accurately for values of A close to zero &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>trunc_log(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      natural log,
      truncated to avoid &plusmn;infinity &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
      <code>square(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      square: <i>x<sup><small>&thinsp;2</small></sup></i>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>sqrt(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      square root: <i>&radic;x</i>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
       <code>cbrt(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      cube root: <i>&#8731;x</i>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>floor(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      largest integral value that is not greater than the input value
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>ceil(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      smallest integral value that is not less than the input value
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>round(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      round to nearest integer, with halfway cases rounded away from zero
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>trunc(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      round to nearest integer, towards zero
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
      <code>erf(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      error function &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
      <code>erfc(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      complementary error function &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>tgamma(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      gamma function &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top; text-align: right;">
      <code>lgamma(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      natural log of the absolute value of gamma function &nbsp; <font size=-1>(only for <i>float</i> and <i>double</i> elements)</font>
    </td>
  </tr>
  <tr style="background-color: #F5F5F5;">
    <td style="vertical-align: top; text-align: right;">
      <code>sign(A)</code>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      signum function;
      for each element <i>a</i> in <i>A</i>, the corresponding element <i>b</i> in <i>B</i> is:
      <ul>
      <table border="0" cellpadding="0" cellspacing="0">
      <tbody>
      <tr><td>              </td><td>&#9127;&nbsp;</td><td style="text-align: right;">&minus;1</td><td>&nbsp;if <i>a</i> &lt; 0</td></tr>
      <tr><td>b&nbsp;=&nbsp;</td><td>&#9128;&nbsp;</td><td style="text-align: right;">       0</td><td>&nbsp;if <i>a</i> =    0</td></tr>
      <tr><td>              </td><td>&#9129;&nbsp;</td><td style="text-align: right;">      +1</td><td>&nbsp;if <i>a</i> &gt; 0</td></tr>
      </tbody>
      </table>
      </ul>
      if <i>a</i> is complex and non-zero, then <i>b</i> = <i>a</i> / abs(<i>a</i>)
    </td>
  </tr>
</tbody>
</table>
</li>
<br>
<li>
<b>Caveats:</b>
<ul>
<li>all of the above functions are applied element-wise, where each element is treated independently</li>
<li>
the element-wise functions <i>exp()</i>, <i>log()</i> and <i>sqrt()</i>
have the corresponding functions <a href="#expmat">expmat()</a>, <a href="#logmat">logmat()</a> and <a href="#sqrtmat">sqrtmat()</a> which take into account matrix structure
</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5, 5, fill::randu);
mat B = exp(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#abs">abs()</a></li>
<li><a href="#pow">pow()</a></li>
<li><a href="#clamp">clamp()</a></li>
<li><a href="#conj">conj()</a></li>
<li><a href="#imag_real">imag() / real()</a></li>
<li><a href="#transform">.transform()</a> &nbsp; (apply user-defined function to each element)</li>
<li><a href="#expmat">expmat()</a></li>
<li><a href="#logmat">logmat()</a></li>
<li><a href="#sqrtmat">sqrtmat()</a></li>
<li><a href="#trig_fns">trigonometric functions</a></li>
<li><a href="#stats_fns">statistics functions</a></li>
<li><a href="#constants">miscellaneous constants</a></li>
</ul>
</li>
<br>
</ul>

<div class="pagebreak"></div><div class="noprint"><hr class="greyline"><br></div>
<a name="trig_fns"></a>
<b>trigonometric element-wise functions (cos, sin, tan, ...)</b>
<ul>
<li>
For single argument functions, <i>B = trig_fn(A)</i>, where <i>trig_fn</i> is applied to each element in <i>A</i>, with <i>trig_fn</i> as one of:
<ul>
<li>
<i>cos</i>, <i>acos</i>, <i>cosh</i>, <i>acosh</i>
</li>
<li>
<i>sin</i>, <i>asin</i>, <i>sinh</i>, <i>asinh</i>
</li>
<li>
<i>tan</i>, <i>atan</i>, <i>tanh</i>, <i>atanh</i>
</li>
<li>
<i>sinc</i>, defined as sinc(x) = sin(&pi;x)&thinsp;/&thinsp;(&pi;x) for x&thinsp;&ne;&thinsp;0, and sinc(x)&thinsp;=&thinsp;1 for x&thinsp;=&thinsp;0
</li>
</ul>
</li>
<br>
<li>
For dual argument functions, apply the function to each tuple of two corresponding elements in <i>X</i> and <i>Y</i>:
<ul>
<li><i>Z = atan2(Y, X)</i></li>
<li><i>Z = hypot(X, Y)</i></li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X(5, 5, fill::randu);
mat Y = cos(X);
</pre>
</ul>
</li>
<li>
See also:
<ul>
<li><a href="#misc_fns">miscellaneous element-wise functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">trigonometric functions in Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Atan2">atan2 function in Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hypot">hypot function in Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sinc_function">sinc function in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>
