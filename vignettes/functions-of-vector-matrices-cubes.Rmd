---
title: "Functions of vectors, matrices, and cubes"
output: rmarkdown::html_vignette
bibliography: "references.bib"
vignette: >
  %\VignetteIndexEntry{Functions of vectors, matrices, and cubes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

**This vignette is adapted from the official Armadillo
[documentation](https://arma.sourceforge.net/docs.html).**

# Contents

| Function                | Description                                                                 |
|-------------------------|-----------------------------------------------------------------------------|
| `abs`                   | [Obtain magnitude of each element](#abs)                                    |
| `accu`                  | [Accumulate (sum) all elements](#accu)                                      |
| `affmul`                | [Affine matrix multiplication](#affmul)                                     |
| `all`                   | [Check whether all elements are non-zero, or satisfy a relational condition](#all) |
| `any`                   | [Check whether any element is non-zero, or satisfies a relational condition](#any) |
| `approx_equal`          | [Approximate equality](#approx_equal)                                       |
| `arg`                   | [Phase angle of each element](#arg)                                         |
| `as_scalar`             | [Convert 1x1 matrix to pure scalar](#as_scalar)                             |
| `clamp`                 | [Obtain clamped elements according to given limits](#clamp)                 |
| `cond`                  | [Condition number of matrix](#cond)                                         |
| `conj`                  | [Obtain complex conjugate of each element](#conj)                           |
| `conv_to`               | [Convert/cast between matrix types](#conv_to)                               |
| `cross`                 | [Cross product](#cross)                                                     |
| `cumsum`                | [Cumulative sum](#cumsum)                                                   |
| `cumprod`               | [Cumulative product](#cumprod)                                              |
| `det`                   | [Determinant](#det)                                                         |
| `diagmat`               | [Generate diagonal matrix from given matrix or vector](#diagmat)            |
| `diagvec`               | [Extract specified diagonal](#diagvec)                                      |
| `diags`                 | [Generate a dense matrix with diagonals specified by column vectors](#diags) |
| `diff`                  | [Differences between adjacent elements](#diff)                              |
| `dot/cdot/norm_dot`     | [Dot product](#dot)                                         |
| `eps`                   | [Obtain distance of each element to next largest floating point representation](#eps) |
| `expmat`                | [Matrix exponential](#expmat)                                               |
| `expmat_sym`            | [Matrix exponential of symmetric matrix](#expmat_sym)                       |
| `find`                  | [Find indices of non-zero elements, or elements satisfying a relational condition](#find) |
| `find_finite`           | [Find indices of finite elements](#find_finite)                             |
| `find_nonfinite`        | [Find indices of non-finite elements](#find_nonfinite)                      |
| `find_nan`              | [Find indices of NaN elements](#find_nan)                                   |
| `find_unique`           | [Find indices of unique elements](#find_unique)                             |
| `fliplr/flipud`         | [Flip matrix left to right or upside down](#fliplr)                         |
| `imag/real`             | [Extract imaginary/real part](#imag)                                        |
| `ind2sub`               | [Convert linear index to subscripts](#ind2sub)                              |
| `index_min / index_max` | [Indices of extremum values](#index_min)                         |
| `inplace_trans`         | [In-place transpose](#inplace_trans)                                        |
| `intersect`             | [Find common elements in two vectors/matrices](#intersect)                  |
| `join_rows / join_cols` | [Concatenation of matrices](#join_rows--join_cols)                          |
| `join_slices`           | [Concatenation of cubes](#join_slices)                                      |
| `kron`                  | [Kronecker tensor product](#kron)                                           |
| `log_det`               | [Log determinant](#log_det)                                                 |
| `log_det_sympd`         | [Log determinant of symmetric positive definite matrix](#log_det_sympd)     |
| `logmat`                | [Matrix logarithm](#logmat)                                                 |
| `logmat_sympd`          | [Matrix logarithm of symmetric matrix](#logmat_sympd)                       |
| `min / max`             | [Return extremum values](#min--max)                                         |
| `nonzeros`              | [Return non-zero values](#nonzeros)                                         |
| `norm`                  | [Various norms of vectors and matrices](#norm)                              |
| `norm2est`              | [Fast estimate of the matrix 2-norm](#norm2est)                             |
| `normalise`             | [Normalise vectors to unit p-norm](#normalise)                              |
| `pow`                   | [Element-wise power](#pow)                                                  |
| `powmat`                | [Matrix power](#powmat)                                                     |
| `prod`                  | [Product of elements](#prod)                                                |
| `rank`                  | [Rank of matrix](#rank)                                                     |
| `rcond`                 | [Reciprocal condition number](#rcond)                                       |
| `repelem`               | [Replicate elements](#repelem)                                              |
| `repmat`                | [Replicate matrix in block-like fashion](#repmat)                           |
| `reshape`               | [Change size while keeping elements](#reshape)                              |
| `resize`                | [Change size while keeping elements and preserving layout](#resize)         |
| `reverse`               | [Reverse order of elements](#reverse)                                       |
| `roots`                 | [Roots of polynomial](#roots)                                               |
| `shift`                 | [Shift elements](#shift)                                                    |
| `shuffle`               | [Randomly shuffle elements](#shuffle)                                       |
| `size`                  | [Obtain dimensions of given object](#size)                                  |
| `sort`                  | [Sort elements](#sort)                                                      |
| `sort_index`            | [Vector describing sorted order of elements](#sort_index)                   |
| `spdiags`               | [Generate a sparse matrix with diagonals specified by column vectors](#spdiags) |
| `sqrtmat`               | [Square root of matrix](#sqrtmat)                                           |
| `sqrtmat_sympd`         | [Square root of symmetric matrix](#sqrtmat_sympd)                           |
| `sum`                   | [Sum of elements](#sum)                                                     |
| `sub2ind`               | [Convert subscripts to linear index](#sub2ind)                              |
| `symmatu / symmatl`     | [Generate symmetric matrix from given matrix](#symmatu--symmatl)            |
| `trace`                 | [Sum of diagonal elements](#trace)                                          |
| `trans`                 | [Transpose of matrix](#trans)                                               |
| `trapz`                 | [Trapezoidal numerical integration](#trapz)                                 |
| `trimatu / trimatl`     | [Copy upper/lower triangular part](#trimatu--trimatl)                       |
| `trimatu_ind / trimatl_ind` | [Obtain indices of upper/lower triangular part](#trimatu_ind--trimatl_ind) |
| `unique`                | [Return unique elements](#unique)                                           |
| `vecnorm`               | [Obtain vector norm of each row or column of a matrix](#vecnorm)            |
| `vectorise`             | [Flatten matrix into vector](#vectorise)                                    |
| `misc functions`        | [Miscellaneous element-wise functions: exp, log, sqrt, round, sign, ...](#misc-functions) |
| `trig functions`        | [Trigonometric element-wise functions: cos, sin, tan, ...](#trig-functions) |

# Absolute value {#abs}

The `abs()` function computes the absolute value of each element in a vector,
matrix, or cube.

Usage:

```cpp
Y = abs(X); // for non-complex X
real_object_type Y = abs(X); // for complex X
```

For the non-complex case, `X` and `Y` must have the same type, such as mat or
cube.

For the complex case, `Y` must be the real counterpart to the type of `X`. If
`X` has the type `cx_mat`, then the type of `Y` must be `mat `.

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> abs1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = abs(A);

  cx_mat X(n, n, fill::randu);
  mat Y = abs(X);

  mat res = B + Y;

  return as_doubles_matrix(res);
}
```

#  Accumulate (sum) all elements {#accu}

The `accu()` function computes the sum of all elements in a vector, matrix, or
cube.

## Examples

```cpp
[[cpp11::register]] double accu1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B(n, n, fill::randu);

  double x = accu(A);

  // accu(A % B) is a "multiply-and-accumulate" operation
  // as operator % performs element-wise multiplication
  double y = accu(A % B);

  return (x + y);
}
```

# Affine matrix multiplication {#affmul}

The `affmul()` function computes matrix multiplication for `A` and `B` with an
extended form of `B`. `A` is typically an affine transformation matrix. `B` can
be a vector or matrix, and is treated as having an additional row of ones.

The number of columns in `A` must be equal to number of rows in the extended
form of `B` (e.g., `A.n_cols = B.n_rows + 1`).

If `A`has dimensions 3x3 and `B` 2x1, the equivalent matrix multiplication is:

```
⎡ C0 ⎤   ⎡ A00 A01 A02 ⎤   ⎡ B0 ⎤
⎢ C1 ⎥ = ⎢ A10 A11 A12 ⎥ x ⎢ B1 ⎥
⎣ C2 ⎦   ⎣ A20 A21 A22 ⎦   ⎣ 1  ⎦
```

If `A` has dimensions 2x3 and `B` 2x1, the equivalent matrix multiplication is:

```
⎡ C0 ⎤   ⎡ A00 A01 A02 ⎤   ⎡ B0 ⎤
⎢ C1 ⎥ = ⎢ A10 A11 A12 ⎥ x ⎢ B1 ⎥
                           ⎣ 1  ⎦
```

## Examples

```cpp
[[cpp11::register]] doubles affmul1_(const int& n) {
  mat A(n, n + 1, fill::randu);
  vec B(n, fill::randu);

  vec C = affmul(A, B);

  return as_doubles(C);
}
```

# Check whether all elements are non-zero, or satisfy a relational condition {#all}

The `all()` function checks whether all elements in a vector, matrix or cube
are non-zero, or satisfy a relational condition. It returns true/false booleans
for vectors and 0/1 vectors for matrices to indicate if the condition is met
for each row or column.

Usage:

```cpp
all(vector);
all(matrix);
all(matrix, dimension); // dimension = 0 -> returns a row vector urowvec/umat
                        // dimension = 1 -> returns a column vector ucolvec/umat
```

## Examples

```cpp
[[cpp11::register]] logicals all1_(const int& n) {
  vec V(n, fill::randu);
  mat X(n, n, fill::randu);

  // true if vector V has all non-zero elements
  bool status1 = all(V);

  // true if vector V has all elements greater than 0.5
  bool status2 = all(V > 0.5);

  // true if matrix X has all elements greater than 0.6;
  // note the use of vectorise()
  bool status3 = all(vectorise(X) > 0.6);

  // row vector indicating which columns of X have all elements greater than 0.7
  umat A = all(X > 0.7);

  writable::logicals res(4);
  res[0] = status1;
  res[1] = status2;
  res[2] = status3;
  res[3] = all(vectorise(A) == 1);  // true if all elements of A are 1

  return res;
}
```

# Check whether any element is non-zero, or satisfies a relational condition {#any}

The `any()` function checks whether any element in a vector, matrix or cube is
non-zero, or satisfies a relational condition. It returns true/false booleans
for vectors and 0/1 vectors for matrices to indicate if the condition is met
for any row or column.

Usage:

```cpp
any(vector);
any(matrix);
any(matrix, dimension); // dimension = 0 -> returns a row vector urowvec/umat
                        // dimension = 1 -> returns a column vector ucolvec/umat
```

## Examples

```cpp
[[cpp11::register]] logicals any1_(const int& n) {
  vec V(n, fill::randu);
  mat X(n, n, fill::randu);

  // true if vector V has any non-zero elements
  bool status1 = any(V);

  // true if vector V has any elements greater than 0.5
  bool status2 = any(V > 0.5);

  // true if matrix X has any elements greater than 0.6;
  // note the use of vectorise()
  bool status3 = any(vectorise(X) > 0.6);

  // row vector indicating which columns of X have any elements greater than 0.7
  umat A = any(X > 0.7);

  writable::logicals res(4);
  res[0] = status1;
  res[1] = status2;
  res[2] = status3;
  res[3] = any(vectorise(A) == 1);  // true if any element of A is 1

  return res;
}
```

# Approximate equality {#approx_equal}

The `approx_equal()` function checks whether two vectors, matrices or cubes are
approximately equal. It returns true if all corresponding elements have
differences less than or equal to a given tolerance.

Usage:

```cpp
approx_equal(A, B, method, tol)
approx_equal(A, B, method, abs_tol, rel_tol)
```

The `method` parameter specifies the method used to compare the elements:

* `method = "absdiff"`: absolute difference (e.g., `|A - B| <= tol`)
* `method = "reldiff"`: relative difference (e.g., `|A - B| / max(|A|, |B|) <= tol`)
* `method = "both"`: absolute or relative difference (e.g., `|A - B| <= tol || |A - B| / max(|A|, |B|) <= tol`)

## Examples

```cpp
[[cpp11::register]] bool approx_equal1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = A + 0.001;

  bool same1 = approx_equal(A, B, "absdiff", 0.002);

  mat C = 1000 * randu<mat>(n, n);
  mat D = C + 1;

  bool same2 = approx_equal(C, D, "reldiff", 0.1);

  bool same3 = approx_equal(C, D, "both", 2, 0.1);

  bool all_same = same1 && same2 && same3;

  return all_same;
}
```

# Phase angle of each element {#arg}

The `arg()` function computes the phase angle of each element in a vector,
matrix or cube. For non-complex elements, the input is treated as a complex
element with zero imaginary component. For complex elements, the input must be
of the same and the output the real counterpart type.

Usage:

```cpp
real_object_type Y = arg(X);
```

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> arg1_(const int& n) {
  cx_mat X(n, n, fill::randu);
  mat Y = arg(X);

  return as_doubles_matrix(Y);
}
```

# Convert 1x1 matrix to pure scalar {#as_scalar}

The `as_scalar()` function converts a 1x1 matrix to a scalar (e.g.,
`double/int`). It is useful when you want to extract a single element from a
matrix or an operation (e.g., converting the result of a dot/inner product to a
scalar).

## Examples

```cpp
[[cpp11::register]] double as_scalar1_(const int& n) {
  rowvec r(n, fill::randu);
  colvec q(n, fill::randu);

  mat X(n, n, fill::randu);

  // examples of expressions which have optimised implementations
  double a = as_scalar(r*q);
  double b = as_scalar(r*X*q);
  double c = as_scalar(r*diagmat(X)*q);
  double d = as_scalar(r*inv(diagmat(X))*q);

  return (a + b + c + d);
}
```

# Obtain clamped elements according to given limits {#clamp}

The `clamp()` function clamps each element in a vector, matrix or cube to a
given range. Any value less than the lower limit is set to the lower limit, and
any value greater than the upper limit is set to the upper limit.

For objects with complex elements, the real and imaginary components are
clamped separately.

If the input is a sparse matrix, only the non-zero elements are clamped.

## Example

```cpp
[[cpp11::register]] doubles_matrix<> clamp1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = clamp(A, 0.2, 0.8);
  mat C = clamp(A, A.min(), 0.8);
  mat D = clamp(A, 0.2, A.max());

  mat res = B + C + D;

  return as_doubles_matrix(res);
}
```

# Condition number of matrix {#cond}

The `cond()` function computes the condition number of a matrix. The condition
number is the ratio of the largest singular value to the smallest singular
value. It is a measure of how well the matrix can be inverted, a matrix with a
value close to 1 is well-conditioned, and a matrix with a large value is
ill-conditioned. The computation is based on the singular value decomposition.

## Examples

```cpp
[[cpp11::register]] double cond1_(const int& n) {
  mat A(n, n);
  A.eye(); // the identity matrix has a condition number of 1

  double cond_num = cond(A);

  return cond_num;
}
```

## Caveat

Calculating the approximate reciprocal condition number via `rcond()` is
considerably more efficient.

# Obtain complex conjugate of each element {#conj}

The `conj()` function computes the complex conjugate of each element in a
complex matrix or cube.

## Examples

```cpp
[[cpp11::register]] list conj1_(const int& n) {
  cx_mat X(n, n, fill::randu);
  cx_mat Y = conj(X);
  return as_complex_matrix(Y);
}
```

# Convert/cast between matrix types {#conv_to}

The `conv_to()` function converts a matrix or cube to a different type. It can
convert `mat` to `imat`, `cube` to `icube`, `mat` into `colvec` or any other
casting that preserves data (e.g., a matrix that cannot be interpreted as a
vector is not a valid casting). It can also be used to convert a matrix/vector
into a `std::vector` object.

Usage:

```cpp
conv_to<type>::from(X) 
```

## Examples

```cpp
[[cpp11::register]] doubles conv_to1_(const int& n) {
  mat A(n, n, fill::randu);
  fmat B = conv_to<fmat>::from(A);

  std::vector<double> x(B.n_elem);

  int i, N = static_cast<int>(B.n_elem);
  for (i = 0; i < N; ++i) { x[i] = B(i); }

  colvec y = conv_to<colvec>::from(x);
  std::vector<double> z = conv_to<std::vector<double>>::from(y);

  return as_doubles(z);
}
```

## Caveat

To convert an expression that results in a 1x1 matrix to a pure scalar value,
use `as_scalar()`.

# Cross product {#cross}

The `cross()` function computes the cross product of two vectors under the
assumption that the vectors are three-dimensional.

## Examples

```cpp
[[cpp11::register]] doubles cross1_(const int& n) {
  vec A(n, fill::randu);
  vec B(n, fill::randu);

  vec C = cross(A, B);

  return as_doubles(C);
}
```

# Cumulative sum {#cumsum}

The `cumsum()` function computes the cumulative sum of elements in a vector or
matrix. For a vector, it returns a vector of the same orientation. For a matrix,
it returns a matrix with the cumulative sum along the specified dimension (the
default is along columns with `dimension = 0`).

Usage:

```cpp
cumsum(vector);
cumsum(matrix, dimension); // dimension = 0 -> cumulative sum along columns
                           // dimension = 1 -> cumulative sum along rows
```

## Examples

```cpp
[[cpp11::register]] doubles cumsum1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = cumsum(A);
  mat C = cumsum(A, 1);

  vec x(n, fill::randu);
  vec y = cumsum(x);

  writable::doubles res(3);
  res[0] = accu(B);
  res[1] = accu(C);
  res[2] = accu(y);
  
  return res;
}
```

# Cumulative product {#cumprod}

The `cumprod()` function computes the cumulative product of elements in a vector
or matrix. For a vector, it returns a vector of the same orientation. For a
matrix, it returns a matrix with the cumulative product along the specified
dimension (the default is along columns with `dimension = 0`).

Usage:

```cpp
cumprod(vector);
cumprod(matrix, dimension); // dimension = 0 -> cumulative prod along columns
                            // dimension = 1 -> cumulative prod along rows
```

## Examples

```cpp
[[cpp11::register]] doubles cumprod1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = cumprod(A);
  mat C = cumprod(A, 1);

  vec x(n, fill::randu);
  vec y = cumprod(x);

  writable::doubles res(3);
  res[0] = accu(B);
  res[1] = accu(C);
  res[2] = accu(y);
  
  return res;
}
```

# Determinant {#det}

The `det()` function computes the determinant of a square matrix. It is based
on the LU decomposition. If the input is a not a square matrix, the function
throws a `std::runtime_error` exception.

Usage:

```
val = det(X); // store a scalar
det(val, A); // store the determinant in val and return true if successful
```

If the calculation fails:

* `val = det(A)` throws a `std::runtime_error` exception
* `det(val,A)` returns a bool set to false (exception is not thrown)

## Examples

```cpp
[[cpp11::register]] doubles det1_(const int& n) {
  mat A(n, n, fill::randu);
  double val1 = det(A);

  double val2;
  mat B(n, n, fill::randu);
  bool success2 = det(val2, B);

  return writable::doubles({val1, val2, static_cast<double>(success2)});
}
```

# Generate diagonal matrix from given matrix or vector {#diagmat}

The `diagmat()` function generates a diagonal matrix from a given vector or
matrix. If the input is a vector, the output is a square matrix with the vector
as the diagonal. If the input is a matrix, the output is a square matrix with
the diagonal elements from the input matrix. Any element outside the diagonal
is set to zero. The default is the main diagonal (`k = 0`).

Usage:

```cpp
diagmat(vector);
diagmat(matrix);
diagmat(matrix, k); // k = 0 -> main diagonal
                    // k > 0 -> above main diagonal
                    // k < 0 -> below main diagonal
```

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> diagmat1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = diagmat(A);
  mat C = diagmat(A, 1);

  vec v(n, fill::randu);
  mat D = diagmat(v); // NxN diagonal matrix
  mat E = diagmat(v, 1); // (N+1)x(N+1) diagonal matrix

  mat res = B + C + D;  
  res += E.submat(0, 0, 1, 1); // the result is an upper triangular matrix

  return as_doubles_matrix(res);
}
```

# Extract specified diagonal {#diagvec}

The `diagvec()` function extracts the specified diagonal from a matrix. The
default is the main diagonal (`k = 0`).

Usage:

```cpp
diagvec(matrix);
diagvec(matrix, k); // k = 0 -> main diagonal
                    // k > 0 -> above main diagonal
                    // k < 0 -> below main diagonal
```

## Examples

```cpp
[[cpp11::register]] doubles diagvec1_(const int& n) {
  mat A(n, n, fill::randu);
  vec B = diagvec(A);
  vec C = diagvec(A, 1);

  vec res = B.subvec(0, 1) + C;

  return as_doubles(res);
}
```

# Generate a dense matrix with diagonals specified by column vectors {#diags}

The `diags()` function generates a dense matrix with diagonals specified by
column vectors from an input matrix and a vector to indicate the diagonals.

Usage:

```cpp
diags(matrix, vector, number_of_rows, number_of_columns);
```

Each element in the input vector specifies diagonal `k`, where:

* `k = 0` is the main diagonal
* `k > 0` is above the main diagonal
* `k < 0` is below the main diagonal

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> diags1_(const int& n) {
  mat V(n, n, fill::randu);
  ivec D = {0, -1};
  mat X = diags(V, D, n, n); // lower triangular matrix
  return as_doubles_matrix(X);
}
```

# Differences between adjacent elements {#diff}

The `diff()` function computes the differences between adjacent elements in a
vector or matrix. For a vector, the output is a vector of length `n-k` (the
default is `k = 1`). For a matrix, the output is a matrix with `n-k` rows
when `dim = 0` (the default) and `m-k` columns when `dim = 1`. If `k` is greater
than the length of the vector or the number or rows/columns, the output is an
empty vector/matrix.

Usage:

```cpp
diff(vector);
diff(vector, k);

diff(matrix);
diff(matrix, k);
diff(matrix, k, dim); // dim = 0 -> differences along columns
                      // dim = 1 -> differences along rows
```

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> diff1_(const int& n) {
  vec a = randu<vec>(n);
  vec b = diff(a);

  mat res(n, 2, fill::zeros);
  
  res.col(0) = a;

  for (int i = 1; i < n; ++i) {
    res(i, 1) = b(i - 1);
  }

  return as_doubles_matrix(res);
}
```

# Dot product {#dot}

The `dot()`, `cdot()`, and `norm_dot()` functions compute the dot product of two
vectors. The `cdot()` function computes the complex conjugate dot product, and
the `norm_dot()` function computes the dot product and normalises the result by
the product of the Euclidean norms of the input vectors.

## Examples

```cpp
[[cpp11::register]] doubles dot1_(const int& n) {
  vec A(n, fill::randu);
  vec B(n, fill::randu);
  return writable::doubles({dot(A, B), cdot(A, B), norm_dot(A, B)});
}
```

## Caveat

`norm()` is more robust for calculating the norm, as it handles underflows and
overflows.

# Generate a sparse matrix with diagonals specified by column vectors {#spdiags}

The `spdiags()` function generates a sparse matrix with diagonals specified by
column vectors from an input matrix and a vector to indicate the diagonals.

Usage:

```cpp
spdiags(matrix, vector, number_of_rows, number_of_columns);
```

Each element in the input vector specifies diagonal `k`, where:

* `k = 0` is the main diagonal
* `k > 0` is above the main diagonal
* `k < 0` is below the main diagonal

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> spdiags1_(const int& n) {
  mat V(n, n, fill::randu);
  ivec D = {0, -1};
  sp_mat X = spdiags(V, D, n, n); // lower triangular matrix
  return as_doubles_matrix(X);
}
```

# Obtain distance of each element to next largest floating point representation {#eps}

The `eps()` function computes the distance of each element in a scalar, vector
or  matrix to the next largest floating point representation. For vector input,
the output is a vector of the same orientation and length. For matrix input,
the output is a matrix of the same dimensions.

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> eps1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = eps(A);
  return as_doubles_matrix(B);
}
```

# Matrix exponential {#expmat}

The `expmat()` function computes the matrix exponential of a square matrix. If
the matrix exponential cannot be computed, the function throws a
`std::runtime_error`, same if the input is not a square matrix.

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> expmat1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = expmat(A);
  return as_doubles_matrix(B);
}
```

## Caveats

* The matrix exponential operation is generally not the same as applying the
  `exp()` function to each element.
* If the input matrix is symmetric, `expmat_sym()` is faster.

# Matrix exponential of symmetric matrix {#expmat_sym}

The `expmat_sym()` function computes the matrix exponential of a symmetric or
Hermitian matrix. If the matrix exponential cannot be computed, the function
throws a `std::runtime_error`, same if the input is not a square matrix.

## Examples

```cpp
[[cpp11::register]] doubles_matrix<> expmat_sym1_(const int& n) {
  mat A(n, n, fill::randu);
  A = A + A.t(); // make A symmetric
  mat B = expmat_sym(A);
  return as_doubles_matrix(B);
}
```

# Find indices of non-zero elements, or elements satisfying a relational condition {#find}

The `find()` function returns the indices of non-zero elements in a vector,
or that satisfy a relational condition in a vector or matrix. The output is a
vector of indices (`uvec`).

Usage:

```cpp
find(vector);
find(vector, k);
find(vector, k, s);

find(matrix);
find(matrix, k);
find(matrix, k, s);
```

The parameter `k` (`k=0` by default) returns the indices of all non-zero
elements or elements that meet the condition. The optional parameter
`s = "first"` returns the first `m` non-zero indices or indices that meet the
condition, and `s = "last"` returns the last `m` non-zero indices or indices
that meet the condition.

## Examples

```cpp
[[cpp11::register]] list find1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B(n, n, fill::randu);

  uvec q1 = find(A > B);
  uvec q2 = find(A > 0.5);
  uvec q3 = find(A > 0.5, 3, "last");

  // change elements of A greater than 0.5 to 1
  A.elem(find(A > 0.5)).ones();

  return writable::list(as_integers(q1), as_integers(q2), as_integers(q3));
}
```

## Caveats

* To clamp values to an interval, `clamp()` is more efficient.
* To replace a specific value, `.replace()` is more efficient.

# Find indices of finite elements {#find_finite}

The `find_finite()` function returns the indices of finite elements in a vector
or matrix. The output is a vector of indices (`uvec`).

## Examples

```cpp
[[cpp11::register]] integers find_finite1_(const int& n) {
  mat A(n, n, fill::randu);
  uvec q = find_finite(A);
  return as_integers(q);
}
```

# Find indices of non-finite elements {#find_nonfinite}

The `find_nonfinite()` function returns the indices of non-finite elements in a
vector or matrix. The output is a vector of indices (`uvec`).

## Examples

```cpp
[[cpp11::register]] integers find_nonfinite1_(const int& n) {
  mat A(n, n, fill::randu);
  A(0, 0) = datum::inf;
  uvec q = find_nonfinite(A);
  return as_integers(q);
}
```

## Caveat

To replace instances of a specific non-finite value (eg. `NaN` or `Inf`), it is
more efficient to use `.replace()`.

# Find indices of NaN elements {#find_nan}

The `find_nan()` function returns the indices of NaN elements in a vector or
matrix. The output is a vector of indices (`uvec`).

## Examples

```cpp
[[cpp11::register]] integers find_nan1_(const int& n) {
  mat A(n, n, fill::randu);
  A(0, 0) = datum::nan;
  uvec q = find_nan(A);
  return as_integers(q);
}
```

## Caveat

To replace instances of `NaN` values, it is more efficient to use `.replace()`.

# Find indices of unique elements {#find_unique}

The `find_unique()` function returns the indices of unique elements in a vector
or matrix. The output is a vector of indices (`uvec`).

## Examples

```cpp
[[cpp11::register]] integers find_unique1_(const int& n) {
  mat A(n, n, fill::randu);
  A(0, 0) = A(1, 1);
  uvec q = find_unique(A);
  return as_integers(q);
}
```

# Flip matrix left to right or upside down {#fliplr}

The `fliplr()` function generates a copy of the input matrix with the order of
the columns reversed, and the `flipud()` function generates a copy of the input
matrix with the order of the rows reversed.

## Examples

```cpp
[[cpp11::register]] list flip1_(const int& n) {
  mat A(n, n, fill::randu);
  mat B = fliplr(A);
  mat C = flipud(A);

  writable::list res(3);
  res[0] = as_doubles_matrix(A);
  res[1] = as_doubles_matrix(B);
  res[2] = as_doubles_matrix(C);

  return res;
}
```

# Extract imaginary/real part {#imag}

The `imag()` and `real()` functions extract the imaginary and real parts of
each element in a complex matrix, respectively.

## Examples

```cpp
[[cpp11::register]] list imag1_(const int& n) {
  cx_mat X(n, n, fill::randu);
  mat Y = imag(X);
  mat Z = real(X);

  writable::list res(2);
  res[0] = as_doubles_matrix(Y);
  res[1] = as_doubles_matrix(Z);

  return res;
}
```

## Caveat

To convert a complex matrix to a list of real matrices, it is more efficient to
use `as_complex_matrix()`.

# Convert linear index to subscripts {#ind2sub}

The `ind2sub()` function converts a linear index or vector of indexes to
subscripts. The output is a vector of indices (`uvec`) if the input index is a
scalar, and a matrix of indices (`umat`) if the input index is a vector.

Usage:

```cpp
uvec sub = ind2sub(size(X), index)
uvec sub = ind2sub(size(n_rows, n_cols), index)
uvec sub = ind2sub(size(n_rows, n_cols, n_slices), index)

umat sub = ind2sub(size(X), vector_of_indices)
umat sub = ind2sub(size(n_rows, n_cols), vector_of_indices)
umat sub = ind2sub(size(n_rows, n_cols, n_slices), vector_of_indices)
```

## Examples

```cpp
[[cpp11::register]] list ind2sub1_(const int& n) {
  mat M(n, n, fill::randu);

  uvec s = ind2sub(size(M), n);

  uvec indices = find(M > 0.5);
  umat t       = ind2sub(size(M), indices);

  cube Q(2,3,4);

  uvec u = ind2sub(size(Q), 8);

  writable::list res(3);
  res[0] = as_integers(s);
  res[1] = as_integers_matrix(t);
  res[2] = as_integers(u);

  return res;
}
```

# Indices of extremum values {#index_min}

The `index_min()` and `index_max()` functions return the indices of the minimum
and maximum values in a vector, matrix or cube. For an input vector, the output
is a scalar index (`uword`). For an input matrix, the output is a vector of
indices (`uvec`) with row orientation for the argument `dim = 0` (default) with
the min/max for each column, and column orientation for `dim = 1` with the
min/max for each row. For an input cube, the output is a cube of indices
(`ucube`) with the min/max for each slice's columns when `dim = 0`, the min/max
for each slice's rows when `dim = 1`, and the min/max for each slice when
`dim = 2`. For complex objects, the absolute value is used to compare the
elements.

Usage:

```cpp
// index_max is analogous

index_min(vector)

index_min(matrix)
index_min(matrix, dim)

index_min(cube)
index_min(cube, dim)
```

## Examples

```cpp
[[cpp11::register]] doubles index_min1_(const int& n) {
  vec v(n, fill::randu);

  uword i = index_max(v);
  double max_val_in_v = v(i);


  mat M(n, n + 1, fill::randu);

  urowvec ii = index_max(M);
  ucolvec jj = index_max(M, 1);

  // max values in col 0 and row n
  return writable::doubles res({M(ii(0), 0), M(n, jj(n))});
}
```
